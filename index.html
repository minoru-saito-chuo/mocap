<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mocap Plus | モーションキャプチャ統合解析ツール</title>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">

    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>

    <style>
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            background-color: #f1f5f9; /* slate-100 */
        }
        .chart-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        .loader, .download-loader {
            border: 6px solid #e5e7eb;
            border-radius: 50%;
            border-top: 6px solid #3b82f6;
            width: 50px;
            height: 50px;
            animation: spin 1.5s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .page {
            display: none;
        }
        .page.active {
            display: block;
            animation: fadeIn 0.2s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .nav-link.active {
            background-color: #e2e8f0; /* slate-200 */
            color: #1e293b; /* slate-800 */
        }

        /* Mobile Menu Overlay */
        #mobile-menu-overlay {
            transition: opacity 0.3s ease-in-out;
        }
        #mobile-menu-content {
            transition: transform 0.3s ease-in-out;
        }
        body.mobile-menu-open {
            overflow: hidden;
        }

        #redraw-charts-btn:active {
            transform: scale(0.95);
            transition: transform 0.1s ease-in-out;
        }

        /* macOS like scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
        }
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        ::-webkit-scrollbar-thumb {
            background-color: #cbd5e1; /* slate-300 */
            border-radius: 20px;
            border: 3px solid #f1f5f9; /* slate-100 */
        }
        .prose-styles h3 {
            font-size: 1.125rem;
            font-weight: 600;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            padding-bottom: 0.25em;
            border-bottom: 1px solid #e2e8f0;
        }
        .prose-styles h4 {
            font-size: 1.05rem;
            font-weight: 600;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
        }
        .prose-styles p {
            font-size: 0.95rem;
            line-height: 1.6;
            margin-bottom: 1em;
        }
        .prose-styles .formula-block {
            background-color: #f8fafc;
            padding: 1rem;
            border-radius: 0.5rem;
            margin: 1.5rem 0;
            overflow-x: auto;
            text-align: center;
        }
        .tab-btn.active {
            background-color: #3b82f6;
            color: white;
        }
    </style>
</head>
<body class="antialiased text-slate-700">
    <div id="loading" class="hidden fixed top-0 left-0 w-full h-full bg-white/80 backdrop-blur-sm flex justify-center items-center z-50">
        <div class="text-center"><div class="loader mx-auto"></div><p id="loading-text" class="text-slate-700 mt-4">解析中...</p></div>
    </div>
    <div id="download-overlay" class="hidden fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm flex justify-center items-center z-50">
         <div class="text-center"><div class="download-loader mx-auto"></div><p class="text-white mt-4">エクスポート用の画像を生成中...</p></div>
    </div>

    <div class="flex min-h-screen bg-slate-100">
        <aside class="hidden lg:flex flex-col w-60 bg-slate-200/50 backdrop-blur-xl border-r border-slate-300/50 h-screen sticky top-0">
            <div class="flex items-center justify-center h-16 border-b border-slate-300/50 px-4">
                <img src="icons/icon-192.png" style="width: 25px; height: auto;">
                <h1 class="text-lg font-bold text-slate-800 ml-2">Mocap Plus</h1>
            </div>
            <nav class="flex-1 px-3 py-4 space-y-1">
                <a class="nav-link flex items-center px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-200 rounded-md transition-colors duration-150" href="#home">
                    <svg class="h-5 w-5 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" /></svg>
                    <span>ホーム</span>
                </a>
                <a class="nav-link flex items-center px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-200 rounded-md transition-colors duration-150" href="#data-analysis">
                    <svg class="h-5 w-5 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M3 3v18h18"></path>
                      <path stroke-linecap="round" stroke-linejoin="round" d="M18 17V9"></path>
                      <path stroke-linecap="round" stroke-linejoin="round" d="M13 17V5"></path>
                      <path stroke-linecap="round" stroke-linejoin="round" d="M8 17v-3"></path>
                    </svg>
                    <span>データ解析ツール</span>
                </a>
                <a class="nav-link flex items-center px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-200 rounded-md transition-colors duration-150" href="#wide-area-analysis">
                    <svg class="h-5 w-5 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M9 20l-5.447-2.724A1 1 0 0 1 3 16.382V5.618a1 1 0 0 1 1.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0 0 21 18.382V7.618a1 1 0 0 0-.553-.894L15 4m0 13V4m0 0L9 7"></path>
                    </svg>
                    <span>広域解析ツール</span>
                </a>
                <a class="nav-link flex items-center px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-200 rounded-md transition-colors duration-150" href="#standard-velocity">
                    <svg class="h-5 w-5 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M15.6 3.3a10 10 0 1 0 5.7 5.7"></path>
                      <circle cx="12" cy="12" r="2"></circle>
                      <path stroke-linecap="round" stroke-linejoin="round" d="M13.4 10.6 19 5"></path>
                    </svg>
                    <span>基準速度算出ツール</span>
                </a>
                <div class="pt-4 mt-4 border-t border-slate-300/60">
                    <a class="nav-link flex items-center px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-200 rounded-md transition-colors duration-150" href="#how-to-use">
                        <svg class="h-5 w-5 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                          <circle cx="12" cy="12" r="9" stroke-linecap="round" stroke-linejoin="round" />
                          <path stroke-linecap="round" stroke-linejoin="round" d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3" />
                          <path stroke-linecap="round" stroke-linejoin="round" d="M12 17h.01" />
                        </svg>
                        <span>使い方ガイド</span>
                    </a>
                    <a class="nav-link flex items-center px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-200 rounded-md transition-colors duration-150" href="#algorithms">
                        <svg class="h-5 w-5 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                        </svg>
                        <span>アルゴリズム仕様</span>
                    </a>
                    <a class="nav-link flex items-center px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-200 rounded-md transition-colors duration-150" href="#about">
                         <svg class="h-5 w-5 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                        <span>このツールについて</span>
                    </a>
                </div>
            </nav>
        </aside>

        <div id="main-content-area" class="flex flex-col flex-1">
             <header class="lg:hidden flex items-center justify-between bg-white/70 backdrop-blur-lg p-4 border-b sticky top-0 z-10">
                <button id="mobile-menu-btn" class="p-2 -ml-2">
                    <svg class="h-6 w-6 text-slate-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
                    </svg>
                </button>
                <h1 id="mobile-title" class="text-lg font-semibold text-slate-800">ホーム</h1>
                <div class="w-6"></div> </header>

            <main class="p-4 sm:p-6 md:p-8">
                <div id="home" class="page">
                    <div class="max-w-5xl mx-auto">
                        <div class="bg-white p-8 rounded-xl shadow-sm border">
                            <h1 class="text-3xl font-bold text-slate-800 mb-2">Mocap Plus へようこそ</h1>
                            <p class="text-slate-600 mb-8">OptiTrackの解析ソフト「Motive」からエクスポートされたcsvファイルを添付するだけで、モーションキャプチャのデータを簡単に解析することができる統合ツールです。</p>
                            <div class="grid md:grid-cols-3 gap-6">
                                <a href="#data-analysis" class="nav-card group block bg-slate-50 p-6 rounded-lg border transition-all duration-300 hover:shadow-lg hover:border-blue-300 hover:-translate-y-1">
                                    <h2 class="text-xl font-semibold text-slate-800 mb-2">データ解析</h2>
                                    <p class="text-slate-600">速度、スリップ率などを計算し、グラフで可視化します。</p>
                                </a>
                                <a href="#wide-area-analysis" class="nav-card group block bg-slate-50 p-6 rounded-lg border transition-all duration-300 hover:shadow-lg hover:border-purple-300 hover:-translate-y-1">
                                    <h2 class="text-xl font-semibold text-slate-800 mb-2">広域解析</h2>
                                    <p class="text-slate-600">広範囲の移動軌跡とヒートマップを生成し、網羅率を計算します。</p>
                                </a>
                                <a href="#standard-velocity" class="nav-card group block bg-slate-50 p-6 rounded-lg border transition-all duration-300 hover:shadow-lg hover:border-green-300 hover:-translate-y-1">
                                    <h2 class="text-xl font-semibold text-slate-800 mb-2">基準速度の算出</h2>
                                    <p class="text-slate-600">車輪の回転周期から基準となる速度を計算します。</p>
                                </a>
                            </div>
                        </div>

                        <div class="mt-10">
                            <h2 class="text-2xl font-bold text-slate-800 mb-4">お知らせ</h2>
                            <div class="space-y-4">
                                <!-- MODIFICATION: Added new development log -->
                                <div class="bg-white p-5 rounded-xl shadow-sm border">
                                    <p class="text-sm text-slate-500">2025/10/20</p>
                                    <p class="font-semibold text-slate-800 mt-1">「広域解析ツール」を追加</p>
                                    <p class="text-sm text-slate-600 mt-2">広範囲の移動軌跡や滞在頻度を可視化するヒートマップ機能、指定範囲に対する網羅率を計算する機能を追加しました。</p>
                                </div>
                                 <div class="bg-white p-5 rounded-xl shadow-sm border">
                                    <p class="text-sm text-slate-500">2025/08/07</p>
                                    <p class="font-semibold text-slate-800 mt-1">機能とUIを改善</p>
                                    <p class="text-sm text-slate-600 mt-2">データ解析ツールでファイルを後からでも追加できるよう修正。スクロールしたときにメニューが固定されるようUIを改善。</p>
                                </div>
                                <div class="bg-white p-5 rounded-xl shadow-sm border">
                                    <p class="text-sm text-slate-500">2025/08/05</p>
                                    <p class="font-semibold text-slate-800 mt-1">機能改善とアルゴリズム修正</p>
                                    <p class="text-sm text-slate-600 mt-2">ローパスフィルタに「ガウシアンフィルタ」を追加し、ユーザが選択できるようにしました。また、往復運動があるデータでも正確に動作区間を検出できるよう、アルゴリズムを修正しました。</p>
                                </div>
                                <div class="bg-white p-5 rounded-xl shadow-sm border">
                                    <p class="text-sm text-slate-500">2025/07/04</p>
                                    <p class="font-semibold text-slate-800 mt-1">分散の表示とローパスフィルタの追加</p>
                                    <p class="text-sm text-slate-600 mt-2">データ解析ツールに分散表示機能と、ユーザが任意に設定できるローパスフィルタ機能を追加しました。</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="page" id="data-analysis">
                    <div class="max-w-7xl mx-auto space-y-8">
                        <header class="text-center">
                            <h1 class="text-3xl font-bold text-slate-800">データ解析ツール</h1>
                            <p class="text-slate-500 mt-2">CSVファイルをアップロードして、剛体の運動を解析します。</p>
                        </header>

                        <section class="bg-white p-6 rounded-lg shadow-sm border">
                            <h2 class="text-xl font-semibold text-center mb-6">1. データ入力</h2>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-6">
                                <div>
                                    <label for="csv-files" class="block text-sm font-medium text-slate-700 mb-2">① CSVファイルを追加</label>
                                    <div class="flex items-center space-x-2">
                                        <input type="file" id="csv-files" multiple accept=".csv" class="hidden">
                                        <label for="csv-files" class="w-full cursor-pointer bg-slate-100 hover:bg-slate-200 text-slate-700 font-semibold py-2 px-4 rounded-md text-sm text-center">ファイルを追加</label>
                                        <button id="clear-files-btn" class="flex-shrink-0 bg-slate-200 hover:bg-slate-300 text-slate-700 font-semibold py-2 px-3 rounded-md text-xs shadow-sm">クリア</button>
                                    </div>
                                    <div id="file-list" class="mt-4 space-y-2"></div>
                                    <div class="mt-4 p-3 bg-yellow-50 border-l-4 border-yellow-400 text-yellow-800 text-xs rounded-r-lg">
                                        <strong>注意:</strong> 1分以上のデータは処理に時間がかかることがあります。また、直線運動以外の複雑な動作では、動作区間が誤って検出される可能性があります。
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-slate-700 mb-2">② 元データの単位</label>
                                    <div class="flex items-center space-x-4 mt-2">
                                        <label class="flex items-center">
                                            <input type="radio" name="data-unit" value="mm" class="form-radio" checked>
                                            <span class="ml-2 text-sm">mm</span>
                                        </label>
                                        <label class="flex items-center">
                                            <input type="radio" name="data-unit" value="m" class="form-radio">
                                            <span class="ml-2 text-sm">m</span>
                                        </label>
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-slate-700 mb-2">③④ 方向の定義</label>
                                    <div class="flex space-x-4">
                                        <div class="flex-1">
                                            <label for="travel-axis" class="block text-xs font-medium text-slate-500">進行方向</label>
                                            <select id="travel-axis" class="mt-1 w-full bg-white border-slate-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 text-sm">
                                                <option value="X">X</option><option value="Y">Y</option><option value="Z" selected>Z</option>
                                            </select>
                                        </div>
                                        <div class="flex-1">
                                            <label for="vertical-axis" class="block text-xs font-medium text-slate-500">鉛直方向</label>
                                            <select id="vertical-axis" class="mt-1 w-full bg-white border-slate-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 text-sm">
                                                <option value="X">X</option><option value="Y" selected>Y</option><option value="Z">Z</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                                <div class="md:col-span-2">
                                     <details class="bg-slate-50/70 border rounded-md p-4">
                                        <summary class="font-medium text-slate-700 text-sm">動作検出の高度な設定</summary>
                                        <div class="mt-4 pt-4 border-t">
                                            <label for="motion-threshold-multiplier" class="block text-sm font-medium text-slate-600">静止範囲の倍率</label>
                                            <input type="number" id="motion-threshold-multiplier" value="0.001" step="0.001" class="mt-1 block w-full rounded-md shadow-sm p-2 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500">
                                            <p class="text-xs text-slate-500 mt-1">データ全体の振れ幅(最大値-最小値)にこの倍率を掛けた値を、静止範囲のマージンとして使用します。</p>
                                        </div>
                                     </details>
                                </div>
                            </div>
                        </section>

                        <section id="rigidbody-selection-section" class="bg-white p-6 rounded-lg shadow-sm border hidden">
                            <h2 class="text-xl font-semibold text-center mb-6">2. 解析対象の剛体を選択</h2>
                            <div id="rigidbody-list" class="space-y-4"></div>
                            <div class="mt-6 text-center">
                                <button id="start-analysis-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-8 rounded-md shadow-sm transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                                    解析開始
                                </button>
                            </div>
                        </section>

                        <div id="results-section" class="hidden space-y-8">
                            <section class="bg-white p-6 rounded-lg shadow-sm border">
                                <h2 class="text-xl font-semibold text-center mb-6">3. 解析結果</h2>
                                <div id="avg-velo-filter-section" class="mb-6 p-4 bg-slate-50/70 rounded-md border">
                                    <h4 class="font-medium text-slate-700 mb-3 text-sm">平均速度の計算設定</h4>
                                    <div class="flex items-center space-x-3"><input type="checkbox" id="filter-velocity-checkbox" class="h-4 w-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500"><label for="filter-velocity-checkbox" class="text-sm font-medium text-slate-700">微小な速度を計算から除外する</label></div>
                                    <div id="filter-range-inputs" class="hidden mt-3 flex items-center space-x-4 pl-7">
                                        <div><label for="filter-lower-bound" class="block text-xs font-medium text-slate-600">下限値 (m/s)</label><input type="number" id="filter-lower-bound" value="-0.01" step="0.01" class="mt-1 block w-32 rounded-md shadow-sm p-1.5 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500"></div>
                                        <div><label for="filter-upper-bound" class="block text-xs font-medium text-slate-600">上限値 (m/s)</label><input type="number" id="filter-upper-bound" value="0.01" step="0.01" class="mt-1 block w-32 rounded-md shadow-sm p-1.5 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500"></div>
                                        <div class="pt-5"><button id="recalculate-avg-btn" class="bg-slate-600 hover:bg-slate-700 text-white font-semibold py-1 px-3 rounded-md text-xs shadow-sm">再計算</button></div>
                                    </div>
                                </div>
                                <div id="average-velocities" class="mb-6"></div>
                                <p class="text-xs text-slate-500 mb-4">※平均速度及び平均スリップ率は、静止範囲として設定している倍率により大きく変動します。</p>
                                <button id="download-velocity-csv" class="bg-slate-600 hover:bg-slate-700 text-white font-semibold py-2 px-4 rounded-md shadow-sm text-sm">微小速度データをCSVでダウンロード</button>
                            </section>

                            <section class="bg-white p-6 rounded-lg shadow-sm border">
                                <div class="flex flex-wrap justify-between items-center mb-6 text-center border-b pb-4">
                                    <h2 class="text-xl font-semibold w-full sm:w-auto text-center sm:text-left">4. グラフ</h2>
                                    <div class="flex items-center space-x-2 mt-4 sm:mt-0 mx-auto sm:mx-0">
                                        <span class="text-sm text-slate-600">スタイル:</span>
                                        <button id="style-casual" class="style-btn bg-blue-600 text-white px-3 py-1 rounded-l-md text-sm font-medium">カジュアル</button>
                                        <button id="style-formal" class="style-btn bg-slate-200 text-slate-700 px-3 py-1 rounded-r-md text-sm font-medium">フォーマル</button>
                                    </div>
                                </div>
                                <div id="graph-customization" class="mt-6">
                                    <div class="mb-8 p-4 bg-slate-50/70 rounded-md border">
                                        <h4 class="font-medium text-slate-700 mb-3 text-sm">グラフ描画設定</h4>
                                        <div class="flex items-center flex-wrap gap-x-6 gap-y-3">
                                            <div class="flex items-center space-x-2">
                                                <label for="lowpass-filter-type" class="text-sm font-medium text-slate-700">ローパスフィルタ:</label>
                                                <select id="lowpass-filter-type" class="block w-36 rounded-md shadow-sm p-1.5 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500">
                                                    <option value="none" selected>適用しない</option>
                                                    <option value="moving-average">移動平均</option>
                                                    <option value="gaussian">ガウシアン</option>
                                                </select>
                                            </div>
                                            <div class="flex items-center space-x-2">
                                                 <label id="lowpass-strength-label" for="lowpass-strength" class="text-sm font-medium text-slate-700">強度:</label>
                                                <input type="number" id="lowpass-strength" value="10" step="0.1" class="block w-20 rounded-md shadow-sm p-1.5 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500" disabled>
                                            </div>
                                            <button id="redraw-charts-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md shadow-sm transition-all duration-150">再描画</button>
                                        </div>
                                        <p id="filter-description" class="text-xs text-slate-500 mt-2">フィルタを選択すると、強度を指定できます。</p>
                                    </div>
                                    <div class="mb-8 p-4 bg-slate-50/70 rounded-md border">
                                         <h4 class="font-medium text-slate-700 mb-3 text-sm">エクスポート設定</h4>
                                         <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                            <div><label for="export-width" class="block text-sm font-medium text-slate-600">画像の幅 (px)</label><input type="number" id="export-width" value="800" step="100" class="mt-1 block w-full rounded-md shadow-sm p-2 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500"></div>
                                            <div><label for="export-height" class="block text-sm font-medium text-slate-600">画像の高さ (px)</label><input type="number" id="export-height" value="450" step="100" class="mt-1 block w-full rounded-md shadow-sm p-2 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500"></div>
                                        </div>
                                    </div>
                                    <h3 class="text-lg font-semibold mb-4 text-slate-700">グラフのラベル編集</h3>
                                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
                                        <div class="space-y-2 p-3 border rounded-md bg-slate-50/50"><h4 class="font-semibold text-center text-slate-700 text-sm">速度 vs 距離</h4><div><label class="text-xs font-medium text-slate-600">タイトル</label><input type="text" id="v-chart-title" data-chart-id="velocity-chart" data-label-type="title" class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300"></div><div><label class="text-xs font-medium text-slate-600">X軸</label><input type="text" id="v-chart-xlabel" data-chart-id="velocity-chart" data-label-type="x" class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300"></div><div><label class="text-xs font-medium text-slate-600">Y軸</label><input type="text" id="v-chart-ylabel" data-chart-id="velocity-chart" data-label-type="y" class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300"></div></div>
                                        <div class="space-y-2 p-3 border rounded-md bg-slate-50/50"><h4 class="font-semibold text-center text-slate-700 text-sm">スリップ率 vs 距離</h4><div><label class="text-xs font-medium text-slate-600">タイトル</label><input type="text" id="s-chart-title" data-chart-id="slip-chart" data-label-type="title" class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300"></div><div><label class="text-xs font-medium text-slate-600">X軸</label><input type="text" id="s-chart-xlabel" data-chart-id="slip-chart" data-label-type="x" class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300"></div><div><label class="text-xs font-medium text-slate-600">Y軸</label><input type="text" id="s-chart-ylabel" data-chart-id="slip-chart" data-label-type="y" class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300"></div></div>
                                        <div class="space-y-2 p-3 border rounded-md bg-slate-50/50"><h4 class="font-semibold text-center text-slate-700 text-sm">鉛直変位 vs 距離</h4><div><label class="text-xs font-medium text-slate-600">タイトル</label><input type="text" id="z-chart-title" data-chart-id="vertical-chart" data-label-type="title" class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300"></div><div><label class="text-xs font-medium text-slate-600">X軸</label><input type="text" id="z-chart-xlabel" data-chart-id="vertical-chart" data-label-type="x" class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300"></div><div><label class="text-xs font-medium text-slate-600">Y軸</label><input type="text" id="z-chart-ylabel" data-chart-id="vertical-chart" data-label-type="y" class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300"></div></div>
                                        <div class="space-y-2 p-3 border rounded-md bg-slate-50/50"><h4 class="font-semibold text-center text-slate-700 text-sm">平面移動軌跡</h4><div><label class="text-xs font-medium text-slate-600">タイトル</label><input type="text" id="t-chart-title" data-chart-id="trajectory-chart" data-label-type="title" class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300"></div><div><label class="text-xs font-medium text-slate-600">X軸</label><input type="text" id="t-chart-xlabel" data-chart-id="trajectory-chart" data-label-type="x" class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300"></div><div><label class="text-xs font-medium text-slate-600">Y軸</label><input type="text" id="t-chart-ylabel" data-chart-id="trajectory-chart" data-label-type="y" class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300"></div></div>
                                    </div>
                                </div>
                                <div class="grid grid-cols-1 lg:grid-cols-2 gap-x-8 gap-y-12 mt-8">
                                    <div>
                                        <div class="w-full aspect-video bg-white p-2 border rounded-lg shadow-sm"><div class="chart-container"><canvas id="velocity-chart"></canvas></div></div>
                                        <div class="text-center mt-3 flex justify-center items-center space-x-2">
                                            <button class="zoom-btn bg-slate-200 hover:bg-slate-300 text-slate-600 h-8 w-8 flex items-center justify-center rounded-md transition-colors" data-chart-id="velocity-chart" title="拡大表示">
                                                <svg class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7" /></svg>
                                            </button>
                                            <button class="download-btn bg-slate-600 hover:bg-slate-700 text-white text-xs h-8 px-3 flex items-center justify-center rounded-md" data-chart-id="velocity-chart" data-format="png">PNG</button>
                                            <button class="download-btn bg-slate-600 hover:bg-slate-700 text-white text-xs h-8 px-3 flex items-center justify-center rounded-md" data-chart-id="velocity-chart" data-format="pdf">PDF</button>
                                        </div>
                                    </div>
                                    <div>
                                        <div class="w-full aspect-video bg-white p-2 border rounded-lg shadow-sm"><div class="chart-container"><canvas id="slip-chart"></canvas></div></div>
                                        <div class="text-center mt-3 flex justify-center items-center space-x-2">
                                            <button class="zoom-btn bg-slate-200 hover:bg-slate-300 text-slate-600 h-8 w-8 flex items-center justify-center rounded-md transition-colors" data-chart-id="slip-chart" title="拡大表示">
                                                <svg class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7" /></svg>
                                            </button>
                                            <button class="download-btn bg-slate-600 hover:bg-slate-700 text-white text-xs h-8 px-3 flex items-center justify-center rounded-md" data-chart-id="slip-chart" data-format="png">PNG</button>
                                            <button class="download-btn bg-slate-600 hover:bg-slate-700 text-white text-xs h-8 px-3 flex items-center justify-center rounded-md" data-chart-id="slip-chart" data-format="pdf">PDF</button>
                                        </div>
                                    </div>
                                    <div>
                                        <div class="w-full aspect-video bg-white p-2 border rounded-lg shadow-sm"><div class="chart-container"><canvas id="vertical-chart"></canvas></div></div>
                                        <div class="text-center mt-3 flex justify-center items-center space-x-2">
                                            <button class="zoom-btn bg-slate-200 hover:bg-slate-300 text-slate-600 h-8 w-8 flex items-center justify-center rounded-md transition-colors" data-chart-id="vertical-chart" title="拡大表示">
                                                <svg class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7" /></svg>
                                            </button>
                                            <button class="download-btn bg-slate-600 hover:bg-slate-700 text-white text-xs h-8 px-3 flex items-center justify-center rounded-md" data-chart-id="vertical-chart" data-format="png">PNG</button>
                                            <button class="download-btn bg-slate-600 hover:bg-slate-700 text-white text-xs h-8 px-3 flex items-center justify-center rounded-md" data-chart-id="vertical-chart" data-format="pdf">PDF</button>
                                        </div>
                                    </div>
                                    <div>
                                        <div class="w-full aspect-video bg-white p-2 border rounded-lg shadow-sm"><div class="chart-container"><canvas id="trajectory-chart"></canvas></div></div>
                                        <div class="text-center mt-3 flex justify-center items-center space-x-2">
                                            <button class="zoom-btn bg-slate-200 hover:bg-slate-300 text-slate-600 h-8 w-8 flex items-center justify-center rounded-md transition-colors" data-chart-id="trajectory-chart" title="拡大表示">
                                                <svg class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7" /></svg>
                                            </button>
                                            <button class="download-btn bg-slate-600 hover:bg-slate-700 text-white text-xs h-8 px-3 flex items-center justify-center rounded-md" data-chart-id="trajectory-chart" data-format="png">PNG</button>
                                            <button class="download-btn bg-slate-600 hover:bg-slate-700 text-white text-xs h-8 px-3 flex items-center justify-center rounded-md" data-chart-id="trajectory-chart" data-format="pdf">PDF</button>
                                        </div>
                                    </div>
                                </div>
                            </section>
                        </div>
                    </div>
                </div>

                <div class="page" id="wide-area-analysis">
                    <div class="max-w-7xl mx-auto space-y-8">
                        <header class="text-center">
                            <h1 class="text-3xl font-bold text-slate-800">広域解析ツール</h1>
                            <p class="text-slate-500 mt-2">CSVファイルをアップロードして、広範囲の移動軌跡や滞在傾向を可視化します。</p>
                        </header>

                        <section id="settings-card-wide" class="bg-white p-6 rounded-lg shadow-sm border">
                            <h2 class="text-xl font-semibold text-center mb-6">1. 設定</h2>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                                <div>
                                    <label for="csv-files-wide" class="block text-sm font-medium text-slate-700 mb-2">① CSVファイルを追加</label>
                                    <div class="flex items-center space-x-2">
                                        <input type="file" id="csv-files-wide" multiple accept=".csv" class="hidden">
                                        <label for="csv-files-wide" class="w-full cursor-pointer bg-slate-100 hover:bg-slate-200 text-slate-700 font-semibold py-2 px-4 rounded-md text-sm text-center">ファイルを追加</label>
                                        <button id="clear-files-btn-wide" class="flex-shrink-0 bg-slate-200 hover:bg-slate-300 text-slate-700 font-semibold py-2 px-3 rounded-md text-xs shadow-sm">クリア</button>
                                    </div>
                                    <div id="file-list-area-wide" class="mt-4 space-y-2"></div>
                                </div>
                                 <div class="space-y-4">
                                     <div>
                                        <label class="block text-sm font-medium text-slate-700 mb-2">② 元データの単位</label>
                                        <div class="flex items-center space-x-4 mt-2">
                                            <label class="flex items-center"><input type="radio" name="data-unit-wide" value="mm" class="form-radio" checked> <span class="ml-2 text-sm">mm</span></label>
                                            <label class="flex items-center"><input type="radio" name="data-unit-wide" value="m" class="form-radio"> <span class="ml-2 text-sm">m</span></label>
                                        </div>
                                     </div>
                                    <div>
                                        <label for="sampling-rate-wide" class="block text-sm font-medium text-slate-700 mb-2">③ データ取得間隔 (秒)</label>
                                        <input type="number" id="sampling-rate-wide" value="1.0" step="0.1" min="0.01" class="block w-full rounded-md shadow-sm p-2 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500">
                                    </div>
                                     <div>
                                        <label for="heatmap-grid-size-wide" class="block text-sm font-medium text-slate-700 mb-2">④ ヒートマップのマス目のサイズ (<span class="unit-label">mm</span>)</label>
                                        <input type="number" id="heatmap-grid-size-wide" value="500" step="100" class="block w-full rounded-md shadow-sm p-2 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500">
                                    </div>
                                     <div>
                                        <label class="block text-sm font-medium text-slate-700 mb-2">⑤ 方向の定義</label>
                                        <div class="flex space-x-4">
                                            <div class="flex-1">
                                                <label for="vertical-axis-wide" class="block text-xs font-medium text-slate-500">鉛直方向の軸</label>
                                                <select id="vertical-axis-wide" class="mt-1 w-full bg-white border-slate-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 text-sm">
                                                    <option value="X">X</option><option value="Y" selected>Y</option><option value="Z">Z</option>
                                                </select>
                                            </div>
                                        </div>
                                     </div>
                                </div>
                            </div>
                            <div id="rigidbody-selection-area-wide" class="mt-6 hidden">
                                <label class="block text-sm font-medium text-slate-700 mb-2">⑤ 解析対象の剛体を選択</label>
                                <div id="rigidbody-list-container-wide" class="space-y-4 p-4 border rounded-md bg-slate-50/70 max-h-60 overflow-y-auto"></div>
                            </div>
                            <div class="text-center mt-8">
                                <button id="analyze-btn-wide" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2.5 px-8 rounded-md shadow-sm transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:bg-slate-400 disabled:cursor-not-allowed disabled:transform-none" disabled>
                                    解析開始
                                </button>
                            </div>
                        </section>

                        <section id="results-card-wide" class="bg-white p-6 rounded-lg shadow-sm border hidden">
                            <h2 class="text-xl font-semibold text-center mb-4">2. 解析結果</h2>
                            <div class="flex justify-center mb-6 border-b">
                                <button id="show-trajectory-btn-wide" class="tab-btn active font-medium py-2 px-6 rounded-t-md transition-colors">軌跡</button>
                                <button id="show-heatmap-btn-wide" class="tab-btn font-medium py-2 px-6 rounded-t-md transition-colors">ヒートマップ</button>
                                <button id="show-3d-trajectory-btn-wide" class="tab-btn font-medium py-2 px-6 rounded-t-md transition-colors">3D軌跡</button>
                            </div>

                            <div id="trajectory-view-wide">
                                <div class="w-full max-w-2xl mx-auto aspect-square bg-white p-2 relative border rounded-lg shadow-sm">
                                    <div class="chart-container"><canvas id="trajectory-chart-wide"></canvas></div>
                                </div>
                                 <div class="text-center mt-4 flex justify-center items-center space-x-2">
                                    <button class="download-btn-wide bg-slate-600 hover:bg-slate-700 text-white text-sm h-9 px-4 flex items-center justify-center rounded-md" data-target="trajectory-chart-wide" data-format="png">PNGで保存</button>
                                    <button class="download-btn-wide bg-slate-600 hover:bg-slate-700 text-white text-sm h-9 px-4 flex items-center justify-center rounded-md" data-target="trajectory-chart-wide" data-format="pdf">PDFで保存</button>
                                </div>
                            </div>

                            <div id="heatmap-view-wide" class="hidden">
                                 <div id="heatmap-container-wide" class="w-full max-w-2xl mx-auto aspect-square relative bg-slate-50 border rounded-lg shadow-sm">
                                    <canvas id="heatmap-canvas-wide"></canvas>
                                    <div id="heatmap-tooltip" class="hidden absolute bg-black/70 text-white text-xs rounded-md px-2 py-1 pointer-events-none shadow-lg"></div>
                                 </div>
                                <div id="heatmap-legend-wide" class="flex justify-end items-center mt-2 max-w-2xl mx-auto space-x-2 text-sm">
                                    <span>Min</span>
                                    <div class="w-32 h-4 rounded-md" style="background: linear-gradient(to right, rgb(0, 0, 255), rgb(0, 255, 255), rgb(0, 255, 0), rgb(255, 255, 0), rgb(255, 0, 0));"></div>
                                    <span>Max (<span id="heatmap-max-value-wide">0</span>)</span>
                                </div>
                                 <div class="text-center mt-4 flex justify-center items-center space-x-2">
                                    <button class="download-btn-wide bg-slate-600 hover:bg-slate-700 text-white text-sm h-9 px-4 flex items-center justify-center rounded-md" data-target="heatmap-canvas-wide" data-format="png">PNGで保存</button>
                                    <button class="download-btn-wide bg-slate-600 hover:bg-slate-700 text-white text-sm h-9 px-4 flex items-center justify-center rounded-md" data-target="heatmap-canvas-wide" data-format="pdf">PDFで保存</button>
                                </div>
                            </div>

                            <div id="trajectory-3d-view-wide" class="hidden">
                                <div id="trajectory-3d-container-wide" class="w-full max-w-2xl mx-auto aspect-square relative bg-slate-50 border rounded-lg shadow-sm">
                                </div>
                            </div>
                                     <p id="coordinate-unit-note" class="text-xs text-slate-500 mt-4 text-center">※ 座標は正規化せず、元データの値をメートル単位に変換して使用しています。</p>

                            <div id="coverage-section-wide" class="mt-8 pt-6 border-t">
                                <h3 class="text-lg font-semibold text-center mb-4 text-slate-800">網羅率の計算</h3>
                                <div class="max-w-2xl mx-auto grid grid-cols-1 md:grid-cols-2 gap-6 p-4 bg-slate-50 border rounded-lg">
                                    <div class="space-y-4">
                                        <div>
                                            <label class="block text-sm font-medium text-slate-700">基準範囲の形状</label>
                                            <div class="mt-2 flex gap-4"><label class="flex items-center"><input type="radio" name="area-shape-wide" value="circle" class="form-radio" checked> <span class="ml-2">円</span></label><label class="flex items-center"><input type="radio" name="area-shape-wide" value="square" class="form-radio"> <span class="ml-2">正方形</span></label></div>
                                        </div>
                                        <div>
                                            <label for="area-size-wide" class="block text-sm font-medium text-slate-700"><span id="area-size-label-wide">半径</span> (<span class="unit-label">mm</span>)</label>
                                            <input type="number" id="area-size-wide" value="2000" step="100" class="mt-1 block w-full rounded-md shadow-sm p-2 text-sm border-slate-300">
                                        </div>
                                         <div>
                                            <label class="block text-sm font-medium text-slate-700">中心座標</label>
                                            <div class="mt-2 flex gap-4"><label class="flex items-center"><input type="radio" name="center-type-wide" value="data" class="form-radio" checked> <span class="ml-2">データの中心</span></label><label class="flex items-center"><input type="radio" name="center-type-wide" value="custom" class="form-radio"> <span class="ml-2">座標指定</span></label></div>
                                        </div>
                                        <div id="custom-center-inputs-wide" class="hidden space-y-2">
                                             <div class="flex items-center gap-2"><label for="center-x-wide" class="text-sm" id="center-x-label-wide">X:</label><input type="number" id="center-x-wide" value="0" step="0.1" class="block w-full rounded-md shadow-sm p-2 text-sm border-slate-300"><label for="center-y-wide" class="text-sm" id="center-y-label-wide">Y:</label><input type="number" id="center-y-wide" value="0" step="0.1" class="block w-full rounded-md shadow-sm p-2 text-sm border-slate-300"></div>
                                        </div>
                                    </div>
                                    <div class="flex flex-col items-center justify-center bg-white p-4 rounded-md border">
                                         <button id="calculate-coverage-btn-wide" class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-2.5 px-6 rounded-md shadow-sm">計算実行</button>
                                         <div class="mt-4 text-center">
                                             <p class="text-sm text-slate-600">網羅率</p>
                                             <p class="text-3xl font-bold text-slate-800 my-1"><span id="coverage-result-wide">--</span> %</p>
                                         </div>
                                    </div>
                                </div>
                            </div>
                        </section>
                    </div>
                </div>


                <div class="page" id="standard-velocity">
                    <div class="max-w-3xl mx-auto space-y-8">
                        <header class="text-center">
                            <h1 class="text-3xl font-bold text-slate-800">基準速度算出ツール</h1>
                            <p class="text-slate-500 mt-2">モーションキャプチャのCSVデータから車輪の基準速度を計算します。</p>
                        </header>

                        <section id="step-1-file-upload-std" class="bg-white p-6 rounded-lg shadow-sm border">
                            <h2 class="text-xl font-semibold text-center mb-6">1. データ入力</h2>
                            <div class="mt-4 flex flex-col items-center gap-3">
                                 <label for="csv-file-input-std" class="cursor-pointer bg-slate-100 hover:bg-slate-200 text-slate-800 font-semibold py-2 px-5 border border-slate-300 rounded-md shadow-sm transition-colors">
                                    ファイルを選択
                                </label>
                                <input type="file" id="csv-file-input-std" class="hidden" accept=".csv">
                                <p id="file-name-display-std" class="text-sm text-slate-500 mt-2">ファイルが選択されていません</p>
                            </div>
                        </section>

                         <div id="loading-indicator-std" class="hidden flex-col items-center justify-center py-10"><div class="loader"></div><p class="text-slate-600 mt-4">ファイルを解析中...</p></div>

                        <section id="step-2-parameters-std" class="hidden bg-white p-6 rounded-lg shadow-sm border">
                            <h2 class="text-xl font-semibold text-center mb-6">2. パラメータ設定</h2>
                             <div class="mt-4 space-y-5 max-w-sm mx-auto">
                                <div>
                                    <label class="block text-sm font-medium text-slate-700">② 車輪の剛体を選択</label>
                                    <div id="rigidbody-radio-container-std" class="mt-2 space-y-2 max-h-40 overflow-y-auto border p-3 rounded-md bg-slate-50/70"></div>
                                </div>
                                <div>
                                    <label for="radius-input-std" class="block text-sm font-medium text-slate-700">③ 車輪の半径 (cm)</label>
                                    <input type="number" id="radius-input-std" value="10" step="1" class="mt-1 block w-full border-slate-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-1 focus:ring-blue-500 text-sm">
                                </div>
                                 <div>
                                    <label for="axis-select-std" class="block text-sm font-medium text-slate-700">④ 車輪の回転軸</label>
                                    <select id="axis-select-std" class="mt-1 block w-full bg-white border-slate-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-1 focus:ring-blue-500 text-sm">
                                        <option value="X">X軸</option><option value="Y" selected>Y軸</option><option value="Z">Z軸</option>
                                    </select>
                                </div>
                            </div>
                            <div class="text-center mt-8">
                                <button id="calculate-btn-std" class="w-full max-w-sm bg-green-600 hover:bg-green-700 text-white font-semibold py-2.5 px-6 rounded-md shadow-sm transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500">
                                    計算開始
                                </button>
                            </div>
                        </section>

                        <section id="step-3-results-std" class="hidden bg-white p-6 rounded-lg shadow-sm border">
                            <h2 class="text-xl font-semibold text-center mb-6">3. 計算結果</h2>
                            <div id="result-display-std" class="hidden mt-6 p-6 bg-slate-50/70 rounded-lg text-center border">
                                 <p class="text-sm text-slate-600">算出された基準速度 (v)</p>
                                <p class="text-4xl font-bold text-slate-800 my-2 tracking-tight">
                                    <span id="result-value-std">0.00000000</span> m/s
                                </p>
                                 <button id="copy-btn-std" class="mt-4 bg-slate-200 hover:bg-slate-300 text-slate-700 font-semibold py-1.5 px-4 rounded-md text-sm transition-colors" data-copy-value="">
                                    結果をコピー
                                </button>
                            </div>
                             <div id="error-display-std" class="hidden mt-6 p-4 bg-red-50 text-red-800 border-l-4 border-red-400 rounded-md"></div>
                        </section>
                    </div>
                </div>

                <div class="page" id="how-to-use">
                    <h1 class="text-2xl font-semibold text-gray-800 mb-8 text-center">使い方ガイド</h1>

                    <div class="space-y-10">
                        <div class="bg-white/70 backdrop-blur-xl rounded-xl border border-gray-200/80 shadow-sm">
                            <div class="p-6 sm:p-8">
                                <h2 class="text-xl font-semibold text-gray-900 flex items-center gap-3 mb-6">
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="h-6 w-6 text-gray-500">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M9 20l-5.447-2.724A1 1 0 0 1 3 16.382V5.618a1 1 0 0 1 1.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0 0 21 18.382V7.618a1 1 0 0 0-.553-.894L15 4m0 13V4m0 0L9 7"></path>
                                    </svg>
                                    <span>広域解析ツール</span>
                                </h2>
                                <div class="space-y-6">
                                    <div class="flex items-start gap-4">
                                        <div class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">1</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-3">設定</h3>
                                            <div class="space-y-3 text-gray-600 text-sm">
                                                <p><strong>① CSVファイルを追加:</strong> 解析したいMotiveのCSVファイルを1つ以上選択します。</p>
                                                <p><strong>② データ取得間隔:</strong> データをサンプリングする時間間隔を秒単位で指定します。短いほど軌跡は詳細になりますが、処理が重くなる場合があります。</p>
                                                <p><strong>③ ヒートマップのマス目サイズ:</strong> 滞在頻度を可視化するヒートマップの1マスの大きさをメートル単位で指定します。</p>
                                                <p><strong>④ 方向の定義:</strong> 座標系における鉛直方向の軸を定義します。</p>
                                                <p><strong>⑤ 解析対象の剛体を選択:</strong> ファイル内の剛体から解析したいものを選択し、必要に応じて凡例名を編集します。</p>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="flex items-start gap-4">
                                        <div class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">2</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-2">解析開始</h3>
                                            <p class="text-gray-600 text-sm">ボタンを押すと解析が実行され、結果が表示されます。</p>
                                        </div>
                                    </div>
                                    <div class="flex items-start gap-4">
                                        <div class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">3</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-3">結果の確認</h3>
                                            <ul class="list-disc list-inside space-y-2 text-gray-600 text-sm">
                                                <li><strong>軌跡タブ:</strong> 選択した剛体の平面移動軌跡をプロットします。</li>
                                                <li><strong>ヒートマップタブ:</strong> 各マスに剛体が滞在した時間の頻度を色で表示します。カーソルを合わせると、そのマスのカウント数が表示されます。</li>
                                                <li><strong>網羅率の計算:</strong> 指定した円または正方形の範囲に対し、軌跡がどれだけの面積をカバーしたかをパーセンテージで計算します。</li>
                                                <li>各グラフはPNGまたはPDF形式でダウンロードできます。</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="bg-white/70 backdrop-blur-xl rounded-xl border border-gray-200/80 shadow-sm">
                            <div class="p-6 sm:p-8">
                                <h2 class="text-xl font-semibold text-gray-900 flex items-center gap-3 mb-6">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-500"><path d="M3 3v18h18"/><path d="M18 17V9"/><path d="M13 17V5"/><path d="M8 17v-3"/></svg>
                                    <span>データ解析ツール</span>
                                </h2>

                                <div class="space-y-6">
                                    <div class="flex items-start gap-4">
                                        <div class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">0</div>
                                        <div class="flex-1">
                                            <h3 class="text-base font-medium text-gray-800 mb-3">データの収集</h3>
                                            <div class="space-y-3 text-gray-600 text-sm">
                                                <p class="text-gray-600 text-sm">解析したい運動のトラッキングデータをキャプチャします。本ツールでは対象物の動作区間は、進行方向の変位データに基づいて自動で検出されます。具体的には、データ全体の振れ幅に対して非常に小さいマージン（デフォルト: 0.1%）を設定し、初期値からそのマージンを超えた瞬間を「動き出し」、データの末尾から逆算してマージン内に入った瞬間を「動き終わり」として判定します。これにより、理論上は一方向の単純な動作だけでなく、往復運動なども含めて動作全体を正確に捉えることができます。</p>

                                                <div class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4" style="max-width: 900px;">
                                                    <div class="aspect-square bg-gradient-to-br from-green-100 to-green-200 rounded-lg shadow-md flex items-center justify-center">
                                                        <div class="text-center">
                                                            <img src="img/simpleForward.png">
                                                            <div class="text-xs font-medium text-gray-700">向いている</div>
                                                        </div>
                                                    </div>
                                                    <div class="aspect-square bg-gradient-to-br from-green-100 to-green-200 rounded-lg shadow-md flex items-center justify-center">
                                                        <div class="text-center">
                                                            <img src="img/simpleHopping.png">
                                                            <div class="text-xs font-medium text-gray-700">向いている</div>
                                                        </div>
                                                    </div>
                                                    <div class="aspect-square bg-gradient-to-br  from-green-100 to-green-200 rounded-lg shadow-md flex items-center justify-center">
                                                        <div class="text-center">
                                                            <img src="img/simpleUpDown.png">
                                                            <div class="text-xs font-medium text-gray-700">向いている</div>
                                                        </div>
                                                    </div>
                                                    <div class="aspect-square bg-gradient-to-br from-yellow-100 to-yellow-200 rounded-lg shadow-md flex items-center justify-center">
                                                        <div class="text-center">
                                                            <img src="img/complex.png">
                                                            <div class="text-xs font-medium text-gray-700">誤検出の可能性あり</div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="flex items-start gap-4">
                                        <div class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">1</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-3">データ入力</h3>
                                            <div class="space-y-3 text-gray-600 text-sm">
                                                <p><strong>① CSVファイルを選択:</strong> 解析したいMotiveのCSVファイルを1つ以上選択します。</p>
                                                <p><strong>② 基準速度:</strong> 各ファイルに対応する車輪などの基準速度を入力します（スリップ率の計算に用います）。</p>
                                                <p><strong>③④ 方向の定義:</strong> 座標系における進行方向と鉛直方向を定義します。</p>
                                                <div class="mt-3 p-3 bg-gray-100/80 rounded-md border border-gray-200/80">
                                                    <p class="font-medium text-gray-700 text-xs">【高度な設定】静止範囲の倍率:</p>
                                                    <p class="text-xs mt-1">対象物の動作区間は、進行方向の変位データに基づいて自動で検出されます。具体的には、データ全体の振れ幅に対して非常に小さいマージン（デフォルト: 0.1%）を設定し、初期値（または最終値）からそのマージンを超えた瞬間をそれぞれ「動き出し」「動き終わり」として判定しています。このため、一方向の単純な動作に対しては高精度に検出できますが、何度も往復するような複雑な動作では、意図しない区間が検出される可能性があります。</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="flex items-start gap-4">
                                        <div class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">2</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-2">解析対象の剛体を選択</h3>
                                            <p class="text-gray-600 text-sm">ファイル内に含まれる剛体の一覧が表示されるので、解析したいものをチェックします。凡例名はグラフのラベルとして使用されます。</p>
                                        </div>
                                    </div>

                                    <div class="flex items-start gap-4">
                                       <div class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">3</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-2">解析開始</h3>
                                            <p class="text-gray-600 text-sm">ボタンを押すと解析が実行されます。</p>
                                        </div>
                                    </div>

                                    <div class="flex items-start gap-4">
                                        <div class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">4</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-3">結果確認と調整</h3>
                                            <ul class="list-disc list-inside space-y-2 text-gray-600 text-sm">
                                                <li>平均速度、スリップ率、およびそれらの分散が表示されます。</li>
                                                <li>微小速度のフィルタリング機能で、静止状態に近い微小な動きを平均速度の計算から除外できます。</li>
                                                <li>ローパスフィルタ機能で、グラフのノイズを低減できます。「移動平均」と「ガウシアン」から選択でき、フィルタ強度も調整可能です。</li>
                                                <li>グラフのラベルを編集したり、スタイル（カジュアル/フォーマル）を変更できます。</li>
                                                <li>各グラフはPNGまたはPDF形式でダウンロードできます。</li>
                                                <li>虫眼鏡アイコンからグラフを拡大表示できます。</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="bg-white/70 backdrop-blur-xl rounded-xl border border-gray-200/80 shadow-sm">
                            <div class="p-6 sm:p-8">
                                <h2 class="text-xl font-semibold text-gray-900 flex items-center gap-3 mb-6">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-500"><path d="M15.6 3.3a10 10 0 1 0 5.7 5.7"/><circle cx="12" cy="12" r="2"/><path d="M13.4 10.6 19 5"/></svg>
                                    <span>基準速度算出ツール</span>
                                </h2>

                                <div class="space-y-6">
                                    <div class="flex items-start gap-4">
                                        <div class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">0</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-2">データの収集</h3>
                                            <p class="text-gray-600 text-sm">基準速度を算出したい回転系について、あらゆる負荷がかからない状態で固定して回転させたトラッキングデータをキャプチャします。例えば2輪ローバであれば、片方の車輪が鉛直方向を向くように立てかけて、上側の車輪にマーカをつけ、旋回動作をさせて上側車輪だけを回すことで無負荷の回転データを得ることができます。</p>
                                            <img src="img/v-caputure2.png" style="max-width: 150px;height: auto;">
                                        </div>
                                    </div>


                                    <div class="flex items-start gap-4">
                                        <div class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">1</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-2">データ入力</h3>
                                            <p class="text-gray-600 text-sm">解析したいMotiveのCSVファイルを1つ選択します。</p>
                                        </div>
                                    </div>

                                    <div class="flex items-start gap-4">
                                        <div class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">2</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-3">パラメータ設定</h3>
                                            <div class="space-y-3 text-gray-600 text-sm">
                                                <p><strong>② 車輪の剛体を選択:</strong> ファイル内の剛体から、回転を計測したい車輪を選択します。</p>
                                                <p><strong>③ 車輪の半径 (cm):</strong> 選択した車輪の半径をセンチメートル単位で入力します。</p>
                                                <p><strong>④ 車輪の回転軸:</strong> 車輪がどの軸周りに回転しているかを選択します。</p>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="flex items-start gap-4">
                                        <div class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">3</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-2">計算開始</h3>
                                            <p class="text-gray-600 text-sm">ボタンを押すと、データから回転の周期を算出し、基準速度（周速度）を計算します。</p>
                                        </div>
                                    </div>

                                    <div class="flex items-start gap-4">
                                        <div class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">4</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-2">結果確認</h3>
                                            <p class="text-gray-600 text-sm">計算された基準速度が表示され、結果をクリップボードにコピーできます。</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="page" id="algorithms">
                    <div class="max-w-4xl mx-auto space-y-8">
                        <div class="bg-white p-8 rounded-lg shadow-sm border">
                            <h1 class="text-2xl font-bold text-slate-800 mb-6 border-b pb-3">アルゴリズム仕様</h1>
                            <div class="prose-styles">
                                <p>本ツールで採用されているデータ解析のアルゴリズムおよび計算式について、その詳細を以下に示します。</p>

                                <h2 class="text-xl font-semibold text-slate-700 mt-8">データ解析ツール</h2>

                                <h3>動作区間の自動検出</h3>
                                <p>
                                    本ツールでは、CSVデータに含まれる時間全体のデータから、対象物が実際に動作している区間を自動で抽出します。この処理は、ユーザーが指定した「進行方向」の座標データに基づいて行われます。
                                    まず、進行方向軸における全データの最大値 $P_{max}$ と最小値 $P_{min}$ から、全体の振れ幅 $R$ を計算します。
                                </p>
                                <div class="formula-block">
                                    $R = P_{max} - P_{min}$
                                </div>
                                <p>
                                    次に、この振れ幅 $R$ とユーザーが設定可能な「静止範囲の倍率」$M$（デフォルト値: 0.001）を用いて、静止判定の閾値となるマージン $\delta$ を決定します。
                                </p>
                                <div class="formula-block">
                                    $\delta = R \times M$
                                </div>
                                <p>
                                    このマージン $\delta$ を用いて、動作の開始点と終了点を検出します。<br>
                                    <b>動作開始点:</b> データの初期値 $P_{initial}$ から $\pm \delta$ の範囲を逸脱した最初のフレーム。<br>
                                    <b>動作終了点:</b> 往復運動などを正しく捉えるため、データの末尾から逆方向に探索します。最終値 $P_{final}$ から $\pm \delta$ の範囲に最後に入ったフレーム（＝範囲外だった最後のフレームの次）を終了点とすることで、動作全体の区間を正確に抽出します。
                                </p>
                                <div class="my-6 text-center">
                                    <img src="img/exp.png" alt="動作区間検出のグラフ例" class="mx-auto rounded-lg shadow-md border">
                                    <p class="text-sm text-slate-500 mt-2">図1: 動作区間検出の概念図。変位データが静止範囲（マージン $\pm\delta$）を逸脱・復帰する点を検出する。</p>
                                </div>

                                <h3>水平移動距離</h3>
                                <p>
                                    各時刻 $t$ における水平移動距離 $d(t)$ は、ユーザーが定義した「鉛直方向」以外の2軸（水平軸 $h_1, h_2$）の変位から算出されます。動作開始点の座標を $(h_{1,0}, h_{2,0})$ とすると、時刻 $t$ での座標 $(h_{1,t}, h_{2,t})$ との間の距離は、三平方の定理を用いて次式で計算されます。
                                </p>
                                <div class="formula-block">
                                    $d(t) = \sqrt{(h_{1,t} - h_{1,0})^2 + (h_{2,t} - h_{2,0})^2}$
                                </div>

                                <h3>瞬時速度（微小速度）</h3>
                                <p>
                                    時刻 $t_i$ における瞬時速度 $v_i$ は、隣接するフレーム間の水平移動距離と時間の変化量から、後退差分を用いて近似的に算出されます。
                                </p>
                                <div class="formula-block">
                                    $v_i = \frac{d(t_i) - d(t_{i-1})}{t_i - t_{i-1}} = \frac{\Delta d}{\Delta t}$
                                </div>

                                <h3>スリップ率</h3>
                                <p>
                                    スリップ率 $S$ は、ユーザーが入力した基準速度 $u$ と、算出した剛体の速度 $v$ を用いて計算されます。$u > v$ の場合は駆動輪のスリップ（加速時）、$u < v$ の場合は制動輪のスリップ（減速時）として、以下の式で定義されます。
                                </p>
                                <div class="formula-block">
                                    $S [\%] =
                                    \begin{cases}
                                    (1 - \frac{v}{u}) \times 100 & (u &gt; v, \text{ 加速スリップ}) \\
                                    (1 - \frac{u}{v}) \times 100 & (u &lt; v, \text{ 制動スリップ})
                                    \end{cases}$
                                </div>
                                <p>
                                    グラフにプロットされるのは各時刻の瞬時速度から算出されたスリップ率であり、「平均スリップ率」は平均速度を用いて算出されます。
                                </p>

                                <h3>分散</h3>
                                <p>
                                    速度およびスリップ率のばらつきを示す指標として、標本分散 $\sigma^2$ と不偏分散 $u^2$ の2種類を算出しています。データ数 $n$、個々のデータ値 $x_i$、平均値 $\bar{x}$ を用いて、それぞれ以下の式で計算されます。
                                </p>
                                <div class="formula-block">
                                    $\text{標本分散: } \sigma^2 = \frac{1}{n} \sum_{i=1}^{n} (x_i - \bar{x})^2$
                                </div>
                                <div class="formula-block">
                                    $\text{不偏分散: } u^2 = \frac{1}{n-1} \sum_{i=1}^{n} (x_i - \bar{x})^2$
                                </div>

                                <h3>ローパスフィルタ</h3>
                                <p>
                                    グラフのノイズを低減するために、複数のローパスフィルタから選択できます。
                                </p>
                                <h4>移動平均フィルタ</h4>
                                <p>
                                    単純移動平均（Simple Moving Average）法です。指定された「サンプル数」$W$に基づき、ある点 $i$ の値 $y_i$ を、その前後 $\lfloor W/2 \rfloor$ 個のデータを含む合計 $W$ 個のデータの平均値 $\hat{y}_i$ で置き換えます。
                                </p>
                                <div class="formula-block">
                                    $\hat{y}_i = \frac{1}{W} \sum_{j=i-\lfloor W/2 \rfloor}^{i+\lfloor W/2 \rfloor} y_j$
                                </div>
                                <h4>ガウシアンフィルタ</h4>
                                <p>
                                    より滑らかな結果が得られるガウス畳み込みによるフィルタです。フィルタの核となるガウス関数の標準偏差 $\sigma$ をユーザーが直接指定します。$\sigma$ の値が大きいほど、より強力な平滑化がかかります。
                                </p>
                                <div class="formula-block">
                                    $$G(x) = \frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{x^2}{2\sigma^2}}$$
                                </div>

                                <h2 class="text-xl font-semibold text-slate-700 mt-8">広域解析ツール</h2>
                                <h3>データサンプリング</h3>
                                <p>
                                    複数のCSVファイルから長時間のデータを効率的に扱うため、指定された「データ取得間隔」に基づいてデータをサンプリングします。座標は正規化せず、元データの値をそのまま使用します。
                                </p>

                                <h3>ヒートマップ生成</h3>
                                <p>
                                    対象物の滞在頻度や傾向を可視化するため、ヒートマップを生成します。まず、描画領域全体をユーザー指定の「マス目のサイズ」でグリッドに分割します。
                                    次に、サンプリングされた各データ点について、それがどのグリッドセルに位置するかを判定します。同一のサンプリング時刻内に複数のデータ点（剛体）が同じセルに存在した場合でも、そのセルは1回のみカウントされます。これにより、各セルが少なくとも1回以上占有されたサンプリング時刻の総数を集計し、ヒートマップの各セルの値とします。
                                </p>
                                <div class="formula-block">
                                    $\text{Cell}(i, j) = \sum_{t \in T} \mathbf{1} \left( \exists p \in P_t \text{ s.t. } p \in \text{Grid}(i, j) \right)$
                                </div>
                                <p>
                                    ここで、$T$はサンプリング時刻の集合、$P_t$は時刻$t$における全データ点の集合、$\mathbf{1}(\cdot)$は指示関数です。
                                </p>

                                <h3>網羅率の計算</h3>
                                <p>
                                    指定された基準範囲（円または正方形）に対して、対象物がどれだけの割合の領域を走破したかを示す「網羅率」を計算します。
                                    まず、基準範囲内に中心が含まれるヒートマップのグリッドセルの総数 $N_{total}$ を求めます。次に、これらのセルのうち、対象物が少なくとも1回以上滞在した（ヒートマップの値が1以上である）セルの数 $N_{reached}$ をカウントします。網羅率 $C$ は以下の式で算出されます。
                                </p>
                                <div class="formula-block">
                                    $C [\%] = \frac{N_{reached}}{N_{total}} \times 100$
                                </div>


                                <h2 class="text-xl font-semibold text-slate-700 mt-8">基準速度算出ツール</h2>

                                <h3>角度データのアンラップ</h3>
                                <p>
                                    Motiveから出力される回転角度データは、通常 $\pm 180^\circ$ の範囲に制限されており、回転がこの範囲を超えると値が不連続に変化（ラップ）します。正確な周期計算のため、このラップを解消（アンラップ）し、連続的な角度変化データに変換します。具体的には、隣接する角度データ $A_{i-1}$ と $A_i$ の差が $\pm 180^\circ$ を超えた場合に、$360^\circ$ のオフセットを加算または減算して補正します。
                                </p>
                                <div class="formula-block">
                                    $A'_{i} =
                                    \begin{cases}
                                    A'_{i-1} + (A_i - A_{i-1}) - 360 & (A_i - A_{i-1} &gt; 180^\circ) \\
                                    A'_{i-1} + (A_i - A_{i-1}) + 360 & (A_i - A_{i-1} &lt; -180^\circ) \\
                                    A'_{i-1} + (A_i - A_{i-1}) & (\text{その他})
                                    \end{cases}$
                                </div>

                                <h3>回転周期の算出</h3>
                                <p>
                                    アンラップされた角度データから、車輪が1回転（$360^\circ$）するのに要する時間（周期 $T$）を算出します。まず、回転が開始したと見なされる点（初期角度から $5^\circ$ 以上変化した点）を検出し、その時刻 $t_{start}$ と角度 $A_{start}$ を記録します。次に、角度が $A_{start} \pm 360^\circ$ に到達する時刻 $t_{end}$ を探します。
                                    目標角度を跨ぐ2つのフレーム間で線形補間を行い、正確な到達時刻 $t_{end}$ を推定します。目標角度 $A_{target}$ を跨ぐ直前と直後の点をそれぞれ $(t_{before}, A_{before})$, $(t_{after}, A_{after})$ とした場合、到達時刻 $t_{end}$ は以下の線形補間の式で求められます。
                                </p>
                                <div class="formula-block">
                                    $t_{end} = t_{before} + (t_{after} - t_{before}) \times \frac{A_{target} - A_{before}}{A_{after} - A_{before}}$
                                </div>
                                <p>
                                    最終的な周期 $T$ は以下の式で得られます。
                                </p>
                                <div class="formula-block">
                                    $T = t_{end} - t_{start}$
                                </div>

                                <h3>基準速度の算出</h3>
                                <p>
                                    算出された周期 $T$ と、ユーザーが入力した車輪の半径 $r$ から、車輪の周速度、すなわち基準速度 $v$ を計算します。角速度 $\omega$ は $\omega = 2\pi / T$ で与えられるため、基準速度 $v$ は次式で求められます。
                                </p>
                                <div class="formula-block">
                                    $v = r \cdot \omega = \frac{2\pi r}{T}$
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="page" id="about">
                    <div class="max-w-4xl mx-auto space-y-8">
                        <div class="bg-white p-8 rounded-lg shadow-sm border">
                            <h1 class="text-2xl font-bold text-slate-800 mb-6 border-b pb-3">このツールについて</h1>
                            <div class="prose prose-slate max-w-none">
                                <div>
                        <h2 class="text-xl font-semibold text-slate-700">基本情報</h2>
                        <div class="mt-3 grid grid-cols-1 gap-y-2 text-sm">
                            <p><span class="w-24 inline-block font-medium text-slate-500">アプリ名:</span> Mocap Plus</p>
                            <p><span class="w-24 inline-block font-medium text-slate-500">バージョン:</span> 3.0.0</p>
                            <p><span class="w-24 inline-block font-medium text-slate-500">製作者:</span> 中央大学理工学部 國井研究室 西藤 実</p>
                            <p><span class="w-24 inline-block font-medium text-slate-500">リポジトリ:</span> <a href="https://github.com/minoru-saito-chuo/mocap" target="_blank" class="text-blue-600 hover:underline">GitHub</a></p>

                        </div>
                    </div>
                    <br>
                    <div>
                        <h2 class="text-xl font-semibold text-slate-700">更新履歴</h2>
                        <ul class="mt-3 list-disc list-inside space-y-2 text-sm">
                            <li><span class="font-semibold">2025-10-20:</span> 広域解析ツールを追加し、軌跡・ヒートマップ・網羅率の可視化機能を追加。</li>
                            <li><span class="font-semibold">2025-08-07:</span> データ解析ツールでファイルを後からでも追加できるよう修正。スクロールしてもメニューが固定されるよう改善。</li>
                            <li><span class="font-semibold">2025-08-05:</span> ローパスフィルタにガウシアンフィルタを追加。動作区間検出アルゴリズムを修正。その他の潜在的なバグを修正。</li>
                            <li><span class="font-semibold">2025-07-05:</span> アルゴリズム仕様ページを追加し、数式表示の改善やレイアウト修正などの更新を実施。</li>
                            <li><span class="font-semibold">2025-07-04:</span> データ解析ツールに分散表示機能と、ユーザが任意に設定できるローパスフィルタ機能を追加。UI/UXの改善。</li>
                            <li><span class="font-semibold">2025-07-03:</span> データ解析ツールにグラフ拡大機能を追加。</li>
                            <li><span class="font-semibold">2025-06-28:</span> 基準速度の算出ツールを作成、データ解析ツールに統合。</li>
                            <li><span class="font-semibold">2025-06-21:</span> データ解析ツールの初期リリース。</li>
                        </ul>
                    </div>
                    <br>
                    <div>
                         <h2 class="text-xl font-semibold text-slate-700">注意事項・免責事項</h2>
                         <ul class="mt-3 list-disc space-y-2 pl-5 text-sm text-slate-600">
                            <li>本ツールは、OptiTrackの解析ソフト「Motive」からエクスポートされたCSVファイルに最適化されています。</li>
                            <li>データ処理は全てブラウザ内で完結し、添付したデータが外部に送信されることはありません。</li>
                            <li>本ツールの利用によって生じた直接的または間接的な損害について、製作者は一切責任を負いません。</li>
                            <li>本ツールの作成にあたっては、複数のLLMを利用しています。</li>
                         </ul>
                    </div>
                            </div>
                        </div>
                        <p class="text-center text-slate-500 text-sm">© 2025 SAITO Minoru.</p>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <div id="mobile-menu-overlay" class="lg:hidden fixed inset-0 z-40 hidden opacity-0">
        <div class="absolute inset-0 bg-black/40 backdrop-blur-sm"></div>
        <div id="mobile-menu-content" class="relative bg-slate-100 w-64 h-full shadow-lg p-4 transform -translate-x-full">
            <button id="mobile-menu-close-btn" class="absolute top-4 right-4 p-2">
                <svg class="h-6 w-6 text-slate-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            <div class="flex items-center mb-6">
                <img src="icons/icon-192.png" style="width: 25px; height: auto;">
                <h1 class="text-lg font-bold text-slate-800 ml-2">Mocap Plus</h1>
            </div>
             <nav class="space-y-2" id="mobile-nav-links">
                <a class="nav-link block px-4 py-2 text-slate-700 hover:bg-slate-200 rounded-md" href="#home">ホーム</a>
                <a class="nav-link block px-4 py-2 text-slate-700 hover:bg-slate-200 rounded-md" href="#data-analysis">データ解析ツール</a>
                <a class="nav-link block px-4 py-2 text-slate-700 hover:bg-slate-200 rounded-md" href="#wide-area-analysis">広域解析ツール</a>
                <a class="nav-link block px-4 py-2 text-slate-700 hover:bg-slate-200 rounded-md" href="#standard-velocity">基準速度算出ツール</a>
                <a class="nav-link block px-4 py-2 text-slate-700 hover:bg-slate-200 rounded-md" href="#how-to-use">使い方ガイド</a>
                <a class="nav-link block px-4 py-2 text-slate-700 hover:bg-slate-200 rounded-md" href="#algorithms">アルゴリズム仕様</a>
                <a class="nav-link block px-4 py-2 text-slate-700 hover:bg-slate-200 rounded-md" href="#about">このツールについて</a>
            </nav>
        </div>
    </div>

    <div id="chart-zoom-modal" class="hidden fixed top-0 left-0 w-full h-full bg-black/60 backdrop-blur-sm flex justify-center items-center z-50 p-4 transition-opacity duration-300">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-5xl h-full max-h-[90vh] flex flex-col">
            <div class="flex justify-end p-2">
                <button id="modal-close-btn" class="p-2 text-slate-500 hover:text-slate-800 rounded-full hover:bg-slate-100 transition-colors">
                    <svg class="h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <div class="flex-1 min-h-0 p-4 pt-0">
                <canvas id="modal-chart-canvas"></canvas>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Global Variables ---
            let modalChartInstance = null;

            // --- SPA Navigation ---
            const pages = document.querySelectorAll('.page');
            const mobileMenuBtn = document.getElementById('mobile-menu-btn');
            const mobileMenuOverlay = document.getElementById('mobile-menu-overlay');
            const mobileMenuContent = document.getElementById('mobile-menu-content');
            const mobileMenuCloseBtn = document.getElementById('mobile-menu-close-btn');
            const mobileNavLinks = document.getElementById('mobile-nav-links');
            const mobileTitle = document.getElementById('mobile-title');
            const mainContentArea = document.getElementById('main-content-area');

            function openMobileMenu() {
                if (!mobileMenuOverlay) return;
                document.body.classList.add('mobile-menu-open');
                mobileMenuOverlay.classList.remove('hidden');
                setTimeout(() => {
                    mobileMenuOverlay.classList.remove('opacity-0');
                    if(mobileMenuContent) mobileMenuContent.classList.remove('-translate-x-full');
                }, 10);
            }

            function closeMobileMenu() {
                if (!mobileMenuOverlay) return;
                document.body.classList.remove('mobile-menu-open');
                mobileMenuOverlay.classList.add('opacity-0');
                if(mobileMenuContent) mobileMenuContent.classList.add('-translate-x-full');
                setTimeout(() => {
                    mobileMenuOverlay.classList.add('hidden');
                }, 300);
            }

            function renderMath() {
                if (window.renderMathInElement) {
                    renderMathInElement(document.getElementById('algorithms'), {
                        delimiters: [
                            {left: '$$', right: '$$', display: true},
                            {left: '$', right: '$', display: false},
                            {left: '\\(', right: '\\)', display: false},
                            {left: '\\[', right: '\\]', display: true}
                        ],
                        throwOnError: false
                    });
                }
            }

            function showPage(pageId) {
                pages.forEach(page => {
                    page.classList.remove('active');
                });
                const targetPage = document.getElementById(pageId);
                if(targetPage) {
                    targetPage.classList.add('active');
                }

                document.querySelectorAll('.nav-link').forEach(link => {
                    const linkPageId = link.getAttribute('href').substring(1);
                    const isActive = linkPageId === pageId;
                    link.classList.toggle('active', isActive);

                    if(isActive){
                         const titleText = link.querySelector('span')?.textContent || link.textContent.trim();
                         if(mobileTitle) mobileTitle.textContent = titleText;
                    }
                });
                window.scrollTo(0, 0);

                if (pageId === 'algorithms') {
                   renderMath();
                }
            }

            if (mobileMenuBtn) mobileMenuBtn.addEventListener('click', openMobileMenu);
            if (mobileMenuCloseBtn) mobileMenuCloseBtn.addEventListener('click', closeMobileMenu);
            if (mobileMenuOverlay) {
                 mobileMenuOverlay.addEventListener('click', (e) => {
                     if (e.target === mobileMenuOverlay) closeMobileMenu();
                 });
            }

             const allNavLinks = document.querySelectorAll('.nav-link, .nav-card');
             allNavLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const pageId = link.getAttribute('href').substring(1);
                    history.pushState(null, '', '#' + pageId);
                    showPage(pageId);
                    closeMobileMenu();
                });
            });

            window.addEventListener('popstate', () => {
                const pageId = window.location.hash ? window.location.hash.substring(1) : 'home';
                showPage(pageId);
            });

            const initialPage = window.location.hash ? window.location.hash.substring(1) : 'home';
            if(document.getElementById(initialPage)) {
                 showPage(initialPage);
            } else {
                 showPage('home');
            }

            // --- DATA ANALYSIS TOOL SCRIPT ---
            const fileDataStore = {};
            const chartInstances = {};
            let allInstantaneousVelocities = [];
            let lastProcessedData = [];

            const csvFileInput = document.getElementById('csv-files');
            const fileListDiv = document.getElementById('file-list');
            const clearFilesBtn = document.getElementById('clear-files-btn');
            const travelAxisSelect = document.getElementById('travel-axis');
            const verticalAxisSelect = document.getElementById('vertical-axis');
            const rigidbodySelectionSection = document.getElementById('rigidbody-selection-section');
            const rigidbodyListDiv = document.getElementById('rigidbody-list');
            const startAnalysisBtn = document.getElementById('start-analysis-btn');
            const resultsSection = document.getElementById('results-section');
            const loadingDiv = document.getElementById('loading');
            const downloadOverlay = document.getElementById('download-overlay');
            const filterVelocityCheckbox = document.getElementById('filter-velocity-checkbox');
            const filterRangeInputs = document.getElementById('filter-range-inputs');
            const recalculateAvgBtn = document.getElementById('recalculate-avg-btn');
            const redrawChartsBtn = document.getElementById('redraw-charts-btn');
            const loadingText = document.getElementById('loading-text');

            const lowpassFilterTypeSelect = document.getElementById('lowpass-filter-type');
            const lowpassStrengthInput = document.getElementById('lowpass-strength');
            const lowpassStrengthLabel = document.getElementById('lowpass-strength-label');
            const filterDescription = document.getElementById('filter-description');


            // --- Modal Elements ---
            const chartZoomModal = document.getElementById('chart-zoom-modal');
            const modalCloseBtn = document.getElementById('modal-close-btn');
            const modalChartCanvas = document.getElementById('modal-chart-canvas');

            // --- Low Pass Filter Helpers ---
            function applyMovingAverageFilter(dataPoints, windowSize) {
                if (windowSize <= 1 || dataPoints.length < windowSize) return dataPoints;

                const smoothedPoints = [];
                const halfWindow = Math.floor(windowSize / 2);

                for (let i = 0; i < dataPoints.length; i++) {
                    const start = Math.max(0, i - halfWindow);
                    const end = Math.min(dataPoints.length - 1, i + halfWindow);
                    let sumY = 0;
                    for (let j = start; j <= end; j++) {
                        sumY += dataPoints[j].y;
                    }
                    const avgY = sumY / (end - start + 1);
                    smoothedPoints.push({ x: dataPoints[i].x, y: avgY });
                }
                return smoothedPoints;
            }

            function applyGaussianFilter(dataPoints, sigma) {
                if (sigma <= 0 || dataPoints.length < 3) return dataPoints;

                const radius = Math.ceil(sigma * 3);
                const kernel = [];
                let kernelSum = 0;
                for (let i = -radius; i <= radius; i++) {
                    const val = Math.exp(-0.5 * (i / sigma) * (i / sigma));
                    kernel.push(val);
                    kernelSum += val;
                }
                for (let i = 0; i < kernel.length; i++) {
                    kernel[i] /= kernelSum;
                }

                const smoothedPoints = [];
                const halfKernel = Math.floor(kernel.length / 2);

                for (let i = 0; i < dataPoints.length; i++) {
                    let weightedSumY = 0;
                    for (let j = 0; j < kernel.length; j++) {
                        const dataIndex = i + j - halfKernel;
                        const clampedIndex = Math.max(0, Math.min(dataPoints.length - 1, dataIndex));
                        weightedSumY += dataPoints[clampedIndex].y * kernel[j];
                    }
                    smoothedPoints.push({ x: dataPoints[i].x, y: weightedSumY });
                }
                return smoothedPoints;
            }

            function rerenderCharts() {
                 if (lastProcessedData && lastProcessedData.length > 0) {
                    renderAllCharts(lastProcessedData, travelAxisSelect.value, verticalAxisSelect.value);
                } else {
                    alert('先に解析を実行してください。');
                }
            }

            if (csvFileInput) {
                csvFileInput.addEventListener('change', (e) => handleFileSelect(e, 'data-analysis'));
                startAnalysisBtn.addEventListener('click', startAnalysis);
                if (clearFilesBtn) {
                    clearFilesBtn.addEventListener('click', () => clearAllFiles('data-analysis'));
                }

                lowpassFilterTypeSelect.addEventListener('change', (e) => {
                    const filterType = e.target.value;
                    if (filterType === 'none') {
                        lowpassStrengthInput.disabled = true;
                        lowpassStrengthLabel.innerHTML = '強度:';
                        filterDescription.textContent = 'フィルタを選択すると、強度を指定できます。';
                    } else if (filterType === 'moving-average') {
                        lowpassStrengthInput.disabled = false;
                        lowpassStrengthInput.value = 10;
                        lowpassStrengthInput.step = 1;
                        lowpassStrengthLabel.innerHTML = 'サンプル数:';
                        filterDescription.textContent = '移動平均のサンプル数（整数）を指定します。値が大きいほど滑らかになります。';
                    } else if (filterType === 'gaussian') {
                        lowpassStrengthInput.disabled = false;
                        lowpassStrengthInput.value = 2.0;
                        lowpassStrengthInput.step = 0.1;
                        lowpassStrengthLabel.innerHTML = 'σ値:';
                        filterDescription.innerHTML = '<b>σ値の目安:</b> 1.0-2.5(弱), 2.5-3.5(標準), 3.5-5.0(強)';
                    }
                });

                rigidbodyListDiv.addEventListener('change', (event) => {
                    if (event.target.classList.contains('rigidbody-checkbox')) {
                        const checkbox = event.target;
                        const itemContainer = checkbox.closest('.rigidbody-item-container');
                        const legendInputContainer = itemContainer.querySelector('.legend-input-container');
                        if (legendInputContainer) {
                            legendInputContainer.classList.toggle('hidden', !checkbox.checked);
                        }
                    }
                });

                fileListDiv.addEventListener('click', async (event) => {
                    const pasteBtn = event.target.closest('.paste-btn');
                    if (!pasteBtn) return;

                    try {
                        const text = await navigator.clipboard.readText();
                        const targetId = pasteBtn.dataset.targetId;
                        const targetInput = document.getElementById(targetId);
                        if (targetInput && !isNaN(parseFloat(text))) {
                            targetInput.value = parseFloat(text);
                        } else {
                            console.warn("Pasted content is not a valid number.");
                        }
                    } catch (err) {
                        console.error('Failed to read clipboard contents: ', err);
                        alert("クリップボードの読み取りに失敗しました。ブラウザの権限設定を確認してください。");
                    }
                });

                filterVelocityCheckbox.addEventListener('change', () => {
                    filterRangeInputs.classList.toggle('hidden', !filterVelocityCheckbox.checked);
                });
                recalculateAvgBtn.addEventListener('click', recalculateAverages);

                if (redrawChartsBtn) redrawChartsBtn.addEventListener('click', rerenderCharts);


                document.querySelectorAll('.style-btn').forEach(btn => btn.addEventListener('click', handleStyleChange));
                document.getElementById('download-velocity-csv').addEventListener('click', downloadVelocityCSV);
                document.querySelectorAll('.chart-label-input').forEach(input => {
                    input.addEventListener('input', updateAllChartLabels);
                });

                resultsSection.addEventListener('click', (event) => {
                    const button = event.target.closest('button');
                    if (!button) return;

                    if (button.classList.contains('zoom-btn')) {
                        handleZoom(button.dataset.chartId);
                    } else if (button.classList.contains('download-btn')) {
                        handleDownload(button.dataset.chartId, button.dataset.format);
                    }
                });
            }

            if (modalCloseBtn) modalCloseBtn.addEventListener('click', closeZoomModal);
            if (chartZoomModal) chartZoomModal.addEventListener('click', (e) => { if (e.target === chartZoomModal) closeZoomModal(); });

            function handleZoom(chartId) {
                const originalChart = chartInstances[chartId];
                if (!originalChart) return;
                if (modalChartInstance) modalChartInstance.destroy();
                const modalChartOptions = JSON.parse(JSON.stringify(originalChart.options));
                modalChartOptions.maintainAspectRatio = false;
                modalChartOptions.plugins.title.font.size = 20;
                modalChartOptions.plugins.legend.labels.font.size = 14;
                modalChartOptions.scales.x.title.font.size = 16;
                modalChartOptions.scales.y.title.font.size = 16;
                modalChartOptions.scales.x.ticks.font.size = 14;
                modalChartOptions.scales.y.ticks.font.size = 14;
                modalChartInstance = new Chart(modalChartCanvas, { type: originalChart.config.type, data: originalChart.config.data, options: modalChartOptions });
                chartZoomModal.classList.remove('hidden');
            }

            function closeZoomModal() {
                if (modalChartInstance) { modalChartInstance.destroy(); modalChartInstance = null; }
                chartZoomModal.classList.add('hidden');
            }


            function clearAllFiles(tool) {
                if (tool === 'data-analysis') {
                    for (const key in fileDataStore) { delete fileDataStore[key]; }
                    fileListDiv.innerHTML = '';
                    rigidbodyListDiv.innerHTML = '';
                    rigidbodySelectionSection.classList.add('hidden');
                    resultsSection.classList.add('hidden');
                    csvFileInput.value = '';
                }
            }

            function handleFileSelect(event, tool) {
                const files = Array.from(event.target.files);
                if (files.length === 0) return;

                if (tool === 'data-analysis') {
                    rigidbodySelectionSection.classList.remove('hidden');

                    files.forEach(file => {
                        if (fileDataStore[file.name]) {
                            console.log(`File "${file.name}" is already loaded. Skipping.`);
                            return;
                        }

                        const fileId = `file-${file.name.replace(/[^a-zA-Z0-9]/g, '')}`;
                        const fileElement = document.createElement('div');
                        fileElement.className = 'bg-slate-50 p-2.5 rounded-md flex items-center justify-between border text-sm';
                        fileElement.innerHTML = `
                            <span class="text-slate-700 truncate pr-4">${file.name}</span>
                            <div class="flex items-center flex-shrink-0">
                                <label for="speed-${fileId}" class="text-xs text-slate-500 mr-2 whitespace-nowrap">基準速度(m/s):</label>
                                <div class="flex">
                                    <input type="number" id="speed-${fileId}" data-filename="${file.name}" class="reference-speed-input bg-white border border-slate-300 rounded-l-md w-20 p-1 text-right text-sm" step="0.1" value="1.0">
                                    <button type="button" class="paste-btn p-1.5 bg-slate-100 hover:bg-slate-200 border border-l-0 border-slate-300 rounded-r-md" data-target-id="speed-${fileId}" title="ペースト">
                                        <svg class="h-4 w-4 text-slate-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h3.75M9 15h3.75M9 18h3.75m3 .75H18a2.25 2.25 0 002.25-2.25V6.108c0-1.135-.845-2.098-1.976-2.192a48.424 48.424 0 00-1.123-.08m-5.801 0c-.065.21-.1.433-.1.664 0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75 2.25 2.25 0 00-.1-.664m-5.8 0A2.251 2.251 0 0113.5 2.25H15c1.012 0 1.867.668 2.15 1.586m-5.8 0c-.376.023-.75.05-1.124.08C9.095 4.01 8.25 4.973 8.25 6.108V8.25m0 0H4.875c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V9.375c0-.621-.504-1.125-1.125-1.125H8.25z" /></svg>
                                    </button>
                                </div>
                            </div>
                        `;
                        fileListDiv.appendChild(fileElement);
                        Papa.parse(file, {
                            complete: (results) => {
                                try {
                                    const rigidBodies = extractRigidBodies(results.data);
                                    fileDataStore[file.name] = { rawData: results.data, rigidBodies };
                                    displayRigidBodySelector(file.name, rigidBodies);
                                } catch (error) {
                                    alert(`ファイル "${file.name}" の解析中にエラーが発生しました: ${error.message}`);
                                }
                            },
                            error: (error) => alert(`ファイル "${file.name}" の読み込みに失敗しました: ${error.message}`)
                        });
                    });
                }
                event.target.value = '';
            }

            function extractRigidBodies(data) {
                let typeRowIndex = -1, nameRowIndex = -1, propertyRowIndex = -1, dataStartIndex = -1;
                for(let i=0; i < 15 && i < data.length; i++){
                     if(data[i][1] === 'Type') typeRowIndex = i;
                     if(data[i][1] === 'Name') nameRowIndex = i;
                     if(data[i][2] === 'Rotation' || data[i][2] === 'Position') propertyRowIndex = i;
                     if(data[i][0] === 'Frame' && data[i][1] === 'Time (Seconds)') dataStartIndex = i + 1;
                }
                if(typeRowIndex === -1 || nameRowIndex === -1 || propertyRowIndex === -1 || dataStartIndex === -1) throw new Error("CSVのヘッダー形式が不正です。");

                const [typeRow, nameRow, propertyRow] = [data[typeRowIndex], data[nameRowIndex], data[propertyRowIndex]];
                const rigidBodies = {};

                for (let i = 2; i < typeRow.length; i++) {
                    if (typeRow[i] === 'Rigid Body' && propertyRow[i] === 'Position') {
                        const name = nameRow[i];
                        if (!rigidBodies[name]) rigidBodies[name] = { name: name, posIndices: {} };
                        rigidBodies[name].posIndices = { X: i, Y: i + 1, Z: i + 2 };
                        i += 2;
                    }
                }

                const dataUnit = document.querySelector('input[name="data-unit"]:checked').value;
                const conversionFactor = dataUnit === 'mm' ? 1000 : 1;
                const actualData = data.slice(dataStartIndex).filter(row => row.length > 1 && row[1] !== '');
                Object.values(rigidBodies).forEach(body => {
                    body.data = actualData.map(row => ({
                        time: parseFloat(row[1]),
                        pos: {
                            X: parseFloat(row[body.posIndices.X]) / conversionFactor,
                            Y: parseFloat(row[body.posIndices.Y]) / conversionFactor,
                            Z: parseFloat(row[body.posIndices.Z]) / conversionFactor
                        }
                    })).filter(d => !isNaN(d.time) && !isNaN(d.pos.X));
                });
                return Object.values(rigidBodies);
            }

            function displayRigidBodySelector(filename, rigidBodies) {
                const fileGroupContainer = document.createElement('div');
                fileGroupContainer.className = 'mb-4';
                let listHTML = `<h3 class="text-md font-semibold text-slate-700 mb-2 border-b pb-2">[${filename}] の剛体</h3><div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-y-2 gap-x-4">`;
                if (rigidBodies.length === 0) {
                    listHTML += `<p class="text-slate-500 col-span-full text-sm">剛体データが見つかりませんでした。</p>`;
                } else {
                    rigidBodies.forEach(body => {
                        const defaultLabel = `${filename} - ${body.name}`;
                        listHTML += `
                        <div class="rigidbody-item-container">
                            <label class="flex items-center space-x-2 p-2 rounded-md hover:bg-slate-100 cursor-pointer w-full">
                                <input type="checkbox" class="rigidbody-checkbox form-checkbox h-4 w-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500" data-filename="${filename}" data-bodyname="${body.name}">
                                <span class="text-slate-800 text-sm">${body.name}</span>
                            </label>
                            <div class="legend-input-container hidden pl-7 mt-1">
                                <label class="text-xs text-slate-500">凡例名:</label>
                                <input type="text" class="legend-label-input mt-1 block w-full rounded-md shadow-sm p-1.5 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500" data-filename="${filename}" data-bodyname="${body.name}" value="${defaultLabel}">
                            </div>
                        </div>`;
                    });
                }
                listHTML += `</div>`;
                fileGroupContainer.innerHTML = listHTML;
                rigidbodyListDiv.appendChild(fileGroupContainer);
            }

            function startAnalysis() {
                const travelAxis = travelAxisSelect.value;
                const verticalAxis = verticalAxisSelect.value;
                if (travelAxis === verticalAxis) {
                    alert('進行方向と鉛直方向は異なる軸を選択してください。');
                    return;
                }

                const motionDetectionSettings = {
                    multiplier: parseFloat(document.getElementById('motion-threshold-multiplier').value)
                };

                const selectedBodies = [];
                document.querySelectorAll('.rigidbody-checkbox:checked').forEach(cb => {
                    const filename = cb.dataset.filename;
                    const bodyName = cb.dataset.bodyname;
                    const labelInput = document.querySelector(`.legend-label-input[data-filename="${filename}"][data-bodyname="${bodyName}"]`);
                    const label = labelInput ? labelInput.value : `${filename} - ${bodyName}`;
                    selectedBodies.push({ filename, bodyName, label });
                });
                if (selectedBodies.length === 0) {
                    alert('解析する剛体を少なくとも1つ選択してください。');
                    return;
                }
                loadingText.textContent = '解析中...';
                loadingDiv.classList.remove('hidden');
                resultsSection.classList.add('hidden');
                setTimeout(() => {
                    try {
                        lastProcessedData = processAllBodies(selectedBodies, travelAxis, verticalAxis, motionDetectionSettings);
                        displayResults(lastProcessedData);
                        renderAllCharts(lastProcessedData, travelAxis, verticalAxis);
                        resultsSection.classList.remove('hidden');
                        setTimeout(() => resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
                    } catch (error) {
                        console.error("解析エラー:", error);
                        alert(`解析中にエラーが発生しました: ${error.message}`);
                    } finally {
                        loadingDiv.classList.add('hidden');
                    }
                }, 50);
            }

            function recalculateAverages() {
                 const useFilter = filterVelocityCheckbox.checked;
                 const lowerBound = parseFloat(document.getElementById('filter-lower-bound').value);
                 const upperBound = parseFloat(document.getElementById('filter-upper-bound').value);

                if(useFilter && (isNaN(lowerBound) || isNaN(upperBound))){
                    alert('有効な除外範囲を入力してください。');
                    return;
                }

                const updatedData = lastProcessedData.map(bodyData => {
                     let newAvgVelocity;
                     if (useFilter) {
                        let filteredDistance = 0;
                        let filteredTime = 0;
                        for (let i = 1; i < bodyData.data.length; i++) {
                            const vel = bodyData.data[i].instVelocity;
                            if (vel < lowerBound || vel > upperBound) {
                                filteredDistance += (bodyData.data[i].distance - bodyData.data[i-1].distance);
                                filteredTime += (bodyData.data[i].time - bodyData.data[i-1].time);
                            }
                        }
                        newAvgVelocity = filteredTime > 0 ? filteredDistance / filteredTime : 0;
                    } else {
                        const totalTime = bodyData.data[bodyData.data.length - 1].time;
                        const totalDistance = bodyData.data[bodyData.data.length - 1].distance;
                        newAvgVelocity = totalTime > 0 ? totalDistance / totalTime : 0;
                    }

                    let newAvgSlipRate = 0;
                    const u = bodyData.referenceSpeed;
                    const v = newAvgVelocity;
                    if (u > 0 && v >= 0) {
                         newAvgSlipRate = (u > v) ? (1 - (v / u)) * 100 : (1 - (u / v)) * 100;
                    }

                    return {...bodyData, avgVelocity: newAvgVelocity, avgSlipRate: newAvgSlipRate};
                });

                displayResults(updatedData);
            }

            function processAllBodies(selectedBodies, travelAxis, verticalAxis, motionDetectionSettings) {
                allInstantaneousVelocities = [];
                return selectedBodies.map(selection => {
                    const { filename, bodyName, label } = selection;
                    const body = fileDataStore[filename].rigidBodies.find(b => b.name === bodyName);
                    const referenceSpeedInput = document.querySelector(`input[data-filename="${filename}"]`);
                    if (!referenceSpeedInput) throw new Error(`基準速度の入力が見つかりません: ${filename}`);
                    const referenceSpeed = parseFloat(referenceSpeedInput.value);

                    if (!body || isNaN(referenceSpeed)) throw new Error(`データまたは基準速度が見つかりません: ${filename} - ${bodyName}`);

                    const motionRange = findMotionRange(body.data, travelAxis, motionDetectionSettings);
                    if (!motionRange) {
                        console.warn(`${label} の有効な動作が見つかりませんでした。スキップします。`);
                        return null;
                    }

                    let workingData = body.data.slice(motionRange.start, motionRange.end);
                    if (workingData.length < 2) return null;

                    const startTime = workingData[0].time;
                    const initialPos = workingData[0].pos;
                    const horizontalAxes = ['X', 'Y', 'Z'].filter(ax => ax !== verticalAxis);

                    workingData.forEach((d, i) => {
                        d.time = d.time - startTime;
                        const d_h1 = d.pos[horizontalAxes[0]] - initialPos[horizontalAxes[0]];
                        const d_h2 = d.pos[horizontalAxes[1]] - initialPos[horizontalAxes[1]];
                        d.distance = Math.sqrt(d_h1 ** 2 + d_h2 ** 2);
                        d.verticalDisp = d.pos[verticalAxis] - initialPos[verticalAxis];

                        const chartXAxisName = travelAxis;
                        const chartYAxisName = horizontalAxes.find(ax => ax !== travelAxis);
                        d.trajectory_x = d.pos[chartXAxisName] - initialPos[chartXAxisName];
                        d.trajectory_y = d.pos[chartYAxisName] - initialPos[chartYAxisName];

                        if (i === 0) { d.instVelocity = 0; } else {
                            const dt = d.time - workingData[i - 1].time;
                            const dd = d.distance - workingData[i - 1].distance;
                            d.instVelocity = dt > 0 ? dd / dt : 0;
                        }
                        const u = referenceSpeed, v = d.instVelocity;
                        if (u > 0 && v >= 0) d.slipRate = (u > v) ? (1 - (v / u)) * 100 : (1 - (u / v)) * 100;
                        else d.slipRate = 0;
                    });

                    const totalTime = workingData[workingData.length - 1].time;
                    const totalDistance = workingData[workingData.length - 1].distance;
                    const avgVelocity = totalTime > 0 ? totalDistance / totalTime : 0;

                    let avgSlipRate = 0;
                    if (referenceSpeed > 0 && avgVelocity >= 0) {
                         avgSlipRate = (referenceSpeed > avgVelocity) ? (1 - (avgVelocity / referenceSpeed)) * 100 : (1 - (referenceSpeed / avgVelocity)) * 100;
                    }

                    const n = workingData.length;
                    let velocitySampleVariance = 0, velocityUnbiasedVariance = 0;
                    if (n > 1) {
                        const velocityValues = workingData.map(d => d.instVelocity);
                        const meanVel = velocityValues.reduce((a, b) => a + b, 0) / n;
                        const sumOfSquares = velocityValues.map(v => (v - meanVel) ** 2).reduce((a, b) => a + b, 0);
                        velocitySampleVariance = sumOfSquares / n;
                        velocityUnbiasedVariance = sumOfSquares / (n - 1);
                    }

                    let slipRateSampleVariance = 0, slipRateUnbiasedVariance = 0;
                    const slipRateValues = workingData.map(d => d.slipRate).filter(sr => sr !== undefined && !isNaN(sr));
                    const m = slipRateValues.length;
                    if (m > 1) {
                        const meanSlip = slipRateValues.reduce((a, b) => a + b, 0) / m;
                        const sumOfSquares = slipRateValues.map(s => (s - meanSlip) ** 2).reduce((a, b) => a + b, 0);
                        slipRateSampleVariance = sumOfSquares / m;
                        slipRateUnbiasedVariance = sumOfSquares / (m - 1);
                    }

                    workingData.forEach(d => {
                        allInstantaneousVelocities.push({
                            "ファイル名": filename, "剛体名": bodyName, "凡例名": label, "時間 (s)": d.time.toFixed(3),
                            "距離 (m)": d.distance.toFixed(4), "微小速度 (m/s)": d.instVelocity.toFixed(4),
                            "スリップ率 (%)": d.slipRate.toFixed(2), "鉛直変位 (m)": d.verticalDisp.toFixed(4),
                        });
                    });
                    return { name: label, data: workingData, avgVelocity, avgSlipRate, velocitySampleVariance, velocityUnbiasedVariance, slipRateSampleVariance, slipRateUnbiasedVariance, referenceSpeed };
                }).filter(d => d !== null);
            }

            function findMotionRange(data, travelAxis, settings) {
                const pos = data.map(d => d.pos[travelAxis]);
                if (pos.length < 20) return { start: 0, end: pos.length };

                const overallMax = Math.max(...pos);
                const overallMin = Math.min(...pos);
                const overallRange = overallMax - overallMin;
                if (overallRange === 0) return null;

                const margin = overallRange * settings.multiplier;

                const initialValue = pos[0];
                const startLowerBound = initialValue - margin;
                const startUpperBound = initialValue + margin;
                let startIndex = 0;
                for (let i = 1; i < pos.length; i++) {
                    if (pos[i] < startLowerBound || pos[i] > startUpperBound) {
                        startIndex = i;
                        break;
                    }
                }
                if (startIndex === 0) { console.warn("動作開始が検出できませんでした。"); return null; }

                const finalValue = pos[pos.length - 1];
                const endLowerBound = finalValue - margin;
                const endUpperBound = finalValue + margin;

                let endIndex = pos.length;
                for (let i = pos.length - 1; i >= startIndex; i--) {
                    if (pos[i] < endLowerBound || pos[i] > endUpperBound) {
                        endIndex = i + 1;
                        break;
                    }
                }

                if (startIndex >= endIndex) { console.warn("有効な動作区間が見つかりませんでした (開始点が終了点以降)。"); return null; }
                return { start: startIndex, end: endIndex };
            }

            function displayResults(processedData) {
                const container = document.getElementById('average-velocities');
                container.innerHTML = '<h3 class="text-md font-semibold mb-3 text-slate-800">平均値・分散</h3>';
                const list = document.createElement('div');
                list.className = 'space-y-3';
                processedData.forEach(result => {
                    const item = document.createElement('div');
                    item.className = 'p-3 bg-slate-50/70 rounded-md border';
                    item.innerHTML = `
                        <div class="font-semibold text-sm text-blue-700">${result.name}</div>
                        <div class="mt-2 pl-2 text-sm text-slate-700 space-y-1">
                            <div>
                                平均速度: <span class="font-medium">${result.avgVelocity.toFixed(3)} m/s</span>
                                <span class="text-xs text-slate-500 ml-2">(標本分散 σ²: ${result.velocitySampleVariance.toFixed(5)} | 不偏分散 u²: ${result.velocityUnbiasedVariance.toFixed(5)})</span>
                            </div>
                            <div>
                                平均スリップ率: <span class="font-medium">${result.avgSlipRate.toFixed(2)} %</span>
                                 <span class="text-xs text-slate-500 ml-2">(標本分散 σ²: ${result.slipRateSampleVariance.toFixed(3)} | 不偏分散 u²: ${result.slipRateUnbiasedVariance.toFixed(3)})</span>
                            </div>
                        </div>
                         <div class="mt-2 pl-2 text-xs text-slate-500">(基準速度: ${result.referenceSpeed} m/s)</div>
                    `;
                    list.appendChild(item);
                });
                container.appendChild(list);
            }

            function renderAllCharts(processedData, travelAxis, verticalAxis) {
                Object.values(chartInstances).forEach(chart => { if(chart && chart.destroy) chart.destroy() });

                const filterType = lowpassFilterTypeSelect ? lowpassFilterTypeSelect.value : 'none';
                const filterStrength = lowpassStrengthInput ? parseFloat(lowpassStrengthInput.value) : 0;
                const isFiltered = filterType !== 'none';

                const horizontalAxes = ['X', 'Y', 'Z'].filter(ax => ax !== verticalAxis);
                const trajectoryYAxisName = horizontalAxes.find(ax => ax !== travelAxis);

                const initialLabels = {
                    'velocity': { id: 'velocity-chart', title: '速度 vs 距離', x: '距離 (m)', y: '速度 (m/s)' },
                    'slip': { id: 'slip-chart', title: 'スリップ率 vs 距離', x: '距離 (m)', y: 'スリップ率 (%)' },
                    'vertical': { id: 'vertical-chart', title: '鉛直変位 vs 距離', x: '距離 (m)', y: `鉛直変位 (${verticalAxis}軸) (m)` },
                    'trajectory': { id: 'trajectory-chart', title: '平面移動軌跡', x: `${travelAxis}軸 変位 (m)`, y: `${trajectoryYAxisName}軸 変位 (m)` }
                };

                const labelMapping = { 'v': 'velocity', 's': 'slip', 'z': 'vertical', 't': 'trajectory' };
                const prefixMapping = { 'velocity': 'v', 'slip': 's', 'vertical': 'z', 'trajectory': 't' };

                for (const [prefix, fullKey] of Object.entries(labelMapping)) {
                    const labels = initialLabels[fullKey];
                    const finalTitle = isFiltered ? `${labels.title} (ローパス適用)` : labels.title;
                    document.getElementById(`${prefix}-chart-title`).value = finalTitle;
                    document.getElementById(`${prefix}-chart-xlabel`).value = labels.x;
                    document.getElementById(`${prefix}-chart-ylabel`).value = labels.y;
                }

                const colors = ['#10b981', '#ef4444', '#3b82f6', '#f59e0b', '#8b5cf6', '#f97316'];
                const pointStyles = ['circle', 'rect', 'cross', 'star', 'triangle', 'rectRot'];

                const datasets = processedData.map((result, index) => {
                    const color = colors[index % colors.length];
                    const style = pointStyles[index % pointStyles.length];
                    const base = {
                        label: result.name, borderColor: color, backgroundColor: color,
                        pointRadius: 3, pointStyle: style, showLine: true, tension: 0.1, borderWidth: 1.5
                    };

                    let velocityData = result.data.map(d => ({ x: d.distance, y: d.instVelocity }));
                    let slipData = result.data.map(d => ({ x: d.distance, y: d.slipRate }));
                    let verticalData = result.data.map(d => ({ x: d.distance, y: d.verticalDisp }));
                    const trajectoryData = result.data.map(d => ({ x: d.trajectory_x, y: d.trajectory_y }));

                    if (filterType === 'moving-average') {
                        velocityData = applyMovingAverageFilter(velocityData, filterStrength);
                        slipData = applyMovingAverageFilter(slipData, filterStrength);
                        verticalData = applyMovingAverageFilter(verticalData, filterStrength);
                    } else if (filterType === 'gaussian') {
                        velocityData = applyGaussianFilter(velocityData, filterStrength);
                        slipData = applyGaussianFilter(slipData, filterStrength);
                        verticalData = applyGaussianFilter(verticalData, filterStrength);
                    }

                    return {
                        velocity: { ...base, data: velocityData },
                        slip: { ...base, data: slipData },
                        vertical: { ...base, data: verticalData },
                        trajectory: { ...base, data: trajectoryData }
                    };
                });

                ['velocity', 'vertical'].forEach(key => {
                    const chartId = `${key}-chart`;
                    const chartData = datasets.map(d => d[key]);
                    const prefix = prefixMapping[key];
                    const title = document.getElementById(`${prefix}-chart-title`).value;
                    const xlabel = document.getElementById(`${prefix}-chart-xlabel`).value;
                    const ylabel = document.getElementById(`${prefix}-chart-ylabel`).value;
                    chartInstances[chartId] = new Chart(document.getElementById(chartId), {
                        type: 'scatter',
                        data: { datasets: chartData },
                        options: getChartOptions(ylabel, xlabel, title)
                    });
                });

                const slipChartId = 'slip-chart';
                const slipChartData = datasets.map(d => d.slip);
                const slipPrefix = prefixMapping['slip'];
                const slipTitle = document.getElementById(`${slipPrefix}-chart-title`).value;
                const slipXLabel = document.getElementById(`${slipPrefix}-chart-xlabel`).value;
                const slipYLabel = document.getElementById(`${slipPrefix}-chart-ylabel`).value;
                const slipChartOptions = getChartOptions(slipYLabel, slipXLabel, slipTitle);
                slipChartOptions.scales.y.min = 0;
                slipChartOptions.scales.y.max = 100;
                chartInstances[slipChartId] = new Chart(document.getElementById(slipChartId), {
                    type: 'scatter',
                    data: { datasets: slipChartData },
                    options: slipChartOptions
                });

                const trajectoryDatasets = datasets.map(d => d.trajectory);

                let minVal = Infinity, maxVal = -Infinity;
                trajectoryDatasets.forEach(dataset => {
                    dataset.data.forEach(point => {
                        minVal = Math.min(minVal, point.x, point.y);
                        maxVal = Math.max(maxVal, point.x, point.y);
                    });
                });
                const range = maxVal - minVal;
                const padding = range === 0 ? 1 : range * 0.1;
                const finalMin = minVal - padding;
                const finalMax = maxVal + padding;

                const trajectoryPrefix = prefixMapping['trajectory'];
                const trajectoryTitle = document.getElementById(`${trajectoryPrefix}-chart-title`).value;
                const trajectoryXLabel = document.getElementById(`${trajectoryPrefix}-chart-xlabel`).value;
                const trajectoryYLabel = document.getElementById(`${trajectoryPrefix}-chart-ylabel`).value;
                const trajectoryOptions = getChartOptions(trajectoryYLabel, trajectoryXLabel, trajectoryTitle);
                trajectoryOptions.scales.x.min = finalMin;
                trajectoryOptions.scales.x.max = finalMax;
                trajectoryOptions.scales.y.min = finalMin;
                trajectoryOptions.scales.y.max = finalMax;
                trajectoryOptions.aspectRatio = 1;

                chartInstances['trajectory-chart'] = new Chart(document.getElementById('trajectory-chart'), {
                    type: 'scatter',
                    data: { datasets: trajectoryDatasets },
                    options: trajectoryOptions
                });

                const currentStyle = document.querySelector('.style-btn.bg-blue-600');
                handleStyleChange({target: currentStyle || document.getElementById('style-casual')});
            }

            function updateAllChartLabels() {
                const filterType = lowpassFilterTypeSelect.value;
                const isFiltered = filterType !== 'none';
                const suffix = isFiltered ? ' (ローパス適用)' : '';

                document.querySelectorAll('.chart-label-input').forEach(input => {
                     const chartId = input.dataset.chartId;
                     const labelType = input.dataset.labelType;
                     const chart = chartInstances[chartId];
                     if(!chart || !chart.options) return;

                     if(labelType === 'title') {
                        let baseTitle = input.value.replace(' (ローパス適用)', '');
                        chart.options.plugins.title.text = baseTitle + suffix;
                     }
                     if(labelType === 'x') chart.options.scales.x.title.text = input.value;
                     if(labelType === 'y') chart.options.scales.y.title.text = input.value;
                });
                Object.values(chartInstances).forEach(chart => chart.update('none'));
            }

            function getChartOptions(yLabel, xLabel, title) {
                return {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { title: { display: true, text: yLabel, font: { size: 13 } }, ticks: { font: { size: 12 } } },
                        x: { type: 'linear', position: 'bottom', title: { display: true, text: xLabel, font: { size: 13 } }, ticks: { font: { size: 12 } } }
                    },
                    plugins: {
                        legend: { position: 'top', labels: { usePointStyle: true, pointStyleWidth: 20, font: {size: 13} } },
                        title: { display: true, text: title, font: { size: 16, weight: '600' } }
                    },
                    animation: { duration: 0 }
                };
            }

            function handleStyleChange(event) {
                if (!event || !event.target) return;
                const mode = event.target.id.includes('formal') ? 'formal' : 'casual';
                const casualBtn = document.getElementById('style-casual');
                const formalBtn = document.getElementById('style-formal');
                casualBtn.classList.toggle('bg-blue-600', mode === 'casual');
                casualBtn.classList.toggle('text-white', mode === 'casual');
                casualBtn.classList.toggle('bg-slate-200', mode === 'formal');
                casualBtn.classList.toggle('text-slate-700', mode === 'formal');
                formalBtn.classList.toggle('bg-blue-600', mode === 'formal');
                formalBtn.classList.toggle('text-white', mode === 'formal');
                formalBtn.classList.toggle('bg-slate-200', mode === 'casual');
                formalBtn.classList.toggle('text-slate-700', mode === 'casual');
                const isFormal = mode === 'formal';
                const formalStyles = { color: '#000', font: { weight: 'bold' } };
                const casualStyles = { color: '#334155', font: { weight: 'normal' } };
                const newStyles = isFormal ? formalStyles : casualStyles;

                Object.values(chartInstances).forEach(chart => {
                    if (!chart || !chart.options || !chart.options.plugins || !chart.options.scales) return;

                    chart.options.plugins.title.color = newStyles.color;
                    chart.options.plugins.title.font.weight = newStyles.font.weight;
                    chart.options.plugins.legend.labels.color = newStyles.color;
                    chart.options.scales.x.title.color = newStyles.color;
                    chart.options.scales.x.title.font.weight = newStyles.font.weight;
                    chart.options.scales.x.ticks.color = newStyles.color;
                    chart.options.scales.y.title.color = newStyles.color;
                    chart.options.scales.y.title.font.weight = newStyles.font.weight;
                    chart.options.scales.y.ticks.color = newStyles.color;

                    if (isFormal) {
                        chart.options.scales.x.grid.display = false;
                        chart.options.scales.y.grid.display = false;
                        chart.options.scales.x.border = { color: '#000', width: 2 };
                        chart.options.scales.y.border = { color: '#000', width: 2 };
                        chart.data.datasets.forEach(dataset => {
                            Object.assign(dataset, { borderColor: '#000', backgroundColor: 'rgba(0,0,0,0.1)', borderWidth: 1, pointRadius: 2.5 });
                        });
                    } else {
                        chart.options.scales.x.grid.display = true;
                        chart.options.scales.y.grid.display = true;
                        chart.options.scales.x.grid.color = '#e2e8f0';
                        chart.options.scales.y.grid.color = '#e2e8f0';
                        chart.options.scales.x.border = { color: '#cbd5e1' };
                        chart.options.scales.y.border = { color: '#cbd5e1' };

                        const colors = ['#10b981', '#ef4444', '#3b82f6', '#f59e0b', '#8b5cf6', '#f97316'];
                        chart.data.datasets.forEach((dataset, i) => {
                            const color = colors[i % colors.length];
                            Object.assign(dataset, { borderColor: color, backgroundColor: color, borderWidth: 1.5, pointRadius: 3 });
                        });
                    }
                    chart.update('none');
                });
            }

            function downloadVelocityCSV() {
                if (allInstantaneousVelocities.length === 0) {
                    alert('ダウンロードするデータがありません。');
                    return;
                }
                const csv = Papa.unparse(allInstantaneousVelocities);
                const blob = new Blob([`\uFEFF${csv}`], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.setAttribute('download', 'instantaneous_velocities.csv');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            async function handleDownload(chartId, format) {
                const chart = chartInstances[chartId];
                if (!chart) return;

                downloadOverlay.classList.remove('hidden');

                const exportWidth = document.getElementById('export-width').value;
                const exportHeight = document.getElementById('export-height').value;

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = exportWidth;
                tempCanvas.height = exportHeight;

                tempCanvas.style.position = 'absolute';
                tempCanvas.style.left = '-9999px';
                tempCanvas.style.top = '0px';
                document.body.appendChild(tempCanvas);

                const tempChart = new Chart(tempCanvas, {
                     type: chart.config.type,
                     data: chart.config.data,
                     options: { ...chart.config.options, animation: false, responsive: false, maintainAspectRatio: false }
                });

                await new Promise(resolve => setTimeout(resolve, 500));

                try {
                    const canvas = await html2canvas(tempCanvas, { backgroundColor: '#FFFFFF', scale: 2 });

                    if (format === 'png') {
                        const image = canvas.toDataURL('image/png', 1.0);
                        const link = document.createElement('a');
                        link.href = image;
                        link.download = `${chartId}.png`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    } else if (format === 'pdf') {
                        if (!window.jspdf || !window.jspdf.jsPDF) {
                            alert('PDF generation library (jsPDF) is not loaded.'); return;
                        }
                        const { jsPDF } = window.jspdf;
                        const pdf = new jsPDF({
                            orientation: canvas.width > canvas.height ? 'landscape' : 'portrait',
                            unit: 'px',
                            format: [canvas.width, canvas.height]
                        });
                        pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
                        pdf.save(`${chartId}.pdf`);
                    }
                } catch (e) {
                    console.error("Failed to generate download:", e);
                    alert("An error occurred during download. Please check the console.");
                } finally {
                    tempChart.destroy();
                    document.body.removeChild(tempCanvas);
                    downloadOverlay.classList.add('hidden');
                }
            }

            // --- STANDARD VELOCITY TOOL SCRIPT ---
            const fileInputStd = document.getElementById('csv-file-input-std');
            const fileNameDisplayStd = document.getElementById('file-name-display-std');
            const loadingIndicatorStd = document.getElementById('loading-indicator-std');
            const parametersSectionStd = document.getElementById('step-2-parameters-std');
            const resultsSectionStd = document.getElementById('step-3-results-std');
            const rigidbodyContainerStd = document.getElementById('rigidbody-radio-container-std');
            const radiusInputStd = document.getElementById('radius-input-std');
            const axisSelectStd = document.getElementById('axis-select-std');
            const calculateBtnStd = document.getElementById('calculate-btn-std');
            const resultDisplayStd = document.getElementById('result-display-std');
            const resultValueStd = document.getElementById('result-value-std');
            const copyBtnStd = document.getElementById('copy-btn-std');
            const errorDisplayStd = document.getElementById('error-display-std');

            let parsedCsvDataStd = null;

            if (fileInputStd) {
                fileInputStd.addEventListener('change', handleFileSelectStd);
                calculateBtnStd.addEventListener('click', handleCalculationStd);
                copyBtnStd.addEventListener('click', handleCopyStd);
            }

            function handleFileSelectStd(event) {
                const file = event.target.files[0];
                if (!file) return;

                fileNameDisplayStd.textContent = file.name;
                parametersSectionStd.classList.add('hidden');
                resultsSectionStd.classList.add('hidden');
                errorDisplayStd.classList.add('hidden');
                loadingIndicatorStd.classList.remove('hidden');

                Papa.parse(file, {
                    complete: (results) => {
                        try {
                            parseCsvAndSetupUIStd(results.data);
                        } catch (e) {
                            showErrorStd(`ファイル解析エラー: ${e.message}`);
                        } finally {
                            loadingIndicatorStd.classList.add('hidden');
                        }
                    },
                    error: (error) => {
                        showErrorStd(`CSVファイルの読み込みに失敗しました: ${error.message}`);
                        loadingIndicatorStd.classList.add('hidden');
                    }
                });
            }

            function parseCsvAndSetupUIStd(csvData) {
                let dataStartIndex = -1, propertyRowIndex = -1, nameRowIndex = -1, typeRowIndex = -1;

                for (let i = 0; i < Math.min(15, csvData.length); i++) {
                    if (csvData[i][0] === 'Frame' && csvData[i][1] === 'Time (Seconds)') dataStartIndex = i + 1;
                    if (csvData[i][2] === 'Rotation' || csvData[i][2] === 'Position') propertyRowIndex = i;
                    if (csvData[i][1] === 'Name') nameRowIndex = i;
                    if (csvData[i][1] === 'Type') typeRowIndex = i;
                }

                if (dataStartIndex === -1 || propertyRowIndex === -1 || nameRowIndex === -1 || typeRowIndex === -1) {
                    throw new Error("CSVのヘッダー形式がMotiveエクスポート形式と異なります。");
                }

                const headerInfo = { dataStartIndex, propertyRowIndex, nameRowIndex, typeRowIndex };
                const rigidBodies = extractRigidBodiesStd(csvData, headerInfo);
                if (Object.keys(rigidBodies).length === 0) {
                     throw new Error("ファイル内に有効な剛体(Rigid Body)データが見つかりませんでした。");
                }

                parsedCsvDataStd = {
                    headerInfo,
                    dataRows: csvData.slice(headerInfo.dataStartIndex),
                    rigidBodies
                };

                populateRigidBodyRadiosStd(Object.keys(rigidBodies));
                parametersSectionStd.classList.remove('hidden');
            }

            function extractRigidBodiesStd(csvData, headerInfo) {
                const rigidBodies = {};
                const typeRow = csvData[headerInfo.typeRowIndex];
                const nameRow = csvData[headerInfo.nameRowIndex];
                const propertyRow = csvData[headerInfo.propertyRowIndex];
                const dataHeaderRow = csvData[headerInfo.dataStartIndex - 1];

                for (let i = 2; i < typeRow.length; i++) {
                    if (typeRow[i] === 'Rigid Body' && propertyRow[i] === 'Rotation') {
                        const name = nameRow[i];
                        if (!rigidBodies[name]) {
                            rigidBodies[name] = {
                                name: name,
                                rotation: {
                                    [dataHeaderRow[i]]: i,
                                    [dataHeaderRow[i+1]]: i+1,
                                    [dataHeaderRow[i+2]]: i+2
                                }
                            };
                        }
                    }
                }
                return rigidBodies;
            }

            function populateRigidBodyRadiosStd(bodyNames) {
                rigidbodyContainerStd.innerHTML = '';
                const keywords = ['wheel', 'tire'];
                let defaultIndex = 0;
                const firstMatchIndex = bodyNames.findIndex(name =>
                    keywords.some(keyword => name.toLowerCase().includes(keyword))
                );
                if (firstMatchIndex !== -1) { defaultIndex = firstMatchIndex; }
                bodyNames.forEach((name, index) => {
                    const id = `body-radio-std-${name.replace(/\s+/g, '-')}`;
                    const div = document.createElement('div');
                    div.className = 'flex items-center';
                    div.innerHTML = `
                        <input id="${id}" type="radio" value="${name}" name="rigidbody-select-std" class="rigidbody-radio-std h-4 w-4 text-blue-600 border-slate-300 focus:ring-blue-500" ${index === defaultIndex ? 'checked' : ''}>
                        <label for="${id}" class="ml-3 block text-sm text-slate-900">${name}</label>
                    `;
                    rigidbodyContainerStd.appendChild(div);
                });
            }

            function handleCalculationStd() {
                if (!parsedCsvDataStd) {
                    showErrorStd("先にファイルを解析してください。"); return;
                }
                resultsSectionStd.classList.add('hidden');
                resultDisplayStd.classList.add('hidden');
                errorDisplayStd.classList.add('hidden');

                const selectedRadio = document.querySelector('.rigidbody-radio-std:checked');
                if (!selectedRadio) {
                    showErrorStd("解析する剛体を選択してください。"); return;
                }
                const radiusCm = parseFloat(radiusInputStd.value);
                if (isNaN(radiusCm) || radiusCm <= 0) {
                    showErrorStd("半径には正の数値を入力してください。"); return;
                }
                const radiusM = radiusCm / 100.0;
                const selectedAxis = axisSelectStd.value;
                const selectedBodyName = selectedRadio.value;

                try {
                    const bodyInfo = parsedCsvDataStd.rigidBodies[selectedBodyName];
                    const rotationColumnIndex = bodyInfo.rotation[selectedAxis];

                    if (rotationColumnIndex === undefined) {
                        throw new Error(`選択された剛体に'${selectedAxis}'軸の回転データが存在しません。`);
                    }
                    const timeData = parsedCsvDataStd.dataRows.map(row => parseFloat(row[1])).filter(t => !isNaN(t));
                    const angleData = parsedCsvDataStd.dataRows.map(row => parseFloat(row[rotationColumnIndex])).filter(a => !isNaN(a));

                    if (timeData.length !== angleData.length || timeData.length < 2) {
                        throw new Error("有効な時間または角度データが不足しています。");
                    }

                    const unwrappedAngles = unwrapAnglesStd(angleData);
                    const period = findRotationPeriodStd(timeData, unwrappedAngles);

                    if (period === null) {
                        throw new Error("データ内で1回転以上の回転を検出できませんでした。回転軸の選択が間違っている可能性があります。");
                    }
                    const omega = (2 * Math.PI) / period;
                    const velocity = radiusM * omega;
                    const velocityStr = velocity.toFixed(8);

                    resultValueStd.textContent = velocityStr;
                    copyBtnStd.dataset.copyValue = velocityStr;
                    resultDisplayStd.classList.remove('hidden');
                    resultsSectionStd.classList.remove('hidden');
                    setTimeout(() => resultsSectionStd.scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);

                } catch (e) {
                    showErrorStd(`[${selectedBodyName}] ${e.message}`);
                }
            }

            function unwrapAnglesStd(angles) {
                const unwrapped = [angles[0]];
                let offset = 0;
                for (let i = 1; i < angles.length; i++) {
                    const diff = angles[i] - angles[i-1];
                    if (diff > 180) { offset -= 360; }
                    else if (diff < -180) { offset += 360; }
                    unwrapped.push(angles[i] + offset);
                }
                return unwrapped;
            }

            function findRotationPeriodStd(times, unwrappedAngles) {
                let motionStartIndex = -1;
                for (let i = 1; i < unwrappedAngles.length; i++) {
                    if (Math.abs(unwrappedAngles[i] - unwrappedAngles[0]) > 5) {
                        motionStartIndex = i; break;
                    }
                }
                if (motionStartIndex === -1 || motionStartIndex > unwrappedAngles.length - 10) return null;

                const sampleEndIndex = Math.min(motionStartIndex + 20, unwrappedAngles.length - 1);
                const angleChange = unwrappedAngles[sampleEndIndex] - unwrappedAngles[motionStartIndex];
                if (Math.abs(angleChange) < 10) return null;

                const direction = Math.sign(angleChange);
                const targetAngle = unwrappedAngles[motionStartIndex] + (360 * direction);
                let endIndex = -1;
                for (let i = motionStartIndex + 1; i < unwrappedAngles.length; i++) {
                    if ((direction > 0 && unwrappedAngles[i] >= targetAngle) || (direction < 0 && unwrappedAngles[i] <= targetAngle)) {
                        endIndex = i; break;
                    }
                }
                if (endIndex === -1) return null;

                const T_start = times[motionStartIndex];
                const angle_before = unwrappedAngles[endIndex - 1], angle_after = unwrappedAngles[endIndex];
                const time_before = times[endIndex - 1], time_after = times[endIndex];

                if (angle_after === angle_before) return time_after - T_start;

                const fraction = (targetAngle - angle_before) / (angle_after - angle_before);
                return (time_before + fraction * (time_after - time_before)) - T_start;
            }

            function handleCopyStd() {
                const textToCopy = copyBtnStd.dataset.copyValue;
                if (!textToCopy) return;

                const textArea = document.createElement('textarea');
                textArea.value = textToCopy;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    copyBtnStd.textContent = 'コピーしました！';
                    setTimeout(() => { copyBtnStd.textContent = '結果をコピー'; }, 2000);
                } catch (err) {
                    copyBtnStd.textContent = 'コピー失敗';
                }
                document.body.removeChild(textArea);
            }

            function showErrorStd(message) {
                errorDisplayStd.textContent = message;
                errorDisplayStd.classList.remove('hidden');
                resultsSectionStd.classList.remove('hidden');
                setTimeout(() => resultsSectionStd.scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
            }

            // --- WIDE AREA ANALYSIS TOOL SCRIPT (kiseki) ---
            const csvFileInputWide = document.getElementById('csv-files-wide');
            const fileListAreaWide = document.getElementById('file-list-area-wide');
            const clearFilesBtnWide = document.getElementById('clear-files-btn-wide');
            const samplingRateInputWide = document.getElementById('sampling-rate-wide');
            const gridSizeInputWide = document.getElementById('heatmap-grid-size-wide');
            const verticalAxisSelectWide = document.getElementById('vertical-axis-wide');
            const rigidbodySelectionAreaWide = document.getElementById('rigidbody-selection-area-wide');
            const rigidbodyListContainerWide = document.getElementById('rigidbody-list-container-wide');
            const analyzeBtnWide = document.getElementById('analyze-btn-wide');
            const resultsCardWide = document.getElementById('results-card-wide');

            const showTrajectoryBtnWide = document.getElementById('show-trajectory-btn-wide');
            const showHeatmapBtnWide = document.getElementById('show-heatmap-btn-wide');
            const show3DTrajectoryBtnWide = document.getElementById('show-3d-trajectory-btn-wide');
            const trajectoryViewWide = document.getElementById('trajectory-view-wide');
            const heatmapViewWide = document.getElementById('heatmap-view-wide');
            const trajectory3DViewWide = document.getElementById('trajectory-3d-view-wide');
            const heatmapMaxValueWide = document.getElementById('heatmap-max-value-wide');

            const calculateCoverageBtnWide = document.getElementById('calculate-coverage-btn-wide');
            const coverageResultElWide = document.getElementById('coverage-result-wide');
            const areaShapeRadiosWide = document.querySelectorAll('input[name="area-shape-wide"]');
            const centerTypeRadiosWide = document.querySelectorAll('input[name="center-type-wide"]');
            const customCenterInputsWide = document.getElementById('custom-center-inputs-wide');
            const areaSizeLabelWide = document.getElementById('area-size-label-wide');
            const areaSizeInputWide = document.getElementById('area-size-wide');
            const centerXInputWide = document.getElementById('center-x-wide');
            const centerYInputWide = document.getElementById('center-y-wide');
            const centerXLabelWide = document.getElementById('center-x-label-wide');
            const centerYLabelWide = document.getElementById('center-y-label-wide');
            const dataUnitRadiosWide = document.querySelectorAll('input[name="data-unit-wide"]');
            const unitLabels = document.querySelectorAll('.unit-label');
            const coordinateUnitNote = document.getElementById('coordinate-unit-note');

            let trajectoryChartWide = null;
            let fileDataStoreWide = {};
            let lastSampledDataWide = null;
            let lastHeatmapGridWide = null;
            let is3DTrajectoryRendered = false;
            const heatmapTooltip = document.getElementById('heatmap-tooltip');
            const heatmapCanvas = document.getElementById('heatmap-canvas-wide');

            heatmapCanvas.addEventListener('mousemove', (event) => {
                if (!lastHeatmapGridWide || !lastHeatmapGridWide.gridInfo) return;

                const rect = heatmapCanvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                const { grid, gridInfo } = lastHeatmapGridWide;
                const { rows, cols } = gridInfo;
                const cellWidth = heatmapCanvas.width / cols;
                const cellHeight = heatmapCanvas.height / rows;

                const col = Math.floor(x / cellWidth);
                const row = rows - 1 - Math.floor(y / cellHeight);

                if (col >= 0 && col < cols && row >= 0 && row < rows) {
                    const count = grid[row][col];
                    heatmapTooltip.textContent = `カウント: ${count}`;
                    heatmapTooltip.style.left = `${event.clientX - rect.left + 10}px`;
                    heatmapTooltip.style.top = `${event.clientY - rect.top + 10}px`;
                    heatmapTooltip.classList.remove('hidden');
                } else {
                    heatmapTooltip.classList.add('hidden');
                }
            });

            heatmapCanvas.addEventListener('mouseout', () => {
                heatmapTooltip.classList.add('hidden');
            });

            csvFileInputWide.addEventListener('change', handleFileSelectWide);
            clearFilesBtnWide.addEventListener('click', clearAllFilesWide);
            analyzeBtnWide.addEventListener('click', analyzeDataWide);
            showTrajectoryBtnWide.addEventListener('click', () => switchViewWide('trajectory'));
            showHeatmapBtnWide.addEventListener('click', () => switchViewWide('heatmap'));
            show3DTrajectoryBtnWide.addEventListener('click', () => switchViewWide('3d-trajectory'));
            document.querySelectorAll('.download-btn-wide').forEach(btn => btn.addEventListener('click', handleDownloadWide));

            calculateCoverageBtnWide.addEventListener('click', calculateAndDisplayCoverageWide);
            areaShapeRadiosWide.forEach(radio => radio.addEventListener('change', (e) => {
                areaSizeLabelWide.textContent = e.target.value === 'circle' ? '半径' : '一辺の長さ';
            }));
            centerTypeRadiosWide.forEach(radio => radio.addEventListener('change', (e) => {
                customCenterInputsWide.classList.toggle('hidden', e.target.value === 'data');
            }));

            dataUnitRadiosWide.forEach(radio => radio.addEventListener('change', (e) => {
                const selectedUnit = e.target.value;
                unitLabels.forEach(label => label.textContent = selectedUnit);

                const gridSizeInput = document.getElementById('heatmap-grid-size-wide');
                const areaSizeInput = document.getElementById('area-size-wide');

                if (selectedUnit === 'm') {
                    gridSizeInput.value = (parseFloat(gridSizeInput.value) / 1000).toFixed(2);
                    gridSizeInput.step = 0.1;
                    areaSizeInput.value = (parseFloat(areaSizeInput.value) / 1000).toFixed(2);
                    areaSizeInput.step = 0.1;
                    coordinateUnitNote.textContent = "※ 座標は正規化せず、元データの値をそのまま使用しています。";
                } else { // mm
                    gridSizeInput.value = Math.round(parseFloat(gridSizeInput.value) * 1000);
                    gridSizeInput.step = 100;
                    areaSizeInput.value = Math.round(parseFloat(areaSizeInput.value) * 1000);
                    areaSizeInput.step = 100;
                    coordinateUnitNote.textContent = "※ 座標は正規化せず、元データの値をメートル単位に変換して使用しています。";
                }
            }));

            function handleFileSelectWide(event) {
                const files = Array.from(event.target.files);
                if (files.length === 0) return;

                loadingDiv.classList.remove('hidden');
                loadingText.textContent = "ファイルを読み込み中...";

                const filePromises = files.map(file => {
                    if (fileDataStoreWide[file.name]) {
                        console.log(`File ${file.name} is already loaded.`);
                        return Promise.resolve();
                    }
                    return new Promise((resolve, reject) => {
                        Papa.parse(file, {
                            complete: (results) => {
                                try {
                                    const { rigidBodyInfo, rawData: processedData } = parseHeaderWide(results.data);
                                    fileDataStoreWide[file.name] = {
                                        rawData: processedData,
                                        rigidBodyInfo: rigidBodyInfo
                                    };
                                    resolve();
                                } catch (error) {
                                    reject(new Error(`"${file.name}"の解析に失敗: ${error.message}`));
                                }
                            },
                            error: (err) => reject(new Error(`"${file.name}"の読み込みに失敗: ${err.message}`))
                        });
                    });
                });

                Promise.all(filePromises)
                    .then(() => {
                        updateFileAndRigidBodyUIWide();
                        analyzeBtnWide.disabled = false;
                    })
                    .catch(error => {
                        alert(error.message);
                    })
                    .finally(() => {
                        loadingDiv.classList.add('hidden');
                        csvFileInputWide.value = '';
                    });
            }

            function parseHeaderWide(data) {
                let typeRowIndex = -1, nameRowIndex = -1, propertyRowIndex = -1, dataHeaderRowIndex = -1;
                for(let i = 0; i < Math.min(20, data.length); i++) {
                    const row = data[i];
                    if (!row || row.length < 2) continue;
                    if (row[1] === 'Type') typeRowIndex = i;
                    if (row[1] === 'Name') nameRowIndex = i;
                    if (row.includes('Position') && row.includes('Rotation')) propertyRowIndex = i;
                    if (row[0] === 'Frame' && row[1] === 'Time (Seconds)') {
                        dataHeaderRowIndex = i;
                        break;
                    }
                }
                if ([typeRowIndex, nameRowIndex, propertyRowIndex, dataHeaderRowIndex].includes(-1)) {
                    throw new Error("OptiTrack CSVのヘッダー形式を認識できませんでした。");
                }

                const typeRow = data[typeRowIndex];
                const nameRow = data[nameRowIndex];
                const propertyRow = data[propertyRowIndex];
                const dataHeaderRow = data[dataHeaderRowIndex];
                const dataStartIndex = dataHeaderRowIndex + 1;

                let rigidBodyInfo = {};
                for (let i = 2; i < typeRow.length; i++) {
                    if (typeRow[i] === 'Rigid Body' && propertyRow[i] === 'Position') {
                        const name = nameRow[i];
                        if (rigidBodyInfo[name]) continue;
                        rigidBodyInfo[name] = { name: name, xIndex: -1, yIndex: -1, zIndex: -1 };
                        for (let j = 0; j < 3; j++) {
                            const colIndex = i + j;
                            if (colIndex >= dataHeaderRow.length || nameRow[colIndex] !== name || propertyRow[colIndex] !== 'Position') break;
                            const axis = dataHeaderRow[colIndex].toUpperCase();
                            if (axis === 'X') rigidBodyInfo[name].xIndex = colIndex;
                            else if (axis === 'Y') rigidBodyInfo[name].yIndex = colIndex;
                            else if (axis === 'Z') rigidBodyInfo[name].zIndex = colIndex;
                        }
                    }
                }

                Object.keys(rigidBodyInfo).forEach(name => {
                    const info = rigidBodyInfo[name];
                    if (info.xIndex === -1 || info.yIndex === -1 || info.zIndex === -1) {
                         console.warn(`剛体 "${name}" の座標(X,Y,Z)の一部が見つかりませんでした。この剛体は無視されます。`);
                         delete rigidBodyInfo[name];
                    }
                });

                const rawData = data.slice(dataStartIndex).filter(row => row.length > 1 && row[1] !== '');
                return { rigidBodyInfo, rawData };
            }

            function updateFileAndRigidBodyUIWide() {
                fileListAreaWide.innerHTML = Object.keys(fileDataStoreWide).map(filename =>
                    `<div class="bg-slate-50 p-2.5 rounded-md border text-sm flex justify-between items-center">
                        <span class="text-slate-700 truncate pr-4">${filename}</span>
                    </div>`
                ).join('');

                rigidbodyListContainerWide.innerHTML = Object.keys(fileDataStoreWide).map(filename => {
                    const info = fileDataStoreWide[filename];
                    if (Object.keys(info.rigidBodyInfo).length === 0) return '';
                    return `
                        <div>
                            <h4 class="font-semibold text-sm text-slate-800 mb-2 border-b pb-1">${filename}</h4>
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-y-2 gap-x-4">
                                ${Object.keys(info.rigidBodyInfo).map(name => `
                                    <div class="rigidbody-item-container-wide">
                                        <label class="flex items-center space-x-2 p-2 rounded-md hover:bg-slate-100 cursor-pointer w-full">
                                            <input type="checkbox" class="rigidbody-checkbox-wide form-checkbox h-4 w-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500" data-filename="${filename}" value="${name}" checked>
                                            <span class="text-slate-800 text-sm">${name}</span>
                                        </label>
                                        <div class="legend-input-container-wide pl-7 mt-1 hidden">
                                            <label class="text-xs text-slate-500">凡例名:</label>
                                            <input type="text" class="legend-label-input-wide mt-1 block w-full rounded-md shadow-sm p-1.5 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500" data-filename="${filename}" data-bodyname="${name}" value="${filename} - ${name}">
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }).join('');

                rigidbodyListContainerWide.addEventListener('change', (event) => {
                    if (event.target.classList.contains('rigidbody-checkbox-wide')) {
                        const checkbox = event.target;
                        const itemContainer = checkbox.closest('.rigidbody-item-container-wide');
                        const legendInputContainer = itemContainer.querySelector('.legend-input-container-wide');
                        if (legendInputContainer) {
                            legendInputContainer.classList.toggle('hidden', !checkbox.checked);
                        }
                    }
                });

                document.querySelectorAll('.rigidbody-checkbox-wide:checked').forEach(checkbox => {
                    const itemContainer = checkbox.closest('.rigidbody-item-container-wide');
                    const legendInputContainer = itemContainer.querySelector('.legend-input-container-wide');
                    if (legendInputContainer) {
                        legendInputContainer.classList.remove('hidden');
                    }
                });

                rigidbodySelectionAreaWide.classList.toggle('hidden', Object.keys(fileDataStoreWide).length === 0);
                clearFilesBtnWide.classList.toggle('hidden', Object.keys(fileDataStoreWide).length === 0);
            }

            function clearAllFilesWide() {
                fileDataStoreWide = {};
                csvFileInputWide.value = '';
                updateFileAndRigidBodyUIWide();
                resultsCardWide.classList.add('hidden');
                analyzeBtnWide.disabled = true;
            }

            function analyzeDataWide() {
                const verticalAxis = verticalAxisSelectWide.value;
                const dataUnit = document.querySelector('input[name="data-unit-wide"]:checked').value;
                const selectedBodies = Array.from(document.querySelectorAll('.rigidbody-checkbox-wide:checked')).map(cb => {
                    const filename = cb.dataset.filename;
                    const bodyName = cb.value;
                    const legendInput = document.querySelector(`.legend-label-input-wide[data-filename="${filename}"][data-bodyname="${bodyName}"]`);
                    return {
                        filename: filename,
                        bodyName: bodyName,
                        label: legendInput ? legendInput.value : `${filename} - ${bodyName}`
                    };
                });

                if (selectedBodies.length === 0) { alert('解析する剛体を少なくとも1つ選択してください。'); return; }
                const samplingRate = parseFloat(samplingRateInputWide.value);
                if (isNaN(samplingRate) || samplingRate <= 0) { alert('データ取得間隔には正の数値を入力してください。'); return; }
                let gridSize = parseFloat(gridSizeInputWide.value);
                if (isNaN(gridSize) || gridSize <= 0) { alert('マス目のサイズには正の数値を入力してください。'); return; }

                if (dataUnit === 'mm') {
                    gridSize /= 1000;
                }

                loadingDiv.classList.remove('hidden');
                loadingText.textContent = "解析中...";
                is3DTrajectoryRendered = false; // Reset render flag

                setTimeout(() => {
                    try {
                        const axes = ['X', 'Y', 'Z'];
                        const horizontalAxes = axes.filter(ax => ax !== verticalAxis);
                        const hAxis1 = horizontalAxes[0];
                        const hAxis2 = horizontalAxes[1];

                        lastSampledDataWide = sampleAllDataWide(selectedBodies, samplingRate, dataUnit);
                        drawTrajectoryWide(lastSampledDataWide, hAxis1, hAxis2);
                        // Defer 3D trajectory drawing until the tab is clicked
                        // draw3DTrajectory(lastSampledDataWide);
                        lastHeatmapGridWide = calculateHeatmapGridWide(lastSampledDataWide, gridSize, hAxis1, hAxis2);
                        heatmapMaxValueWide.textContent = lastHeatmapGridWide.maxCount;

                        const allPoints = [].concat(...Object.values(lastSampledDataWide));
                        const dataCenter = calculateDataCenterWide(allPoints);

                        if (dataUnit === 'mm') {
                            centerXInputWide.value = (dataCenter.x * 1000).toFixed(2);
                            centerYInputWide.value = (dataCenter.y * 1000).toFixed(2);
                        } else {
                            centerXInputWide.value = dataCenter.x.toFixed(2);
                            centerYInputWide.value = dataCenter.y.toFixed(2);
                        }

                        centerXLabelWide.textContent = `${hAxis1}:`;
                        centerYLabelWide.textContent = `${hAxis2}:`;

                        resultsCardWide.classList.remove('hidden');
                        switchViewWide('trajectory');
                        setTimeout(() => resultsCardWide.scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
                    } catch (error) {
                        alert(`解析エラー: ${error.message}`);
                    } finally {
                        loadingDiv.classList.add('hidden');
                    }
                }, 50);
            }

            function sampleAllDataWide(selectedBodies, samplingRate, dataUnit) {
                const result = {};
                selectedBodies.forEach(({ filename, bodyName, label }) => {
                    const uniqueKey = label;
                    result[uniqueKey] = [];
                    const { rawData, rigidBodyInfo } = fileDataStoreWide[filename];
                    const info = rigidBodyInfo[bodyName];
                    if (!info) return;

                    let nextSampleTime = 0;
                    for (const row of rawData) {
                        const time = parseFloat(row[1]);
                        if (isNaN(time)) continue;

                        if (time >= nextSampleTime) {
                            let x = parseFloat(row[info.xIndex]);
                            let y = parseFloat(row[info.yIndex]);
                            let z = parseFloat(row[info.zIndex]);

                            if (dataUnit === 'mm') {
                                x /= 1000;
                                y /= 1000;
                                z /= 1000;
                            }

                            if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                                result[uniqueKey].push({ t: time, x: x, y: y, z: z });
                            }
                            nextSampleTime += samplingRate;
                        }
                    }
                });
                return result;
            }

            function drawTrajectoryWide(data, hAxis1, hAxis2) {
                const ctx = document.getElementById('trajectory-chart-wide').getContext('2d');
                const colors = ['#3b82f6', '#ef4444', '#10b981', '#f97316', '#8b5cf6', '#f59e0b', '#14b8a6', '#ec4899'];
                if (trajectoryChartWide) trajectoryChartWide.destroy();

                const datasets = Object.keys(data).map((uniqueKey, index) => ({
                    label: uniqueKey,
                    data: data[uniqueKey].map(p => ({ x: p[hAxis1.toLowerCase()], y: p[hAxis2.toLowerCase()] })),
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length],
                    showLine: true, tension: 0.1, pointRadius: 2, borderWidth: 2,
                }));

                const allPoints = [].concat(...datasets.map(d => d.data));
                let scales = {};
                if (allPoints.length > 0) {
                    const allX = allPoints.map(p => p.x), allY = allPoints.map(p => p.y);
                    const minX = Math.min(...allX), maxX = Math.max(...allX);
                    const minY = Math.min(...allY), maxY = Math.max(...allY);
                    const rangeX = maxX - minX, rangeY = maxY - minY;
                    const maxRange = Math.max(rangeX, rangeY, 0.1) * 1.1;
                    const midX = (minX + maxX) / 2, midY = (minY + maxY) / 2;
                    scales = {
                        x: { min: midX - maxRange / 2, max: midX + maxRange / 2, grid: { color: '#e2e8f0' }, title: { display: true, text: `${hAxis1}座標 (m)` }},
                        y: { min: midY - maxRange / 2, max: midY + maxRange / 2, grid: { color: '#e2e8f0' }, title: { display: true, text: `${hAxis2}座標 (m)` }}
                    };
                }
                trajectoryChartWide = new Chart(ctx, {
                    type: 'scatter', data: { datasets }, options: { responsive: true, maintainAspectRatio: true, plugins: { title: { display: true, text: '剛体の移動軌跡' }, legend: { position: 'top' }}, scales: scales, aspectRatio: 1 }
                });
            }

            function draw3DTrajectory(data) {
                const container = document.getElementById('trajectory-3d-container-wide');
                if (!container) return;
                container.innerHTML = '';

                const logDiv = document.createElement('div');
                logDiv.style.position = 'absolute';
                logDiv.style.top = '10px';
                logDiv.style.left = '10px';
                logDiv.style.padding = '5px';
                logDiv.style.backgroundColor = 'rgba(0,0,0,0.6)';
                logDiv.style.color = 'white';
                logDiv.style.fontSize = '10px';
                logDiv.style.fontFamily = 'monospace';
                logDiv.style.zIndex = '100';
                container.appendChild(logDiv);

                const log = (msg) => {
                    logDiv.innerHTML += msg + '<br>';
                    console.log(msg);
                };

                log('--- 3D Trajectory Log ---');
                log(`Data received: ${Object.keys(data).length} rigid bodies.`);

                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf1f5f9);

                const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 10000);
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                container.appendChild(renderer.domElement);

                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;

                // Add lights to the scene
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 50);
                scene.add(directionalLight);

                const colors = ['#3b82f6', '#ef4444', '#10b981', '#f97316', '#8b5cf6', '#f59e0b', '#14b8a6', '#ec4899'];

                const allPoints = [].concat(...Object.values(data).map(arr => arr.map(p => new THREE.Vector3(p.x, p.y, p.z))));
                log(`Total points: ${allPoints.length}`);

                if (allPoints.length > 1) {
                    Object.values(data).forEach((pointsData, index) => {
                        const points = pointsData.map(p => new THREE.Vector3(p.x, p.y, p.z));
                        if (points.length < 2) return;

                        const curve = new THREE.CatmullRomCurve3(points);
                        const tubeGeometry = new THREE.TubeGeometry(curve, points.length * 2, 0.05, 8, false);
                        const tubeMaterial = new THREE.MeshStandardMaterial({
                            color: colors[index % colors.length],
                            metalness: 0.5,
                            roughness: 0.5
                        });
                        const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                        scene.add(tube);
                    });

                    const boundingBox = new THREE.Box3().setFromPoints(allPoints);
                    const center = new THREE.Vector3();
                    boundingBox.getCenter(center);
                    const size = new THREE.Vector3();
                    boundingBox.getSize(size);

                    log(`BBox Center: ${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)}`);
                    log(`BBox Size: ${size.x.toFixed(2)}, ${size.y.toFixed(2)}, ${size.z.toFixed(2)}`);

                    const maxDim = Math.max(size.x, size.y, size.z);
                    log(`Max dimension: ${maxDim.toFixed(2)}`);
                    const fov = camera.fov * (Math.PI / 180);
                    const cameraDistance = Math.abs(maxDim / (2 * Math.tan(fov / 2)));

                    const offset = cameraDistance * 1.2;
                    camera.position.set(center.x, center.y, center.z + Math.max(offset, 5));

                    camera.near = cameraDistance / 100;
                    camera.far = cameraDistance * 100;
                    camera.updateProjectionMatrix();

                    log(`Camera Position: ${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)}`);
                    log(`Camera Target: ${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)}`);

                    controls.target.copy(center);
                    controls.update();

                    const gridHelper = new THREE.GridHelper(Math.ceil(maxDim * 1.5) || 10, 20, 0xcccccc, 0xcccccc);
                    gridHelper.position.y = boundingBox.min.y;
                    scene.add(gridHelper);

                    const axesHelper = new THREE.AxesHelper(maxDim * 0.8);
                    axesHelper.position.set(center.x, center.y, center.z);
                    scene.add(axesHelper);

                } else {
                    camera.position.set(0, 5, 10);
                    controls.target.set(0, 0, 0);
                    const gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xcccccc);
                    scene.add(gridHelper);
                    const axesHelper = new THREE.AxesHelper(5);
                    scene.add(axesHelper);
                }

                function animate() {
                    requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                }
                animate();

                const resizeObserver = new ResizeObserver(entries => {
                    if (entries.length === 0) return;
                    const { width, height } = entries[0].contentRect;
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                    renderer.setSize(width, height);
                });

                resizeObserver.observe(container);
            }

            function calculateHeatmapGridWide(data, gridSize, hAxis1, hAxis2) {
                const hAxis1Lower = hAxis1.toLowerCase();
                const hAxis2Lower = hAxis2.toLowerCase();
                const allPoints = [].concat(...Object.values(data));
                if (allPoints.length === 0) return { grid: [], maxCount: 0, gridInfo: null };

                const minX = Math.min(...allPoints.map(p => p[hAxis1Lower])), maxX = Math.max(...allPoints.map(p => p[hAxis1Lower]));
                const minY = Math.min(...allPoints.map(p => p[hAxis2Lower])), maxY = Math.max(...allPoints.map(p => p[hAxis2Lower]));
                const rangeX = maxX - minX, rangeY = maxY - minY;
                const maxRange = Math.max(rangeX, rangeY, 0.1);
                const midX = (minX + maxX) / 2, midY = (minY + maxY) / 2;
                const gridMinX = midX - maxRange / 2, gridMinY = midY - maxRange / 2;
                const divisions = Math.ceil(maxRange / gridSize);
                const cols = Math.max(1, divisions), rows = Math.max(1, divisions);

                const grid = Array(rows).fill(0).map(() => Array(cols).fill(0));
                const timeSteps = {};
                const samplingRate = parseFloat(samplingRateInputWide.value);
                allPoints.forEach(p => {
                    const t = Math.floor(p.t / samplingRate);
                    if (!timeSteps[t]) timeSteps[t] = [];
                    timeSteps[t].push(p);
                });
                Object.values(timeSteps).forEach(pointsInStep => {
                    const visitedCells = new Set();
                    pointsInStep.forEach(point => {
                        const col = Math.floor((point[hAxis1Lower] - gridMinX) / gridSize);
                        const row = Math.floor((point[hAxis2Lower] - gridMinY) / gridSize);
                        if (col >= 0 && col < cols && row >= 0 && row < rows) {
                           visitedCells.add(`${row}-${col}`);
                        }
                    });
                    visitedCells.forEach(cell => {
                        const [r, c] = cell.split('-').map(Number);
                        if (grid[r] !== undefined && grid[r][c] !== undefined) grid[r][c]++;
                    });
                });
                const maxCount = Math.max(0, ...[].concat(...grid));
                const gridInfo = { gridMinX, gridMinY, rows, cols, gridSize };
                return { grid, maxCount, gridInfo };
            }

            function drawHeatmapCanvasWide(grid, maxCount, hAxis1, hAxis2) {
                const canvas = document.getElementById('heatmap-canvas-wide');
                const container = document.getElementById('heatmap-container-wide');
                if (!container) return;
                const ctx = canvas.getContext('2d');
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const rows = grid.length;
                if (rows === 0 || grid[0].length === 0) return;
                const cols = grid[0].length;
                const cellWidth = canvas.width / cols, cellHeight = canvas.height / rows;
                if (maxCount > 0) {
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            const count = grid[r][c];
                            if (count > 0) {
                                const value = count / maxCount;
                                ctx.fillStyle = getColorForValueWide(value);
                                ctx.fillRect(c * cellWidth, (rows - 1 - r) * cellHeight, cellWidth + 1, cellHeight + 1);
                            }
                        }
                    }
                }
            }

            function getColorForValueWide(value) {
                // Blue -> Cyan -> Green -> Yellow -> Red
                const colors = [
                    { r: 0,   g: 0,   b: 255 }, // Blue
                    { r: 0,   g: 255, b: 255 }, // Cyan
                    { r: 0,   g: 255, b: 0 },   // Green
                    { r: 255, g: 255, b: 0 },   // Yellow
                    { r: 255, g: 0,   b: 0 }    // Red
                ];

                const segment = 1 / (colors.length - 1);
                const index = Math.min(Math.floor(value / segment), colors.length - 2);
                const t = (value - (index * segment)) / segment;

                const r = colors[index].r + t * (colors[index + 1].r - colors[index].r);
                const g = colors[index].g + t * (colors[index + 1].g - colors[index].g);
                const b = colors[index].b + t * (colors[index + 1].b - colors[index].b);

                return `rgb(${r}, ${g}, ${b})`;
            }

            function switchViewWide(viewName) {
                trajectoryViewWide.classList.add('hidden');
                heatmapViewWide.classList.add('hidden');
                trajectory3DViewWide.classList.add('hidden');
                showTrajectoryBtnWide.classList.remove('active');
                showHeatmapBtnWide.classList.remove('active');
                show3DTrajectoryBtnWide.classList.remove('active');

                if (viewName === 'trajectory') {
                    trajectoryViewWide.classList.remove('hidden');
                    showTrajectoryBtnWide.classList.add('active');
                } else if (viewName === 'heatmap') {
                    heatmapViewWide.classList.remove('hidden');
                    showHeatmapBtnWide.classList.add('active');
                    if (lastHeatmapGridWide) {
                        const verticalAxis = verticalAxisSelectWide.value;
                        const axes = ['X', 'Y', 'Z'];
                        const horizontalAxes = axes.filter(ax => ax !== verticalAxis);
                        const hAxis1 = horizontalAxes[0];
                        const hAxis2 = horizontalAxes[1];
                        setTimeout(() => {
                            drawHeatmapCanvasWide(lastHeatmapGridWide.grid, lastHeatmapGridWide.maxCount, hAxis1, hAxis2);
                        }, 50);
                    }
                } else if (viewName === '3d-trajectory') {
                    trajectory3DViewWide.classList.remove('hidden');
                    show3DTrajectoryBtnWide.classList.add('active');
                    if (lastSampledDataWide && !is3DTrajectoryRendered) {
                        setTimeout(() => { // Use setTimeout to ensure the container is fully visible
                            draw3DTrajectory(lastSampledDataWide);
                            is3DTrajectoryRendered = true;
                        }, 50);
                    }
                }
            }

            function calculateDataCenterWide(allPoints) {
                if (allPoints.length === 0) return { x: 0, y: 0 };
                const sumX = allPoints.reduce((sum, p) => sum + p.x, 0);
                const sumY = allPoints.reduce((sum, p) => sum + p.y, 0);
                return { x: sumX / allPoints.length, y: sumY / allPoints.length };
            }

            function calculateAndDisplayCoverageWide() {
                if (!lastHeatmapGridWide || !lastHeatmapGridWide.gridInfo) {
                    alert('先にデータを解析してください。');
                    return;
                }

                const shape = document.querySelector('input[name="area-shape-wide"]:checked').value;
                const dataUnit = document.querySelector('input[name="data-unit-wide"]:checked').value;
                let size = parseFloat(areaSizeInputWide.value);
                if (isNaN(size) || size <= 0) {
                    alert('基準範囲のサイズには正の数値を入力してください。');
                    return;
                }

                let centerX, centerY;
                if (document.querySelector('input[name="center-type-wide"]:checked').value === 'custom') {
                    centerX = parseFloat(centerXInputWide.value);
                    centerY = parseFloat(centerYInputWide.value);
                    if (isNaN(centerX) || isNaN(centerY)) {
                        alert('中心座標には有効な数値を入力してください。');
                        return;
                    }
                } else {
                    const allPoints = [].concat(...Object.values(lastSampledDataWide));
                    const dataCenter = calculateDataCenterWide(allPoints);
                    centerX = dataCenter.x;
                    centerY = dataCenter.y;
                }

                if (dataUnit === 'mm') {
                    size /= 1000;
                    if (document.querySelector('input[name="center-type-wide"]:checked').value === 'custom') {
                        centerX /= 1000;
                        centerY /= 1000;
                    }
                }

                const { grid, gridInfo } = lastHeatmapGridWide;
                const { gridMinX, gridMinY, rows, cols, gridSize } = gridInfo;

                let totalCellsInArea = 0;
                let reachedCellsInArea = 0;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const cellCenterX = gridMinX + (c + 0.5) * gridSize;
                        const cellCenterY = gridMinY + (r + 0.5) * gridSize;

                        const dx = cellCenterX - centerX;
                        const dy = cellCenterY - centerY;

                        let isInArea = false;
                        if (shape === 'circle') {
                            if ((dx * dx + dy * dy) <= (size * size)) {
                                isInArea = true;
                            }
                        } else { // square
                            if (Math.abs(dx) <= size / 2 && Math.abs(dy) <= size / 2) {
                                isInArea = true;
                            }
                        }

                        if (isInArea) {
                            totalCellsInArea++;
                            if (grid[r][c] > 0) {
                                reachedCellsInArea++;
                            }
                        }
                    }
                }

                const coverage = totalCellsInArea > 0 ? (reachedCellsInArea / totalCellsInArea) * 100 : 0;
                coverageResultElWide.textContent = coverage.toFixed(2);

                // Visualize the area on the heatmap
                switchViewWide('heatmap');
                setTimeout(() => {
                    drawHeatmapCanvasWide(grid, lastHeatmapGridWide.maxCount);
                    const canvas = document.getElementById('heatmap-canvas-wide');
                    const ctx = canvas.getContext('2d');

                    const canvasWidth = canvas.width;
                    const canvasHeight = canvas.height;
                    const totalGridWidth = cols * gridSize;
                    const totalGridHeight = rows * gridSize;

                    const canvasCenterX = ((centerX - gridMinX) / totalGridWidth) * canvasWidth;
                    const canvasCenterY = canvasHeight - (((centerY - gridMinY) / totalGridHeight) * canvasHeight);

                    ctx.strokeStyle = '#0d9488';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);

                    if (shape === 'circle') {
                        const canvasRadius = (size / totalGridWidth) * canvasWidth;
                        ctx.beginPath();
                        ctx.arc(canvasCenterX, canvasCenterY, canvasRadius, 0, 2 * Math.PI);
                        ctx.stroke();
                    } else {
                        const canvasSide = (size / totalGridWidth) * canvasWidth;
                        ctx.strokeRect(canvasCenterX - canvasSide / 2, canvasCenterY - canvasSide / 2, canvasSide, canvasSide);
                    }
                    ctx.setLineDash([]);
                }, 100);
            }

            async function handleDownloadWide(event) {
                const { target, format } = event.target.dataset;
                const element = document.getElementById(target);
                if (!element) return;

                loadingDiv.classList.remove('hidden');
                loadingText.textContent = "画像を生成中...";

                await new Promise(resolve => setTimeout(resolve, 100));

                try {
                    const canvas = await html2canvas(element, { backgroundColor: '#ffffff', scale: 2 });
                    const image = canvas.toDataURL('image/png', 1.0);

                    if (format === 'png') {
                        const link = document.createElement('a');
                        link.href = image;
                        link.download = `${target}.png`;
                        link.click();
                    } else if (format === 'pdf') {
                        const { jsPDF } = window.jspdf;
                        const orientation = canvas.width > canvas.height ? 'landscape' : 'portrait';
                        const pdf = new jsPDF({ orientation, unit: 'px', format: [canvas.width, canvas.height] });
                        pdf.addImage(image, 'PNG', 0, 0, canvas.width, canvas.height);
                        pdf.save(`${target}.pdf`);
                    }
                } catch (error) {
                    console.error("Download failed:", error);
                    alert("画像の生成に失敗しました。");
                } finally {
                    loadingDiv.classList.add('hidden');
                }
            }

            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                  navigator.serviceWorker.register('./service-worker.js')
                    .then(registration => {
                      console.log('Service Worker registered: ', registration);
                    })
                    .catch(error => {
                      console.log('Service Worker registration failed: ', error);
                    });
                });
            }
        });
    </script>
</body>
</html>