<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mocap Plus | モーションキャプチャ統合解析ツール</title>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap"
        rel="stylesheet">

    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
        crossorigin="anonymous"></script>

    <style>
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            background-color: #f1f5f9;
            /* slate-100 */
        }

        .chart-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .loader,
        .download-loader {
            border: 6px solid #e5e7eb;
            border-radius: 50%;
            border-top: 6px solid #3b82f6;
            width: 50px;
            height: 50px;
            animation: spin 1.5s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .page {
            display: none;
        }

        .page.active {
            display: block;
            animation: fadeIn 0.2s ease-in-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .nav-link.active {
            background-color: #e2e8f0;
            /* slate-200 */
            color: #1e293b;
            /* slate-800 */
        }

        /* Mobile Menu Overlay */
        #mobile-menu-overlay {
            transition: opacity 0.3s ease-in-out;
        }

        #mobile-menu-content {
            transition: transform 0.3s ease-in-out;
        }

        body.mobile-menu-open {
            overflow: hidden;
        }

        #redraw-charts-btn:active {
            transform: scale(0.95);
            transition: transform 0.1s ease-in-out;
        }

        /* macOS like scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            /* slate-300 */
            border-radius: 20px;
            border: 3px solid #f1f5f9;
            /* slate-100 */
        }

        .prose-styles h3 {
            font-size: 1.125rem;
            font-weight: 600;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            padding-bottom: 0.25em;
            border-bottom: 1px solid #e2e8f0;
        }

        .prose-styles h4 {
            font-size: 1.05rem;
            font-weight: 600;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
        }

        .prose-styles p {
            font-size: 0.95rem;
            line-height: 1.6;
            margin-bottom: 1em;
        }

        .prose-styles .formula-block {
            background-color: #f8fafc;
            padding: 1rem;
            border-radius: 0.5rem;
            margin: 1.5rem 0;
            overflow-x: auto;
            text-align: center;
        }

        .tab-btn.active {
            background-color: #3b82f6;
            color: white;
        }
    </style>
</head>

<body class="antialiased text-slate-700">
    <div id="loading"
        class="hidden fixed top-0 left-0 w-full h-full bg-white/80 backdrop-blur-sm flex justify-center items-center z-50">
        <div class="text-center">
            <div class="loader mx-auto"></div>
            <p id="loading-text" class="text-slate-700 mt-4">解析中...</p>
        </div>
    </div>
    <div id="download-overlay"
        class="hidden fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm flex justify-center items-center z-50">
        <div class="text-center">
            <div class="download-loader mx-auto"></div>
            <p class="text-white mt-4">エクスポート用の画像を生成中...</p>
        </div>
    </div>

    <div class="flex min-h-screen bg-slate-100">
        <aside
            class="hidden lg:flex flex-col w-60 bg-slate-200/50 backdrop-blur-xl border-r border-slate-300/50 h-screen sticky top-0">
            <div class="flex items-center justify-center h-16 border-b border-slate-300/50 px-4">
                <img src="icons/icon-192.png" style="width: 25px; height: auto;">
                <h1 class="text-lg font-bold text-slate-800 ml-2">Mocap Plus</h1>
            </div>
            <nav class="flex-1 px-3 py-4 space-y-1">
                <a class="nav-link flex items-center px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-200 rounded-md transition-colors duration-150"
                    href="#home">
                    <svg class="h-5 w-5 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
                        stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round"
                            d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
                    </svg>
                    <span>ホーム</span>
                </a>
                <a class="nav-link flex items-center px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-200 rounded-md transition-colors duration-150"
                    href="#data-analysis">
                    <svg class="h-5 w-5 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
                        stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M3 3v18h18"></path>
                        <path stroke-linecap="round" stroke-linejoin="round" d="M18 17V9"></path>
                        <path stroke-linecap="round" stroke-linejoin="round" d="M13 17V5"></path>
                        <path stroke-linecap="round" stroke-linejoin="round" d="M8 17v-3"></path>
                    </svg>
                    <span>データ解析ツール</span>
                </a>
                <a class="nav-link flex items-center px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-200 rounded-md transition-colors duration-150"
                    href="#wide-area-analysis">
                    <svg class="h-5 w-5 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
                        stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round"
                            d="M9 20l-5.447-2.724A1 1 0 0 1 3 16.382V5.618a1 1 0 0 1 1.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0 0 21 18.382V7.618a1 1 0 0 0-.553-.894L15 4m0 13V4m0 0L9 7">
                        </path>
                    </svg>
                    <span>広域解析ツール</span>
                </a>
                <a class="nav-link flex items-center px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-200 rounded-md transition-colors duration-150"
                    href="#standard-velocity">
                    <svg class="h-5 w-5 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
                        stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15.6 3.3a10 10 0 1 0 5.7 5.7"></path>
                        <circle cx="12" cy="12" r="2"></circle>
                        <path stroke-linecap="round" stroke-linejoin="round" d="M13.4 10.6 19 5"></path>
                    </svg>
                    <span>基準速度算出ツール</span>
                </a>
                <a class="nav-link flex items-center px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-200 rounded-md transition-colors duration-150"
                    href="#distance-measurement">
                    <svg class="h-5 w-5 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
                        stroke="currentColor" stroke-width="2">
                        <rect x="3" y="8" width="18" height="8" rx="1" stroke-linecap="round" stroke-linejoin="round" />

                        <!-- 目盛り（長い） -->
                        <line x1="6" y1="12" x2="6" y2="15" stroke-linecap="round" />
                        <line x1="12" y1="12" x2="12" y2="15" stroke-linecap="round" />
                        <line x1="18" y1="12" x2="18" y2="15" stroke-linecap="round" />

                        <!-- 目盛り（短い） -->
                        <line x1="9" y1="13" x2="9" y2="15" stroke-linecap="round" />
                        <line x1="15" y1="13" x2="15" y2="15" stroke-linecap="round" />
                    </svg>
                    <span>距離測定ツール</span>
                </a>
                <a class="nav-link flex items-center px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-200 rounded-md transition-colors duration-150"
                    href="#data-trimming">
                    <svg class="h-5 w-5 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
                        stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" />
                        <path stroke-linecap="round" stroke-linejoin="round" d="M14.12 14.12 21 21M7 7l7 7" />
                        <!-- Scissors icon -->
                        <path stroke-linecap="round" stroke-linejoin="round" d="M7.5 7.5l9 9M16.5 7.5l-9 9" />
                        <!-- Replacing with a simpler scissors icon representation for clarity -->
                        <circle cx="6" cy="6" r="3" />
                        <circle cx="6" cy="18" r="3" />
                        <line x1="20" y1="4" x2="8.12" y2="15.88" />
                        <line x1="14.47" y1="14.48" x2="20" y2="20" />
                        <line x1="8.12" y1="8.12" x2="12" y2="12" />
                    </svg>
                    <span>データのトリミング</span>
                </a>
                <div class="pt-4 mt-4 border-t border-slate-300/60">
                    <a class="nav-link flex items-center px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-200 rounded-md transition-colors duration-150"
                        href="#how-to-use">
                        <svg class="h-5 w-5 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
                            stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="9" stroke-linecap="round" stroke-linejoin="round" />
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3" />
                            <path stroke-linecap="round" stroke-linejoin="round" d="M12 17h.01" />
                        </svg>
                        <span>使い方ガイド</span>
                    </a>
                    <a class="nav-link flex items-center px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-200 rounded-md transition-colors duration-150"
                        href="#algorithms">
                        <svg class="h-5 w-5 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
                            stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                        </svg>
                        <span>アルゴリズム仕様</span>
                    </a>
                    <a class="nav-link flex items-center px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-200 rounded-md transition-colors duration-150"
                        href="#about">
                        <svg class="h-5 w-5 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
                            stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <span>このツールについて</span>
                    </a>
                </div>
            </nav>
        </aside>

        <div id="main-content-area" class="flex flex-col flex-1">
            <header
                class="lg:hidden flex items-center justify-between bg-white/70 backdrop-blur-lg p-4 border-b sticky top-0 z-10">
                <button id="mobile-menu-btn" class="p-2 -ml-2">
                    <svg class="h-6 w-6 text-slate-600" xmlns="http://www.w3.org/2000/svg" fill="none"
                        viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 6h16M4 12h16M4 18h16" />
                    </svg>
                </button>
                <h1 id="mobile-title" class="text-lg font-semibold text-slate-800">ホーム</h1>
                <div class="w-6"></div>
            </header>

            <main class="p-4 sm:p-6 md:p-8">
                <div id="home" class="page">
                    <div class="max-w-5xl mx-auto">
                        <div class="bg-white p-8 rounded-xl shadow-sm border">
                            <h1 class="text-3xl font-bold text-slate-800 mb-2">Mocap Plus へようこそ</h1>
                            <p class="text-slate-600 mb-8">
                                OptiTrackの解析ソフト「Motive」からエクスポートされたcsvファイルを添付するだけで、モーションキャプチャのデータを簡単に解析することができる統合ツールです。
                            </p>
                            <div class="grid md:grid-cols-3 gap-6">
                                <a href="#data-analysis"
                                    class="nav-card group block bg-slate-50 p-6 rounded-lg border transition-all duration-300 hover:shadow-lg hover:border-blue-300 hover:-translate-y-1">
                                    <h2 class="text-xl font-semibold text-slate-800 mb-2">データ解析</h2>
                                    <p class="text-slate-600">速度、スリップ率などを計算し、グラフで可視化します。</p>
                                </a>
                                <a href="#wide-area-analysis"
                                    class="nav-card group block bg-slate-50 p-6 rounded-lg border transition-all duration-300 hover:shadow-lg hover:border-purple-300 hover:-translate-y-1">
                                    <h2 class="text-xl font-semibold text-slate-800 mb-2">広域解析</h2>
                                    <p class="text-slate-600">広範囲の移動軌跡とヒートマップを生成し、網羅率を計算します。</p>
                                </a>
                                <a href="#standard-velocity"
                                    class="nav-card group block bg-slate-50 p-6 rounded-lg border transition-all duration-300 hover:shadow-lg hover:border-green-300 hover:-translate-y-1">
                                    <h2 class="text-xl font-semibold text-slate-800 mb-2">基準速度の算出</h2>
                                    <p class="text-slate-600">車輪の回転周期から基準となる速度を計算します。</p>
                                </a>
                                <a href="#distance-measurement"
                                    class="nav-card group block bg-slate-50 p-6 rounded-lg border transition-all duration-300 hover:shadow-lg hover:border-pink-300 hover:-translate-y-1">
                                    <h2 class="text-xl font-semibold text-slate-800 mb-2">距離測定</h2>
                                    <p class="text-slate-600">マーカー間や剛体間の平均位置からの距離を測定します。</p>
                                </a>
                                <a href="#data-trimming"
                                    class="nav-card group block bg-slate-50 p-6 rounded-lg border transition-all duration-300 hover:shadow-lg hover:border-gray-300 hover:-translate-y-1">
                                    <h2 class="text-xl font-semibold text-slate-800 mb-2">データのトリミング</h2>
                                    <p class="text-slate-600">データの範囲を選択し、必要な区間だけを切り出して出力します。</p>
                                </a>
                            </div>
                        </div>

                        <div class="mt-10">
                            <h2 class="text-2xl font-bold text-slate-800 mb-4">お知らせ</h2>
                            <div class="space-y-4">
                                <!-- MODIFICATION: Added new development log -->
                                <div class="bg-white p-5 rounded-xl shadow-sm border">
                                    <p class="text-sm text-slate-500">2025/12/16</p>
                                    <p class="font-semibold text-slate-800 mt-1">「距離測定ツール」を追加</p>
                                    <p class="text-sm text-slate-600 mt-2">点Aと点Bの平均座標を計算し、ユークリッド距離を測定する機能を追加しました。</p>
                                </div>
                                <div class="bg-white p-5 rounded-xl shadow-sm border">
                                    <p class="text-sm text-slate-500">2025/10/20</p>
                                    <p class="font-semibold text-slate-800 mt-1">「広域解析ツール」を追加</p>
                                    <p class="text-sm text-slate-600 mt-2">
                                        広範囲の移動軌跡や滞在頻度を可視化するヒートマップ機能、指定範囲に対する網羅率を計算する機能を追加しました。</p>
                                </div>
                                <div class="bg-white p-5 rounded-xl shadow-sm border">
                                    <p class="text-sm text-slate-500">2025/08/07</p>
                                    <p class="font-semibold text-slate-800 mt-1">機能とUIを改善</p>
                                    <p class="text-sm text-slate-600 mt-2">
                                        データ解析ツールでファイルを後からでも追加できるよう修正。スクロールしたときにメニューが固定されるようUIを改善。</p>
                                </div>
                                <div class="bg-white p-5 rounded-xl shadow-sm border">
                                    <p class="text-sm text-slate-500">2025/08/05</p>
                                    <p class="font-semibold text-slate-800 mt-1">機能改善とアルゴリズム修正</p>
                                    <p class="text-sm text-slate-600 mt-2">
                                        ローパスフィルタに「ガウシアンフィルタ」を追加し、ユーザが選択できるようにしました。また、往復運動があるデータでも正確に動作区間を検出できるよう、アルゴリズムを修正しました。
                                    </p>
                                </div>
                                <div class="bg-white p-5 rounded-xl shadow-sm border">
                                    <p class="text-sm text-slate-500">2025/07/04</p>
                                    <p class="font-semibold text-slate-800 mt-1">分散の表示とローパスフィルタの追加</p>
                                    <p class="text-sm text-slate-600 mt-2">
                                        データ解析ツールに分散表示機能と、ユーザが任意に設定できるローパスフィルタ機能を追加しました。</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="page" id="data-analysis">
                    <div class="max-w-7xl mx-auto space-y-8">
                        <header class="text-center">
                            <h1 class="text-3xl font-bold text-slate-800">データ解析ツール</h1>
                            <p class="text-slate-500 mt-2">CSVファイルをアップロードして、剛体の運動を解析します。</p>
                        </header>

                        <section class="bg-white p-6 rounded-lg shadow-sm border">
                            <h2 class="text-xl font-semibold text-center mb-6">1. データ入力</h2>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-6">
                                <div>
                                    <label for="csv-files" class="block text-sm font-medium text-slate-700 mb-2">①
                                        CSVファイルを追加</label>
                                    <div class="flex items-center space-x-2">
                                        <input type="file" id="csv-files" multiple accept=".csv" class="hidden">
                                        <label for="csv-files"
                                            class="w-full cursor-pointer bg-slate-100 hover:bg-slate-200 text-slate-700 font-semibold py-2 px-4 rounded-md text-sm text-center">ファイルを追加</label>
                                        <button id="clear-files-btn"
                                            class="flex-shrink-0 bg-slate-200 hover:bg-slate-300 text-slate-700 font-semibold py-2 px-3 rounded-md text-xs shadow-sm">クリア</button>
                                    </div>
                                    <div id="file-list" class="mt-4 space-y-2"></div>
                                    <div
                                        class="mt-4 p-3 bg-yellow-50 border-l-4 border-yellow-400 text-yellow-800 text-xs rounded-r-lg">
                                        <strong>注意:</strong>
                                        1分以上のデータは処理に時間がかかることがあります。また、直線運動以外の複雑な動作では、動作区間が誤って検出される可能性があります。
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-slate-700 mb-2">② 元データの単位</label>
                                    <div class="flex items-center space-x-4 mt-2">
                                        <label class="flex items-center">
                                            <input type="radio" name="data-unit" value="mm" class="form-radio" checked>
                                            <span class="ml-2 text-sm">mm</span>
                                        </label>
                                        <label class="flex items-center">
                                            <input type="radio" name="data-unit" value="m" class="form-radio">
                                            <span class="ml-2 text-sm">m</span>
                                        </label>
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-slate-700 mb-2">③④ 方向の定義</label>
                                    <div class="flex space-x-4">
                                        <div class="flex-1">
                                            <label for="travel-axis"
                                                class="block text-xs font-medium text-slate-500">進行方向</label>
                                            <select id="travel-axis"
                                                class="mt-1 w-full bg-white border-slate-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 text-sm">
                                                <option value="X">X</option>
                                                <option value="Y">Y</option>
                                                <option value="Z" selected>Z</option>
                                            </select>
                                        </div>
                                        <div class="flex-1">
                                            <label for="vertical-axis"
                                                class="block text-xs font-medium text-slate-500">鉛直方向</label>
                                            <select id="vertical-axis"
                                                class="mt-1 w-full bg-white border-slate-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 text-sm">
                                                <option value="X">X</option>
                                                <option value="Y" selected>Y</option>
                                                <option value="Z">Z</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                                <div class="md:col-span-2">
                                    <details class="bg-slate-50/70 border rounded-md p-4">
                                        <summary class="font-medium text-slate-700 text-sm">動作検出の高度な設定</summary>
                                        <div class="mt-4 pt-4 border-t">
                                            <label for="motion-threshold-multiplier"
                                                class="block text-sm font-medium text-slate-600">静止範囲の倍率</label>
                                            <input type="number" id="motion-threshold-multiplier" value="0.001"
                                                step="0.001"
                                                class="mt-1 block w-full rounded-md shadow-sm p-2 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500">
                                            <p class="text-xs text-slate-500 mt-1">
                                                データ全体の振れ幅(最大値-最小値)にこの倍率を掛けた値を、静止範囲のマージンとして使用します。</p>
                                        </div>
                                    </details>
                                </div>
                            </div>
                        </section>

                        <section id="rigidbody-selection-section"
                            class="bg-white p-6 rounded-lg shadow-sm border hidden">
                            <h2 class="text-xl font-semibold text-center mb-6">2. 解析対象の剛体を選択</h2>
                            <div id="rigidbody-list" class="space-y-4"></div>
                            <div class="mt-6 text-center">
                                <button id="start-analysis-btn"
                                    class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-8 rounded-md shadow-sm transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                                    解析開始
                                </button>
                            </div>
                        </section>

                        <div id="results-section" class="hidden space-y-8">
                            <section class="bg-white p-6 rounded-lg shadow-sm border">
                                <h2 class="text-xl font-semibold text-center mb-6">3. 解析結果</h2>
                                <div id="avg-velo-filter-section" class="mb-6 p-4 bg-slate-50/70 rounded-md border">
                                    <h4 class="font-medium text-slate-700 mb-3 text-sm">平均速度の計算設定</h4>
                                    <div class="flex items-center space-x-3"><input type="checkbox"
                                            id="filter-velocity-checkbox"
                                            class="h-4 w-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500"><label
                                            for="filter-velocity-checkbox"
                                            class="text-sm font-medium text-slate-700">微小な速度を計算から除外する</label></div>
                                    <div id="filter-range-inputs" class="hidden mt-3 flex items-center space-x-4 pl-7">
                                        <div><label for="filter-lower-bound"
                                                class="block text-xs font-medium text-slate-600">下限値 (m/s)</label><input
                                                type="number" id="filter-lower-bound" value="-0.01" step="0.01"
                                                class="mt-1 block w-32 rounded-md shadow-sm p-1.5 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500">
                                        </div>
                                        <div><label for="filter-upper-bound"
                                                class="block text-xs font-medium text-slate-600">上限値 (m/s)</label><input
                                                type="number" id="filter-upper-bound" value="0.01" step="0.01"
                                                class="mt-1 block w-32 rounded-md shadow-sm p-1.5 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500">
                                        </div>
                                        <div class="pt-5"><button id="recalculate-avg-btn"
                                                class="bg-slate-600 hover:bg-slate-700 text-white font-semibold py-1 px-3 rounded-md text-xs shadow-sm">再計算</button>
                                        </div>
                                    </div>
                                </div>
                                <div id="average-velocities" class="mb-6"></div>
                                <p class="text-xs text-slate-500 mb-4">※平均速度及び平均スリップ率は、静止範囲として設定している倍率により大きく変動します。</p>
                                <button id="download-velocity-csv"
                                    class="bg-slate-600 hover:bg-slate-700 text-white font-semibold py-2 px-4 rounded-md shadow-sm text-sm">微小速度データをCSVでダウンロード</button>
                            </section>

                            <section class="bg-white p-6 rounded-lg shadow-sm border">
                                <div class="flex flex-wrap justify-between items-center mb-6 text-center border-b pb-4">
                                    <h2 class="text-xl font-semibold w-full sm:w-auto text-center sm:text-left">4. グラフ
                                    </h2>
                                    <div class="flex items-center space-x-2 mt-4 sm:mt-0 mx-auto sm:mx-0">
                                        <span class="text-sm text-slate-600">スタイル:</span>
                                        <button id="style-casual"
                                            class="style-btn bg-blue-600 text-white px-3 py-1 rounded-l-md text-sm font-medium">カジュアル</button>
                                        <button id="style-formal"
                                            class="style-btn bg-slate-200 text-slate-700 px-3 py-1 rounded-r-md text-sm font-medium">フォーマル</button>
                                    </div>
                                </div>
                                <div id="graph-customization" class="mt-6">
                                    <div class="mb-8 p-4 bg-slate-50/70 rounded-md border">
                                        <h4 class="font-medium text-slate-700 mb-3 text-sm">グラフ描画設定</h4>
                                        <div class="flex items-center flex-wrap gap-x-6 gap-y-3">
                                            <div class="flex items-center space-x-2">
                                                <label for="lowpass-filter-type"
                                                    class="text-sm font-medium text-slate-700">ローパスフィルタ:</label>
                                                <select id="lowpass-filter-type"
                                                    class="block w-36 rounded-md shadow-sm p-1.5 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500">
                                                    <option value="none" selected>適用しない</option>
                                                    <option value="moving-average">移動平均</option>
                                                    <option value="gaussian">ガウシアン</option>
                                                </select>
                                            </div>
                                            <div class="flex items-center space-x-2">
                                                <label id="lowpass-strength-label" for="lowpass-strength"
                                                    class="text-sm font-medium text-slate-700">強度:</label>
                                                <input type="number" id="lowpass-strength" value="10" step="0.1"
                                                    class="block w-20 rounded-md shadow-sm p-1.5 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                                                    disabled>
                                            </div>
                                            <button id="redraw-charts-btn"
                                                class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md shadow-sm transition-all duration-150">再描画</button>
                                        </div>
                                        <p id="filter-description" class="text-xs text-slate-500 mt-2">
                                            フィルタを選択すると、強度を指定できます。</p>
                                    </div>
                                    <div class="mb-8 p-4 bg-slate-50/70 rounded-md border">
                                        <h4 class="font-medium text-slate-700 mb-3 text-sm">エクスポート設定</h4>
                                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                            <div><label for="export-width"
                                                    class="block text-sm font-medium text-slate-600">画像の幅
                                                    (px)</label><input type="number" id="export-width" value="800"
                                                    step="100"
                                                    class="mt-1 block w-full rounded-md shadow-sm p-2 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500">
                                            </div>
                                            <div><label for="export-height"
                                                    class="block text-sm font-medium text-slate-600">画像の高さ
                                                    (px)</label><input type="number" id="export-height" value="450"
                                                    step="100"
                                                    class="mt-1 block w-full rounded-md shadow-sm p-2 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500">
                                            </div>
                                        </div>
                                    </div>
                                    <h3 class="text-lg font-semibold mb-4 text-slate-700">グラフのラベル編集</h3>
                                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
                                        <div class="space-y-2 p-3 border rounded-md bg-slate-50/50">
                                            <h4 class="font-semibold text-center text-slate-700 text-sm">速度 vs 距離</h4>
                                            <div><label class="text-xs font-medium text-slate-600">タイトル</label><input
                                                    type="text" id="v-chart-title" data-chart-id="velocity-chart"
                                                    data-label-type="title"
                                                    class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300">
                                            </div>
                                            <div><label class="text-xs font-medium text-slate-600">X軸</label><input
                                                    type="text" id="v-chart-xlabel" data-chart-id="velocity-chart"
                                                    data-label-type="x"
                                                    class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300">
                                            </div>
                                            <div><label class="text-xs font-medium text-slate-600">Y軸</label><input
                                                    type="text" id="v-chart-ylabel" data-chart-id="velocity-chart"
                                                    data-label-type="y"
                                                    class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300">
                                            </div>
                                        </div>
                                        <div class="space-y-2 p-3 border rounded-md bg-slate-50/50">
                                            <h4 class="font-semibold text-center text-slate-700 text-sm">スリップ率 vs 距離
                                            </h4>
                                            <div><label class="text-xs font-medium text-slate-600">タイトル</label><input
                                                    type="text" id="s-chart-title" data-chart-id="slip-chart"
                                                    data-label-type="title"
                                                    class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300">
                                            </div>
                                            <div><label class="text-xs font-medium text-slate-600">X軸</label><input
                                                    type="text" id="s-chart-xlabel" data-chart-id="slip-chart"
                                                    data-label-type="x"
                                                    class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300">
                                            </div>
                                            <div><label class="text-xs font-medium text-slate-600">Y軸</label><input
                                                    type="text" id="s-chart-ylabel" data-chart-id="slip-chart"
                                                    data-label-type="y"
                                                    class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300">
                                            </div>
                                        </div>
                                        <div class="space-y-2 p-3 border rounded-md bg-slate-50/50">
                                            <h4 class="font-semibold text-center text-slate-700 text-sm">鉛直変位 vs 距離</h4>
                                            <div><label class="text-xs font-medium text-slate-600">タイトル</label><input
                                                    type="text" id="z-chart-title" data-chart-id="vertical-chart"
                                                    data-label-type="title"
                                                    class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300">
                                            </div>
                                            <div><label class="text-xs font-medium text-slate-600">X軸</label><input
                                                    type="text" id="z-chart-xlabel" data-chart-id="vertical-chart"
                                                    data-label-type="x"
                                                    class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300">
                                            </div>
                                            <div><label class="text-xs font-medium text-slate-600">Y軸</label><input
                                                    type="text" id="z-chart-ylabel" data-chart-id="vertical-chart"
                                                    data-label-type="y"
                                                    class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300">
                                            </div>
                                        </div>
                                        <div class="space-y-2 p-3 border rounded-md bg-slate-50/50">
                                            <h4 class="font-semibold text-center text-slate-700 text-sm">平面移動軌跡</h4>
                                            <div><label class="text-xs font-medium text-slate-600">タイトル</label><input
                                                    type="text" id="t-chart-title" data-chart-id="trajectory-chart"
                                                    data-label-type="title"
                                                    class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300">
                                            </div>
                                            <div><label class="text-xs font-medium text-slate-600">X軸</label><input
                                                    type="text" id="t-chart-xlabel" data-chart-id="trajectory-chart"
                                                    data-label-type="x"
                                                    class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300">
                                            </div>
                                            <div><label class="text-xs font-medium text-slate-600">Y軸</label><input
                                                    type="text" id="t-chart-ylabel" data-chart-id="trajectory-chart"
                                                    data-label-type="y"
                                                    class="chart-label-input mt-1 w-full rounded-md p-1.5 text-sm border-slate-300">
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="grid grid-cols-1 lg:grid-cols-2 gap-x-8 gap-y-12 mt-8">
                                    <div>
                                        <div class="w-full aspect-video bg-white p-2 border rounded-lg shadow-sm">
                                            <div class="chart-container"><canvas id="velocity-chart"></canvas></div>
                                        </div>
                                        <div class="text-center mt-3 flex justify-center items-center space-x-2">
                                            <button
                                                class="zoom-btn bg-slate-200 hover:bg-slate-300 text-slate-600 h-8 w-8 flex items-center justify-center rounded-md transition-colors"
                                                data-chart-id="velocity-chart" title="拡大表示">
                                                <svg class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none"
                                                    viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                                                    <path stroke-linecap="round" stroke-linejoin="round"
                                                        d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7" />
                                                </svg>
                                            </button>
                                            <button
                                                class="download-btn bg-slate-600 hover:bg-slate-700 text-white text-xs h-8 px-3 flex items-center justify-center rounded-md"
                                                data-chart-id="velocity-chart" data-format="png">PNG</button>
                                            <button
                                                class="download-btn bg-slate-600 hover:bg-slate-700 text-white text-xs h-8 px-3 flex items-center justify-center rounded-md"
                                                data-chart-id="velocity-chart" data-format="pdf">PDF</button>
                                        </div>
                                    </div>
                                    <div>
                                        <div class="w-full aspect-video bg-white p-2 border rounded-lg shadow-sm">
                                            <div class="chart-container"><canvas id="slip-chart"></canvas></div>
                                        </div>
                                        <div class="text-center mt-3 flex justify-center items-center space-x-2">
                                            <button
                                                class="zoom-btn bg-slate-200 hover:bg-slate-300 text-slate-600 h-8 w-8 flex items-center justify-center rounded-md transition-colors"
                                                data-chart-id="slip-chart" title="拡大表示">
                                                <svg class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none"
                                                    viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                                                    <path stroke-linecap="round" stroke-linejoin="round"
                                                        d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7" />
                                                </svg>
                                            </button>
                                            <button
                                                class="download-btn bg-slate-600 hover:bg-slate-700 text-white text-xs h-8 px-3 flex items-center justify-center rounded-md"
                                                data-chart-id="slip-chart" data-format="png">PNG</button>
                                            <button
                                                class="download-btn bg-slate-600 hover:bg-slate-700 text-white text-xs h-8 px-3 flex items-center justify-center rounded-md"
                                                data-chart-id="slip-chart" data-format="pdf">PDF</button>
                                        </div>
                                    </div>
                                    <div>
                                        <div class="w-full aspect-video bg-white p-2 border rounded-lg shadow-sm">
                                            <div class="chart-container"><canvas id="vertical-chart"></canvas></div>
                                        </div>
                                        <div class="text-center mt-3 flex justify-center items-center space-x-2">
                                            <button
                                                class="zoom-btn bg-slate-200 hover:bg-slate-300 text-slate-600 h-8 w-8 flex items-center justify-center rounded-md transition-colors"
                                                data-chart-id="vertical-chart" title="拡大表示">
                                                <svg class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none"
                                                    viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                                                    <path stroke-linecap="round" stroke-linejoin="round"
                                                        d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7" />
                                                </svg>
                                            </button>
                                            <button
                                                class="download-btn bg-slate-600 hover:bg-slate-700 text-white text-xs h-8 px-3 flex items-center justify-center rounded-md"
                                                data-chart-id="vertical-chart" data-format="png">PNG</button>
                                            <button
                                                class="download-btn bg-slate-600 hover:bg-slate-700 text-white text-xs h-8 px-3 flex items-center justify-center rounded-md"
                                                data-chart-id="vertical-chart" data-format="pdf">PDF</button>
                                        </div>
                                    </div>
                                    <div>
                                        <div class="w-full aspect-video bg-white p-2 border rounded-lg shadow-sm">
                                            <div class="chart-container"><canvas id="trajectory-chart"></canvas></div>
                                        </div>
                                        <div class="text-center mt-3 flex justify-center items-center space-x-2">
                                            <button
                                                class="zoom-btn bg-slate-200 hover:bg-slate-300 text-slate-600 h-8 w-8 flex items-center justify-center rounded-md transition-colors"
                                                data-chart-id="trajectory-chart" title="拡大表示">
                                                <svg class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none"
                                                    viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                                                    <path stroke-linecap="round" stroke-linejoin="round"
                                                        d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7" />
                                                </svg>
                                            </button>
                                            <button
                                                class="download-btn bg-slate-600 hover:bg-slate-700 text-white text-xs h-8 px-3 flex items-center justify-center rounded-md"
                                                data-chart-id="trajectory-chart" data-format="png">PNG</button>
                                            <button
                                                class="download-btn bg-slate-600 hover:bg-slate-700 text-white text-xs h-8 px-3 flex items-center justify-center rounded-md"
                                                data-chart-id="trajectory-chart" data-format="pdf">PDF</button>
                                        </div>
                                    </div>
                                </div>
                            </section>
                        </div>
                    </div>
                </div>

                <div class="page" id="wide-area-analysis">
                    <div class="max-w-7xl mx-auto space-y-8">
                        <header class="text-center">
                            <h1 class="text-3xl font-bold text-slate-800">広域解析ツール</h1>
                            <p class="text-slate-500 mt-2">CSVファイルをアップロードして、広範囲の移動軌跡や滞在傾向を可視化します。</p>
                        </header>

                        <section id="settings-card-wide" class="bg-white p-6 rounded-lg shadow-sm border">
                            <h2 class="text-xl font-semibold text-center mb-6">1. 設定</h2>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                                <div>
                                    <label for="csv-files-wide" class="block text-sm font-medium text-slate-700 mb-2">①
                                        CSVファイルを追加</label>
                                    <div class="flex items-center space-x-2">
                                        <input type="file" id="csv-files-wide" multiple accept=".csv" class="hidden">
                                        <label for="csv-files-wide"
                                            class="w-full cursor-pointer bg-slate-100 hover:bg-slate-200 text-slate-700 font-semibold py-2 px-4 rounded-md text-sm text-center">ファイルを追加</label>
                                        <button id="clear-files-btn-wide"
                                            class="flex-shrink-0 bg-slate-200 hover:bg-slate-300 text-slate-700 font-semibold py-2 px-3 rounded-md text-xs shadow-sm">クリア</button>
                                    </div>
                                    <div id="file-list-area-wide" class="mt-4 space-y-2"></div>
                                </div>
                                <div class="space-y-4">
                                    <div>
                                        <label class="block text-sm font-medium text-slate-700 mb-2">② 元データの単位</label>
                                        <div class="flex items-center space-x-4 mt-2">
                                            <label class="flex items-center"><input type="radio" name="data-unit-wide"
                                                    value="mm" class="form-radio" checked> <span
                                                    class="ml-2 text-sm">mm</span></label>
                                            <label class="flex items-center"><input type="radio" name="data-unit-wide"
                                                    value="m" class="form-radio"> <span
                                                    class="ml-2 text-sm">m</span></label>
                                        </div>
                                    </div>
                                    <div>
                                        <label for="sampling-rate-wide"
                                            class="block text-sm font-medium text-slate-700 mb-2">③ データ取得間隔 (秒)</label>
                                        <input type="number" id="sampling-rate-wide" value="1.0" step="0.1" min="0.01"
                                            class="block w-full rounded-md shadow-sm p-2 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500">
                                    </div>
                                    <div>
                                        <label for="heatmap-grid-size-wide"
                                            class="block text-sm font-medium text-slate-700 mb-2">④ ヒートマップのマス目のサイズ
                                            (<span class="unit-label">mm</span>)</label>
                                        <input type="number" id="heatmap-grid-size-wide" value="500" step="100"
                                            class="block w-full rounded-md shadow-sm p-2 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500">
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium text-slate-700 mb-2">⑤ 方向の定義</label>
                                        <div class="flex space-x-4">
                                            <div class="flex-1">
                                                <label for="vertical-axis-wide"
                                                    class="block text-xs font-medium text-slate-500">鉛直方向の軸</label>
                                                <select id="vertical-axis-wide"
                                                    class="mt-1 w-full bg-white border-slate-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 text-sm">
                                                    <option value="X">X</option>
                                                    <option value="Y" selected>Y</option>
                                                    <option value="Z">Z</option>
                                                </select>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div id="rigidbody-selection-area-wide" class="mt-6 hidden">
                                <label class="block text-sm font-medium text-slate-700 mb-2">⑤ 解析対象の剛体を選択</label>
                                <div id="rigidbody-list-container-wide"
                                    class="space-y-4 p-4 border rounded-md bg-slate-50/70 max-h-60 overflow-y-auto">
                                </div>
                            </div>
                            <div class="text-center mt-8">
                                <button id="analyze-btn-wide"
                                    class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2.5 px-8 rounded-md shadow-sm transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:bg-slate-400 disabled:cursor-not-allowed disabled:transform-none"
                                    disabled>
                                    解析開始
                                </button>
                            </div>
                        </section>

                        <section id="results-card-wide" class="bg-white p-6 rounded-lg shadow-sm border hidden">
                            <h2 class="text-xl font-semibold text-center mb-4">2. 解析結果</h2>
                            <div class="flex justify-center mb-6 border-b">
                                <button id="show-trajectory-btn-wide"
                                    class="tab-btn active font-medium py-2 px-6 rounded-t-md transition-colors">軌跡</button>
                                <button id="show-heatmap-btn-wide"
                                    class="tab-btn font-medium py-2 px-6 rounded-t-md transition-colors">ヒートマップ</button>
                                <button id="show-3d-trajectory-btn-wide"
                                    class="tab-btn font-medium py-2 px-6 rounded-t-md transition-colors">3D軌跡</button>
                            </div>

                            <div id="trajectory-view-wide">
                                <div class="w-full max-w-2xl mx-auto">
                                    <div class="flex justify-end items-center mb-2">
                                        <label for="height-info-checkbox-wide" class="flex items-center cursor-pointer">
                                            <input type="checkbox" id="height-info-checkbox-wide"
                                                class="form-checkbox h-4 w-4 text-blue-600 rounded border-slate-300 focus:ring-blue-500">
                                            <span class="ml-2 text-sm text-slate-700">高さ情報を含む</span>
                                        </label>
                                    </div>
                                    <div class="aspect-square bg-white p-2 relative border rounded-lg shadow-sm">
                                        <div class="chart-container">
                                            <canvas id="trajectory-chart-wide"></canvas>
                                            <div id="height-legend-wide"
                                                class="hidden absolute top-2 right-2 bg-white/80 backdrop-blur-sm p-2 rounded-md border text-xs">
                                                <div class="font-semibold text-center text-slate-700 mb-1">高さ (m)</div>
                                                <div class="flex items-center space-x-2">
                                                    <span id="height-legend-min-wide">0.0</span>
                                                    <div id="height-legend-gradient-wide"
                                                        class="w-20 h-3 rounded-sm border"></div>
                                                    <span id="height-legend-max-wide">0.0</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="text-center mt-4 flex justify-center items-center space-x-2">
                                    <button
                                        class="download-btn-wide bg-slate-600 hover:bg-slate-700 text-white text-sm h-9 px-4 flex items-center justify-center rounded-md"
                                        data-target="trajectory-chart-wide" data-format="png">PNGで保存</button>
                                    <button
                                        class="download-btn-wide bg-slate-600 hover:bg-slate-700 text-white text-sm h-9 px-4 flex items-center justify-center rounded-md"
                                        data-target="trajectory-chart-wide" data-format="pdf">PDFで保存</button>
                                </div>
                            </div>

                            <div id="heatmap-view-wide" class="hidden">
                                <div id="heatmap-container-wide"
                                    class="w-full max-w-2xl mx-auto aspect-square relative bg-slate-50 border rounded-lg shadow-sm">
                                    <canvas id="heatmap-canvas-wide"></canvas>
                                    <div id="heatmap-tooltip"
                                        class="hidden absolute bg-black/70 text-white text-xs rounded-md px-2 py-1 pointer-events-none shadow-lg">
                                    </div>
                                </div>
                                <div id="heatmap-legend-wide"
                                    class="flex justify-end items-center mt-2 max-w-2xl mx-auto space-x-2 text-sm">
                                    <span>Min</span>
                                    <div class="w-32 h-4 rounded-md"
                                        style="background: linear-gradient(to right, rgb(0, 0, 255), rgb(0, 255, 255), rgb(0, 255, 0), rgb(255, 255, 0), rgb(255, 0, 0));">
                                    </div>
                                    <span>Max (<span id="heatmap-max-value-wide">0</span>)</span>
                                </div>
                                <div class="text-center mt-4 flex justify-center items-center space-x-2">
                                    <button
                                        class="download-btn-wide bg-slate-600 hover:bg-slate-700 text-white text-sm h-9 px-4 flex items-center justify-center rounded-md"
                                        data-target="heatmap-canvas-wide" data-format="png">PNGで保存</button>
                                    <button
                                        class="download-btn-wide bg-slate-600 hover:bg-slate-700 text-white text-sm h-9 px-4 flex items-center justify-center rounded-md"
                                        data-target="heatmap-canvas-wide" data-format="pdf">PDFで保存</button>
                                </div>
                            </div>

                            <div id="trajectory-3d-view-wide" class="hidden">
                                <div id="trajectory-3d-container-wide"
                                    class="w-full max-w-2xl mx-auto aspect-square relative bg-slate-50 border rounded-lg shadow-sm">
                                </div>
                            </div>
                            <p id="coordinate-unit-note" class="text-xs text-slate-500 mt-4 text-center">※
                                座標は正規化せず、元データの値をメートル単位に変換して使用しています。</p>

                            <div id="coverage-section-wide" class="mt-8 pt-6 border-t">
                                <h3 class="text-lg font-semibold text-center mb-4 text-slate-800">網羅率の計算</h3>
                                <div
                                    class="max-w-2xl mx-auto grid grid-cols-1 md:grid-cols-2 gap-6 p-4 bg-slate-50 border rounded-lg">
                                    <div class="space-y-4">
                                        <div>
                                            <label class="block text-sm font-medium text-slate-700">基準範囲の形状</label>
                                            <div class="mt-2 flex gap-4"><label class="flex items-center"><input
                                                        type="radio" name="area-shape-wide" value="circle"
                                                        class="form-radio" checked> <span
                                                        class="ml-2">円</span></label><label
                                                    class="flex items-center"><input type="radio" name="area-shape-wide"
                                                        value="square" class="form-radio"> <span
                                                        class="ml-2">正方形</span></label></div>
                                        </div>
                                        <div>
                                            <label for="area-size-wide"
                                                class="block text-sm font-medium text-slate-700"><span
                                                    id="area-size-label-wide">半径</span> (<span
                                                    class="unit-label">mm</span>)</label>
                                            <input type="number" id="area-size-wide" value="2000" step="100"
                                                class="mt-1 block w-full rounded-md shadow-sm p-2 text-sm border-slate-300">
                                        </div>
                                        <div>
                                            <label class="block text-sm font-medium text-slate-700">中心座標</label>
                                            <div class="mt-2 flex gap-4"><label class="flex items-center"><input
                                                        type="radio" name="center-type-wide" value="data"
                                                        class="form-radio" checked> <span
                                                        class="ml-2">データの中心</span></label><label
                                                    class="flex items-center"><input type="radio"
                                                        name="center-type-wide" value="custom" class="form-radio"> <span
                                                        class="ml-2">座標指定</span></label></div>
                                        </div>
                                        <div id="custom-center-inputs-wide" class="hidden space-y-2">
                                            <div class="flex items-center gap-2"><label for="center-x-wide"
                                                    class="text-sm" id="center-x-label-wide">X:</label><input
                                                    type="number" id="center-x-wide" value="0" step="0.1"
                                                    class="block w-full rounded-md shadow-sm p-2 text-sm border-slate-300"><label
                                                    for="center-y-wide" class="text-sm"
                                                    id="center-y-label-wide">Y:</label><input type="number"
                                                    id="center-y-wide" value="0" step="0.1"
                                                    class="block w-full rounded-md shadow-sm p-2 text-sm border-slate-300">
                                            </div>
                                        </div>
                                    </div>
                                    <div
                                        class="flex flex-col items-center justify-center bg-white p-4 rounded-md border">
                                        <button id="calculate-coverage-btn-wide"
                                            class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-2.5 px-6 rounded-md shadow-sm">計算実行</button>
                                        <div class="mt-4 text-center">
                                            <p class="text-sm text-slate-600">網羅率</p>
                                            <p class="text-3xl font-bold text-slate-800 my-1"><span
                                                    id="coverage-result-wide">--</span> %</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </section>
                    </div>
                </div>


                <div class="page" id="standard-velocity">
                    <div class="max-w-3xl mx-auto space-y-8">
                        <header class="text-center">
                            <h1 class="text-3xl font-bold text-slate-800">基準速度算出ツール</h1>
                            <p class="text-slate-500 mt-2">モーションキャプチャのCSVデータから車輪の基準速度を計算します。</p>
                        </header>

                        <section id="step-1-file-upload-std" class="bg-white p-6 rounded-lg shadow-sm border">
                            <h2 class="text-xl font-semibold text-center mb-6">1. データ入力</h2>
                            <div class="mt-4 flex flex-col items-center gap-3">
                                <label for="csv-file-input-std"
                                    class="cursor-pointer bg-slate-100 hover:bg-slate-200 text-slate-800 font-semibold py-2 px-5 border border-slate-300 rounded-md shadow-sm transition-colors">
                                    ファイルを選択
                                </label>
                                <input type="file" id="csv-file-input-std" class="hidden" accept=".csv">
                                <p id="file-name-display-std" class="text-sm text-slate-500 mt-2">ファイルが選択されていません</p>
                            </div>
                        </section>

                        <div id="loading-indicator-std" class="hidden flex-col items-center justify-center py-10">
                            <div class="loader"></div>
                            <p class="text-slate-600 mt-4">ファイルを解析中...</p>
                        </div>

                        <section id="step-2-parameters-std" class="hidden bg-white p-6 rounded-lg shadow-sm border">
                            <h2 class="text-xl font-semibold text-center mb-6">2. パラメータ設定</h2>
                            <div class="mt-4 space-y-5 max-w-sm mx-auto">
                                <div>
                                    <label class="block text-sm font-medium text-slate-700">① 回転データの形式</label>
                                    <div class="flex items-center space-x-4 mt-2">
                                        <label class="flex items-center">
                                            <input type="radio" name="rotation-format-std" value="euler"
                                                class="form-radio text-blue-600 focus:ring-blue-500" checked>
                                            <span class="ml-2 text-sm text-slate-700">オイラー角 (度数法)</span>
                                        </label>
                                        <label class="flex items-center">
                                            <input type="radio" name="rotation-format-std" value="quaternion"
                                                class="form-radio text-blue-600 focus:ring-blue-500">
                                            <span class="ml-2 text-sm text-slate-700">クウォータニオン</span>
                                        </label>
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-slate-700">② 車輪の剛体を選択</label>
                                    <div id="rigidbody-radio-container-std"
                                        class="mt-2 space-y-2 max-h-40 overflow-y-auto border p-3 rounded-md bg-slate-50/70">
                                    </div>
                                </div>
                                <div>
                                    <label for="radius-input-std" class="block text-sm font-medium text-slate-700">③
                                        車輪の半径 (cm)</label>
                                    <input type="number" id="radius-input-std" value="10" step="1"
                                        class="mt-1 block w-full border-slate-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-1 focus:ring-blue-500 text-sm">
                                </div>
                                <div>
                                    <label for="axis-select-std" class="block text-sm font-medium text-slate-700">④
                                        車輪の回転軸</label>
                                    <select id="axis-select-std"
                                        class="mt-1 block w-full bg-white border-slate-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-1 focus:ring-blue-500 text-sm">
                                        <option value="X">X軸</option>
                                        <option value="Y" selected>Y軸</option>
                                        <option value="Z">Z軸</option>
                                    </select>
                                </div>
                            </div>
                            <div class="text-center mt-8">
                                <button id="calculate-btn-std"
                                    class="w-full max-w-sm bg-green-600 hover:bg-green-700 text-white font-semibold py-2.5 px-6 rounded-md shadow-sm transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500">
                                    計算開始
                                </button>
                            </div>
                        </section>

                        <section id="step-3-results-std" class="hidden bg-white p-6 rounded-lg shadow-sm border">
                            <h2 class="text-xl font-semibold text-center mb-6">3. 計算結果</h2>
                            <div id="result-display-std"
                                class="hidden mt-6 p-6 bg-slate-50/70 rounded-lg text-center border">
                                <p class="text-sm text-slate-600">算出された基準速度 (v)</p>
                                <p class="text-4xl font-bold text-slate-800 my-2 tracking-tight">
                                    <span id="result-value-std">0.00000000</span> m/s
                                </p>
                                <button id="copy-btn-std"
                                    class="mt-4 bg-slate-200 hover:bg-slate-300 text-slate-700 font-semibold py-1.5 px-4 rounded-md text-sm transition-colors"
                                    data-copy-value="">
                                    結果をコピー
                                </button>
                            </div>
                            <div id="error-display-std"
                                class="hidden mt-6 p-4 bg-red-50 text-red-800 border-l-4 border-red-400 rounded-md">
                            </div>
                        </section>
                    </div>
                </div>

                <div class="page" id="distance-measurement">
                    <div class="max-w-7xl mx-auto space-y-8">
                        <header class="text-center">
                            <h1 class="text-3xl font-bold text-slate-800">距離測定ツール</h1>
                            <p class="text-slate-500 mt-2">マーカー間または剛体間の平均位置からの距離を測定します。</p>
                        </header>

                        <section class="bg-white p-6 rounded-lg shadow-sm border">
                            <h2 class="text-xl font-semibold text-center mb-6">1. 設定</h2>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                                <div>
                                    <label class="block text-sm font-medium text-slate-700 mb-2">① CSVファイルを追加</label>
                                    <div class="flex items-center space-x-2">
                                        <input type="file" id="csv-files-distance" accept=".csv" class="hidden">
                                        <label for="csv-files-distance"
                                            class="w-full cursor-pointer bg-slate-100 hover:bg-slate-200 text-slate-700 font-semibold py-2 px-4 rounded-md text-sm text-center">ファイルを選択</label>
                                    </div>
                                    <div id="file-name-distance" class="mt-2 text-sm text-slate-600"></div>
                                </div>
                                <div class="space-y-4">
                                    <div>
                                        <label class="block text-sm font-medium text-slate-700 mb-2">② 解析タイプ</label>
                                        <div class="flex items-center space-x-4 mt-2">
                                            <label class="flex items-center"><input type="radio"
                                                    name="analysis-type-distance" value="marker" class="form-radio"
                                                    checked> <span class="ml-2 text-sm">マーカー間距離</span></label>
                                            <label class="flex items-center"><input type="radio"
                                                    name="analysis-type-distance" value="rigidbody" class="form-radio">
                                                <span class="ml-2 text-sm">剛体間距離</span></label>
                                        </div>
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium text-slate-700 mb-2">③ データ取得間隔</label>
                                        <div class="flex items-center mb-2">
                                            <input type="checkbox" id="enable-downsampling-distance"
                                                class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
                                            <label for="enable-downsampling-distance"
                                                class="ml-2 text-sm text-slate-700">ダウンサンプリングを行う</label>
                                        </div>
                                        <div id="sampling-rate-container-distance" class="hidden">
                                            <label for="sampling-rate-distance"
                                                class="block text-xs font-medium text-slate-500 mb-1">間隔 (秒)</label>
                                            <input type="number" id="sampling-rate-distance" value="0.1" step="0.01"
                                                min="0.01"
                                                class="block w-full rounded-md shadow-sm p-2 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500">
                                        </div>
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium text-slate-700 mb-2">④ 元データの単位</label>
                                        <div class="flex items-center space-x-4 mt-2">
                                            <label class="flex items-center"><input type="radio"
                                                    name="data-unit-distance" value="mm" class="form-radio" checked>
                                                <span class="ml-2 text-sm">mm</span></label>
                                            <label class="flex items-center"><input type="radio"
                                                    name="data-unit-distance" value="m" class="form-radio"> <span
                                                    class="ml-2 text-sm">m</span></label>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div id="pair-selection-area" class="mt-8 hidden">
                                <h3 class="text-lg font-medium text-slate-800 mb-4 border-b pb-2">⑤ 測定対象のペアを選択 (最大5件)
                                </h3>
                                <div id="pair-list-container" class="space-y-4">
                                    <!-- Dynamic Rows -->
                                </div>
                                <button id="add-pair-btn"
                                    class="mt-4 text-sm text-blue-600 hover:text-blue-800 font-medium flex items-center">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20"
                                        fill="currentColor">
                                        <path fill-rule="evenodd"
                                            d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z"
                                            clip-rule="evenodd" />
                                    </svg>
                                    ペアを追加
                                </button>
                            </div>

                            <div class="text-center mt-8">
                                <button id="analyze-btn-distance"
                                    class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2.5 px-8 rounded-md shadow-sm disabled:bg-slate-400"
                                    disabled>
                                    解析開始
                                </button>
                            </div>
                        </section>

                        <section id="results-card-distance" class="bg-white p-6 rounded-lg shadow-sm border hidden">
                            <h2 class="text-xl font-semibold text-center mb-6">2. 解析結果</h2>
                            <div class="overflow-x-auto">
                                <table class="min-w-full divide-y divide-slate-200">
                                    <thead class="bg-slate-50">
                                        <tr>
                                            <th scope="col"
                                                class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">
                                                ペア</th>
                                            <th scope="col"
                                                class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">
                                                距離 (m)</th>
                                            <th scope="col"
                                                class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">
                                                点A 平均座標 (x,y,z)</th>
                                            <th scope="col"
                                                class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">
                                                点B 平均座標 (x,y,z)</th>
                                        </tr>
                                    </thead>
                                    <tbody id="results-table-body-distance" class="bg-white divide-y divide-slate-200">
                                    </tbody>
                                </table>
                            </div>
                        </section>
                    </div>
                </div>

                <div class="page" id="data-trimming">
                    <div class="max-w-7xl mx-auto space-y-8">
                        <header class="text-center">
                            <h1 class="text-3xl font-bold text-slate-800">データのトリミングツール</h1>
                            <p class="text-slate-500 mt-2">グラフを見ながら直感的にデータの範囲を選択し、必要な区間だけをMotive形式でエクスポートします。</p>
                        </header>

                        <section class="bg-white p-6 rounded-lg shadow-sm border">
                            <h2 class="text-xl font-semibold text-center mb-6">1. ファイル読み込み</h2>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                                <div>
                                    <label class="block text-sm font-medium text-slate-700 mb-2">① CSVファイルを選択</label>
                                    <div class="flex items-center space-x-2">
                                        <input type="file" id="csv-file-trimming" accept=".csv" class="hidden">
                                        <label for="csv-file-trimming"
                                            class="w-full cursor-pointer bg-slate-100 hover:bg-slate-200 text-slate-700 font-semibold py-2 px-4 rounded-md text-sm text-center">ファイルを選択</label>
                                    </div>
                                    <div id="file-name-trimming" class="mt-2 text-sm text-slate-600"></div>
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-slate-700 mb-2">② 表示する剛体</label>
                                    <select id="rigidbody-select-trimming" disabled
                                        class="block w-full bg-slate-100 border-slate-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 text-sm">
                                        <option value="">ファイルを読み込んでください</option>
                                    </select>
                                    <div class="mt-2 flex items-center">
                                        <input type="checkbox" id="trimming-downsample" checked class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
                                        <label for="trimming-downsample" class="ml-2 text-xs text-slate-500">描画時にダウンサンプリングを行う（動作が軽くなります）</label>
                                    </div>
                                </div>
                            </div>
                        </section>

                        <section id="trimming-editor-area" class="bg-white p-6 rounded-lg shadow-sm border hidden">
                            <h2 class="text-xl font-semibold text-center mb-6">2. 範囲の選択</h2>

                            <div class="w-full aspect-[21/9] bg-white p-2 border rounded-lg shadow-sm mb-6 relative">
                                <div class="chart-container">
                                    <canvas id="trimming-chart"></canvas>
                                </div>
                            </div>

                            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-end">
                                <div class="space-y-4">
                                    <div class="flex items-center justify-between bg-slate-50 p-3 rounded border">
                                        <label class="text-sm font-medium text-slate-700">開始時間 (秒)</label>
                                        <input type="number" id="trim-start-time" step="0.01" class="w-32 text-right border-slate-300 rounded-md shadow-sm p-1">
                                    </div>
                                    <div class="flex items-center justify-between bg-slate-50 p-3 rounded border">
                                        <label class="text-sm font-medium text-slate-700">終了時間 (秒)</label>
                                        <input type="number" id="trim-end-time" step="0.01" class="w-32 text-right border-slate-300 rounded-md shadow-sm p-1">
                                    </div>
                                </div>
                                <div class="text-center pb-2">
                                    <button id="export-trimming-btn"
                                        class="w-full md:w-auto bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-8 rounded-md shadow-lg transition-transform transform hover:scale-105">
                                        選択範囲をCSVでエクスポート
                                    </button>
                                    <p class="text-xs text-slate-500 mt-2">
                                        ※ エクスポートされたファイルは、Frameが1から、Timeが0から始まるように再計算されます。
                                    </p>
                                </div>
                            </div>
                        </section>
                    </div>
                </div>

                <div class="page" id="how-to-use">
                    <h1 class="text-2xl font-semibold text-gray-800 mb-8 text-center">使い方ガイド</h1>

                    <div class="space-y-10">
                        <div class="bg-white/70 backdrop-blur-xl rounded-xl border border-gray-200/80 shadow-sm">
                            <div class="p-6 sm:p-8">
                                <h2 class="text-xl font-semibold text-gray-900 flex items-center gap-3 mb-6">
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
                                        stroke-width="2" stroke="currentColor" class="h-6 w-6 text-gray-500">
                                        <path stroke-linecap="round" stroke-linejoin="round"
                                            d="M9 20l-5.447-2.724A1 1 0 0 1 3 16.382V5.618a1 1 0 0 1 1.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0 0 21 18.382V7.618a1 1 0 0 0-.553-.894L15 4m0 13V4m0 0L9 7">
                                        </path>
                                    </svg>
                                    <span>広域解析ツール</span>
                                </h2>
                                <div class="space-y-6">
                                    <div class="flex items-start gap-4">
                                        <div
                                            class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">
                                            1</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-3">設定</h3>
                                            <div class="space-y-3 text-gray-600 text-sm">
                                                <p><strong>① CSVファイルを追加:</strong> 解析したいMotiveのCSVファイルを1つ以上選択します。</p>
                                                <p><strong>② データ取得間隔:</strong>
                                                    データをサンプリングする時間間隔を秒単位で指定します。短いほど軌跡は詳細になりますが、処理が重くなる場合があります。</p>
                                                <p><strong>③ ヒートマップのマス目サイズ:</strong>
                                                    滞在頻度を可視化するヒートマップの1マスの大きさをメートル単位で指定します。</p>
                                                <p><strong>④ 方向の定義:</strong> 座標系における鉛直方向の軸を定義します。</p>
                                                <p><strong>⑤ 解析対象の剛体を選択:</strong> ファイル内の剛体から解析したいものを選択し、必要に応じて凡例名を編集します。
                                                </p>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="flex items-start gap-4">
                                        <div
                                            class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">
                                            2</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-2">解析開始</h3>
                                            <p class="text-gray-600 text-sm">ボタンを押すと解析が実行され、結果が表示されます。</p>
                                        </div>
                                    </div>
                                    <div class="flex items-start gap-4">
                                        <div
                                            class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">
                                            3</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-3">結果の確認</h3>
                                            <ul class="list-disc list-inside space-y-2 text-gray-600 text-sm">
                                                <li><strong>軌跡タブ:</strong> 選択した剛体の平面移動軌跡をプロットします。</li>
                                                <li><strong>ヒートマップタブ:</strong>
                                                    各マスに剛体が滞在した時間の頻度を色で表示します。カーソルを合わせると、そのマスのカウント数が表示されます。</li>
                                                <li><strong>網羅率の計算:</strong>
                                                    指定した円または正方形の範囲に対し、軌跡がどれだけの面積をカバーしたかをパーセンテージで計算します。</li>
                                                <li>各グラフはPNGまたはPDF形式でダウンロードできます。</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="bg-white/70 backdrop-blur-xl rounded-xl border border-gray-200/80 shadow-sm">
                            <div class="p-6 sm:p-8">
                                <h2 class="text-xl font-semibold text-gray-900 flex items-center gap-3 mb-6">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="text-gray-500">
                                        <path d="M3 3v18h18" />
                                        <path d="M18 17V9" />
                                        <path d="M13 17V5" />
                                        <path d="M8 17v-3" />
                                    </svg>
                                    <span>データ解析ツール</span>
                                </h2>

                                <div class="space-y-6">
                                    <div class="flex items-start gap-4">
                                        <div
                                            class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">
                                            0</div>
                                        <div class="flex-1">
                                            <h3 class="text-base font-medium text-gray-800 mb-3">データの収集</h3>
                                            <div class="space-y-3 text-gray-600 text-sm">
                                                <p class="text-gray-600 text-sm">
                                                    解析したい運動のトラッキングデータをキャプチャします。本ツールでは対象物の動作区間は、進行方向の変位データに基づいて自動で検出されます。具体的には、データ全体の振れ幅に対して非常に小さいマージン（デフォルト:
                                                    0.1%）を設定し、初期値からそのマージンを超えた瞬間を「動き出し」、データの末尾から逆算してマージン内に入った瞬間を「動き終わり」として判定します。これにより、理論上は一方向の単純な動作だけでなく、往復運動なども含めて動作全体を正確に捉えることができます。
                                                </p>

                                                <div class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4"
                                                    style="max-width: 900px;">
                                                    <div
                                                        class="aspect-square bg-gradient-to-br from-green-100 to-green-200 rounded-lg shadow-md flex items-center justify-center">
                                                        <div class="text-center">
                                                            <img src="img/simpleForward.png">
                                                            <div class="text-xs font-medium text-gray-700">向いている</div>
                                                        </div>
                                                    </div>
                                                    <div
                                                        class="aspect-square bg-gradient-to-br from-green-100 to-green-200 rounded-lg shadow-md flex items-center justify-center">
                                                        <div class="text-center">
                                                            <img src="img/simpleHopping.png">
                                                            <div class="text-xs font-medium text-gray-700">向いている</div>
                                                        </div>
                                                    </div>
                                                    <div
                                                        class="aspect-square bg-gradient-to-br  from-green-100 to-green-200 rounded-lg shadow-md flex items-center justify-center">
                                                        <div class="text-center">
                                                            <img src="img/simpleUpDown.png">
                                                            <div class="text-xs font-medium text-gray-700">向いている</div>
                                                        </div>
                                                    </div>
                                                    <div
                                                        class="aspect-square bg-gradient-to-br from-yellow-100 to-yellow-200 rounded-lg shadow-md flex items-center justify-center">
                                                        <div class="text-center">
                                                            <img src="img/complex.png">
                                                            <div class="text-xs font-medium text-gray-700">誤検出の可能性あり
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="flex items-start gap-4">
                                        <div
                                            class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">
                                            1</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-3">データ入力</h3>
                                            <div class="space-y-3 text-gray-600 text-sm">
                                                <p><strong>① CSVファイルを選択:</strong> 解析したいMotiveのCSVファイルを1つ以上選択します。</p>
                                                <p><strong>② 基準速度:</strong> 各ファイルに対応する車輪などの基準速度を入力します（スリップ率の計算に用います）。
                                                </p>
                                                <p><strong>③④ 方向の定義:</strong> 座標系における進行方向と鉛直方向を定義します。</p>
                                                <div
                                                    class="mt-3 p-3 bg-gray-100/80 rounded-md border border-gray-200/80">
                                                    <p class="font-medium text-gray-700 text-xs">【高度な設定】静止範囲の倍率:</p>
                                                    <p class="text-xs mt-1">
                                                        対象物の動作区間は、進行方向の変位データに基づいて自動で検出されます。具体的には、データ全体の振れ幅に対して非常に小さいマージン（デフォルト:
                                                        0.1%）を設定し、初期値（または最終値）からそのマージンを超えた瞬間をそれぞれ「動き出し」「動き終わり」として判定しています。このため、一方向の単純な動作に対しては高精度に検出できますが、何度も往復するような複雑な動作では、意図しない区間が検出される可能性があります。
                                                    </p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="flex items-start gap-4">
                                        <div
                                            class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">
                                            2</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-2">解析対象の剛体を選択</h3>
                                            <p class="text-gray-600 text-sm">
                                                ファイル内に含まれる剛体の一覧が表示されるので、解析したいものをチェックします。凡例名はグラフのラベルとして使用されます。</p>
                                        </div>
                                    </div>

                                    <div class="flex items-start gap-4">
                                        <div
                                            class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">
                                            3</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-2">解析開始</h3>
                                            <p class="text-gray-600 text-sm">ボタンを押すと解析が実行されます。</p>
                                        </div>
                                    </div>

                                    <div class="flex items-start gap-4">
                                        <div
                                            class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">
                                            4</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-3">結果確認と調整</h3>
                                            <ul class="list-disc list-inside space-y-2 text-gray-600 text-sm">
                                                <li>平均速度、スリップ率、およびそれらの分散が表示されます。</li>
                                                <li>微小速度のフィルタリング機能で、静止状態に近い微小な動きを平均速度の計算から除外できます。</li>
                                                <li>ローパスフィルタ機能で、グラフのノイズを低減できます。「移動平均」と「ガウシアン」から選択でき、フィルタ強度も調整可能です。</li>
                                                <li>グラフのラベルを編集したり、スタイル（カジュアル/フォーマル）を変更できます。</li>
                                                <li>各グラフはPNGまたはPDF形式でダウンロードできます。</li>
                                                <li>虫眼鏡アイコンからグラフを拡大表示できます。</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="bg-white/70 backdrop-blur-xl rounded-xl border border-gray-200/80 shadow-sm">
                            <div class="p-6 sm:p-8">
                                <h2 class="text-xl font-semibold text-gray-900 flex items-center gap-3 mb-6">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="text-gray-500">
                                        <path d="M15.6 3.3a10 10 0 1 0 5.7 5.7" />
                                        <circle cx="12" cy="12" r="2" />
                                        <path d="M13.4 10.6 19 5" />
                                    </svg>
                                    <span>基準速度算出ツール</span>
                                </h2>

                                <div class="space-y-6">
                                    <div class="flex items-start gap-4">
                                        <div
                                            class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">
                                            0</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-2">データの収集</h3>
                                            <p class="text-gray-600 text-sm">
                                                基準速度を算出したい回転系について、あらゆる負荷がかからない状態で固定して回転させたトラッキングデータをキャプチャします。例えば2輪ローバであれば、片方の車輪が鉛直方向を向くように立てかけて、上側の車輪にマーカをつけ、旋回動作をさせて上側車輪だけを回すことで無負荷の回転データを得ることができます。
                                            </p>
                                            <img src="img/v-caputure2.png" style="max-width: 150px;height: auto;">
                                        </div>
                                    </div>


                                    <div class="flex items-start gap-4">
                                        <div
                                            class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">
                                            1</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-2">データ入力</h3>
                                            <p class="text-gray-600 text-sm">解析したいMotiveのCSVファイルを1つ選択します。</p>
                                        </div>
                                    </div>

                                    <div class="flex items-start gap-4">
                                        <div
                                            class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">
                                            2</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-3">パラメータ設定</h3>
                                            <div class="space-y-3 text-gray-600 text-sm">
                                                <p><strong>② 車輪の剛体を選択:</strong> ファイル内の剛体から、回転を計測したい車輪を選択します。</p>
                                                <p><strong>③ 車輪の半径 (cm):</strong> 選択した車輪の半径をセンチメートル単位で入力します。</p>
                                                <p><strong>④ 車輪の回転軸:</strong> 車輪がどの軸周りに回転しているかを選択します。</p>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="flex items-start gap-4">
                                        <div
                                            class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">
                                            3</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-2">計算開始</h3>
                                            <p class="text-gray-600 text-sm">ボタンを押すと、データから回転の周期を算出し、基準速度（周速度）を計算します。</p>
                                        </div>
                                    </div>

                                    <div class="flex items-start gap-4">
                                        <div
                                            class="flex-shrink-0 bg-gray-200 text-gray-600 rounded-full h-7 w-7 text-sm flex items-center justify-center font-medium mt-1">
                                            4</div>
                                        <div>
                                            <h3 class="text-base font-medium text-gray-800 mb-2">結果確認</h3>
                                            <p class="text-gray-600 text-sm">計算された基準速度が表示され、結果をクリップボードにコピーできます。</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="page" id="algorithms">
                    <div class="max-w-4xl mx-auto space-y-8">
                        <div class="bg-white p-8 rounded-lg shadow-sm border">
                            <h1 class="text-2xl font-bold text-slate-800 mb-6 border-b pb-3">アルゴリズム仕様</h1>
                            <div class="prose-styles">
                                <p>本ツールで採用されているデータ解析のアルゴリズムおよび計算式について、その詳細を以下に示します。</p>

                                <h2 class="text-xl font-semibold text-slate-700 mt-8">データ解析ツール</h2>

                                <h3>動作区間の自動検出</h3>
                                <p>
                                    本ツールでは、CSVデータに含まれる時間全体のデータから、対象物が実際に動作している区間を自動で抽出します。この処理は、ユーザーが指定した「進行方向」の座標データに基づいて行われます。
                                    まず、進行方向軸における全データの最大値 $P_{max}$ と最小値 $P_{min}$ から、全体の振れ幅 $R$ を計算します。
                                </p>
                                <div class="formula-block">
                                    $R = P_{max} - P_{min}$
                                </div>
                                <p>
                                    次に、この振れ幅 $R$ とユーザーが設定可能な「静止範囲の倍率」$M$（デフォルト値: 0.001）を用いて、静止判定の閾値となるマージン $\delta$
                                    を決定します。
                                </p>
                                <div class="formula-block">
                                    $\delta = R \times M$
                                </div>
                                <p>
                                    このマージン $\delta$ を用いて、動作の開始点と終了点を検出します。<br>
                                    <b>動作開始点:</b> データの初期値 $P_{initial}$ から $\pm \delta$ の範囲を逸脱した最初のフレーム。<br>
                                    <b>動作終了点:</b> 往復運動などを正しく捉えるため、データの末尾から逆方向に探索します。最終値 $P_{final}$ から $\pm \delta$
                                    の範囲に最後に入ったフレーム（＝範囲外だった最後のフレームの次）を終了点とすることで、動作全体の区間を正確に抽出します。
                                </p>
                                <div class="my-6 text-center">
                                    <img src="img/exp.png" alt="動作区間検出のグラフ例"
                                        class="mx-auto rounded-lg shadow-md border">
                                    <p class="text-sm text-slate-500 mt-2">図1: 動作区間検出の概念図。変位データが静止範囲（マージン
                                        $\pm\delta$）を逸脱・復帰する点を検出する。</p>
                                </div>

                                <h3>水平移動距離</h3>
                                <p>
                                    各時刻 $t$ における水平移動距離 $d(t)$ は、ユーザーが定義した「鉛直方向」以外の2軸（水平軸 $h_1,
                                    h_2$）の変位から算出されます。動作開始点の座標を $(h_{1,0}, h_{2,0})$ とすると、時刻 $t$ での座標 $(h_{1,t},
                                    h_{2,t})$ との間の距離は、三平方の定理を用いて次式で計算されます。
                                </p>
                                <div class="formula-block">
                                    $d(t) = \sqrt{(h_{1,t} - h_{1,0})^2 + (h_{2,t} - h_{2,0})^2}$
                                </div>

                                <h3>瞬時速度（微小速度）</h3>
                                <p>
                                    時刻 $t_i$ における瞬時速度 $v_i$ は、隣接するフレーム間の水平移動距離と時間の変化量から、後退差分を用いて近似的に算出されます。
                                </p>
                                <div class="formula-block">
                                    $v_i = \frac{d(t_i) - d(t_{i-1})}{t_i - t_{i-1}} = \frac{\Delta d}{\Delta t}$
                                </div>

                                <h3>スリップ率</h3>
                                <p>
                                    スリップ率 $S$ は、ユーザーが入力した基準速度 $u$ と、算出した剛体の速度 $v$ を用いて計算されます。$u > v$
                                    の場合は駆動輪のスリップ（加速時）、$u < v$ の場合は制動輪のスリップ（減速時）として、以下の式で定義されます。 </p>
                                        <div class="formula-block">
                                            $S [\%] =
                                            \begin{cases}
                                            (1 - \frac{v}{u}) \times 100 & (u &gt; v, \text{ 加速スリップ}) \\
                                            (1 - \frac{u}{v}) \times 100 & (u &lt; v, \text{ 制動スリップ})
                                            \end{cases}$
                                        </div>
                                        <p>
                                            グラフにプロットされるのは各時刻の瞬時速度から算出されたスリップ率であり、「平均スリップ率」は平均速度を用いて算出されます。
                                        </p>

                                        <h3>分散</h3>
                                        <p>
                                            速度およびスリップ率のばらつきを示す指標として、標本分散 $\sigma^2$ と不偏分散 $u^2$ の2種類を算出しています。データ数
                                            $n$、個々のデータ値 $x_i$、平均値 $\bar{x}$ を用いて、それぞれ以下の式で計算されます。
                                        </p>
                                        <div class="formula-block">
                                            $\text{標本分散: } \sigma^2 = \frac{1}{n} \sum_{i=1}^{n} (x_i - \bar{x})^2$
                                        </div>
                                        <div class="formula-block">
                                            $\text{不偏分散: } u^2 = \frac{1}{n-1} \sum_{i=1}^{n} (x_i - \bar{x})^2$
                                        </div>

                                        <h3>ローパスフィルタ</h3>
                                        <p>
                                            グラフのノイズを低減するために、複数のローパスフィルタから選択できます。
                                        </p>
                                        <h4>移動平均フィルタ</h4>
                                        <p>
                                            単純移動平均（Simple Moving Average）法です。指定された「サンプル数」$W$に基づき、ある点 $i$ の値 $y_i$ を、その前後
                                            $\lfloor W/2 \rfloor$ 個のデータを含む合計 $W$ 個のデータの平均値 $\hat{y}_i$ で置き換えます。
                                        </p>
                                        <div class="formula-block">
                                            $\hat{y}_i = \frac{1}{W} \sum_{j=i-\lfloor W/2 \rfloor}^{i+\lfloor W/2
                                            \rfloor} y_j$
                                        </div>
                                        <h4>ガウシアンフィルタ</h4>
                                        <p>
                                            より滑らかな結果が得られるガウス畳み込みによるフィルタです。フィルタの核となるガウス関数の標準偏差 $\sigma$
                                            をユーザーが直接指定します。$\sigma$ の値が大きいほど、より強力な平滑化がかかります。
                                        </p>
                                        <div class="formula-block">
                                            $$G(x) = \frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{x^2}{2\sigma^2}}$$
                                        </div>

                                        <h2 class="text-xl font-semibold text-slate-700 mt-8">広域解析ツール</h2>
                                        <h3>データサンプリング</h3>
                                        <p>
                                            複数のCSVファイルから長時間のデータを効率的に扱うため、指定された「データ取得間隔」に基づいてデータをサンプリングします。座標は正規化せず、元データの値をそのまま使用します。
                                        </p>

                                        <h3>ヒートマップ生成</h3>
                                        <p>
                                            対象物の滞在頻度や傾向を可視化するため、ヒートマップを生成します。まず、描画領域全体をユーザー指定の「マス目のサイズ」でグリッドに分割します。
                                            次に、サンプリングされた各データ点について、それがどのグリッドセルに位置するかを判定します。同一のサンプリング時刻内に複数のデータ点（剛体）が同じセルに存在した場合でも、そのセルは1回のみカウントされます。これにより、各セルが少なくとも1回以上占有されたサンプリング時刻の総数を集計し、ヒートマップの各セルの値とします。
                                        </p>
                                        <div class="formula-block">
                                            $\text{Cell}(i, j) = \sum_{t \in T} \mathbf{1} \left( \exists p \in P_t
                                            \text{ s.t. } p \in \text{Grid}(i, j) \right)$
                                        </div>
                                        <p>
                                            ここで、$T$はサンプリング時刻の集合、$P_t$は時刻$t$における全データ点の集合、$\mathbf{1}(\cdot)$は指示関数です。
                                        </p>

                                        <h3>網羅率の計算</h3>
                                        <p>
                                            指定された基準範囲（円または正方形）に対して、対象物がどれだけの割合の領域を走破したかを示す「網羅率」を計算します。
                                            まず、基準範囲内に中心が含まれるヒートマップのグリッドセルの総数 $N_{total}$
                                            を求めます。次に、これらのセルのうち、対象物が少なくとも1回以上滞在した（ヒートマップの値が1以上である）セルの数 $N_{reached}$
                                            をカウントします。網羅率 $C$ は以下の式で算出されます。
                                        </p>
                                        <div class="formula-block">
                                            $C [\%] = \frac{N_{reached}}{N_{total}} \times 100$
                                        </div>


                                        <h2 class="text-xl font-semibold text-slate-700 mt-8">基準速度算出ツール</h2>

                                        <h3>角度データのアンラップ</h3>
                                        <p>
                                            Motiveから出力される回転角度データは、通常 $\pm 180^\circ$
                                            の範囲に制限されており、回転がこの範囲を超えると値が不連続に変化（ラップ）します。正確な周期計算のため、このラップを解消（アンラップ）し、連続的な角度変化データに変換します。具体的には、隣接する角度データ
                                            $A_{i-1}$ と $A_i$ の差が $\pm 180^\circ$ を超えた場合に、$360^\circ$
                                            のオフセットを加算または減算して補正します。
                                        </p>
                                        <div class="formula-block">
                                            $A'_{i} =
                                            \begin{cases}
                                            A'_{i-1} + (A_i - A_{i-1}) - 360 & (A_i - A_{i-1} &gt; 180^\circ) \\
                                            A'_{i-1} + (A_i - A_{i-1}) + 360 & (A_i - A_{i-1} &lt; -180^\circ) \\
                                            A'_{i-1} + (A_i - A_{i-1}) & (\text{その他})
                                            \end{cases}$
                                        </div>

                                        <h3>回転周期の算出</h3>
                                        <p>
                                            アンラップされた角度データから、車輪が1回転（$360^\circ$）するのに要する時間（周期
                                            $T$）を算出します。まず、回転が開始したと見なされる点（初期角度から $5^\circ$ 以上変化した点）を検出し、その時刻 $t_{start}$
                                            と角度 $A_{start}$ を記録します。次に、角度が $A_{start} \pm 360^\circ$ に到達する時刻 $t_{end}$
                                            を探します。
                                            目標角度を跨ぐ2つのフレーム間で線形補間を行い、正確な到達時刻 $t_{end}$ を推定します。目標角度 $A_{target}$
                                            を跨ぐ直前と直後の点をそれぞれ $(t_{before}, A_{before})$, $(t_{after}, A_{after})$
                                            とした場合、到達時刻 $t_{end}$ は以下の線形補間の式で求められます。
                                        </p>
                                        <div class="formula-block">
                                            $t_{end} = t_{before} + (t_{after} - t_{before}) \times \frac{A_{target} -
                                            A_{before}}{A_{after} - A_{before}}$
                                        </div>
                                        <p>
                                            最終的な周期 $T$ は以下の式で得られます。
                                        </p>
                                        <div class="formula-block">
                                            $T = t_{end} - t_{start}$
                                        </div>

                                        <h3>基準速度の算出</h3>
                                        <p>
                                            算出された周期 $T$ と、ユーザーが入力した車輪の半径 $r$ から、車輪の周速度、すなわち基準速度 $v$ を計算します。角速度 $\omega$
                                            は $\omega = 2\pi / T$ で与えられるため、基準速度 $v$ は次式で求められます。
                                        </p>
                                        <div class="formula-block">
                                            $v = r \cdot \omega = \frac{2\pi r}{T}$
                                        </div>

                                        <h2 class="text-xl font-semibold text-slate-700 mt-8">距離測定ツール</h2>
                                        <h3>距離の算出</h3>
                                        <p>
                                            指定された2点（点Aと点B）間の距離を測定します。まず、全解析区間における各点の平均座標 $(\bar{x}, \bar{y}, \bar{z})$
                                            を算出します。データ点数を $N$、各時刻 $t$ における座標を $(x_t, y_t, z_t)$ とすると、平均座標は次式で計算されます。
                                        </p>
                                        <div class="formula-block">
                                            $\bar{x} = \frac{1}{N} \sum_{t=1}^{N} x_t, \quad \bar{y} = \frac{1}{N}
                                            \sum_{t=1}^{N} y_t, \quad \bar{z} = \frac{1}{N} \sum_{t=1}^{N} z_t$
                                        </div>
                                        <p>
                                            点Aの平均座標を $(\bar{x}_A, \bar{y}_A, \bar{z}_A)$、点Bの平均座標を $(\bar{x}_B,
                                            \bar{y}_B, \bar{z}_B)$ としたとき、2点間の距離 $D$ はユークリッド距離の公式を用いて次のように求められます。
                                        </p>
                                        <div class="formula-block">
                                            $D = \sqrt{(\bar{x}_A - \bar{x}_B)^2 + (\bar{y}_A - \bar{y}_B)^2 +
                                            (\bar{z}_A - \bar{z}_B)^2}$
                                        </div>

                                        <h2 class="text-xl font-semibold text-slate-700 mt-8">データのトリミングツール</h2>
                                        <h3>データの再インデックス</h3>
                                        <p>
                                            指定された区間 $[t_{start}, t_{end}]$ に含まれるデータを抽出した後、Motive形式の互換性を維持するために、フレーム番号と時刻の再計算を行います。
                                            抽出されたデータ列の最初のフレームの時刻を $t_{start}$、フレーム番号を $F_{start}$ としたとき、抽出後の $i$ 番目のデータ（$0$始まり）の新しい時刻 $t'_i$ とフレーム番号 $F'_i$ は以下のように定義されます。
                                        </p>
                                        <div class="formula-block">
                                            $t'_i = t_{start+i} - t_{start}$
                                        </div>
                                        <div class="formula-block">
                                            $F'_i = i + 1$
                                        </div>
                                        <p>
                                            これにより、トリミング後のデータは常に時刻 0.0 秒、フレーム 1 から開始するように正規化されます。
                                        </p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="page" id="about">
                    <div class="max-w-4xl mx-auto space-y-8">
                        <div class="bg-white p-8 rounded-lg shadow-sm border">
                            <h1 class="text-2xl font-bold text-slate-800 mb-6 border-b pb-3">このツールについて</h1>
                            <div class="prose prose-slate max-w-none">
                                <div>
                                    <h2 class="text-xl font-semibold text-slate-700">基本情報</h2>
                                    <div class="mt-3 grid grid-cols-1 gap-y-2 text-sm">
                                        <p><span class="w-24 inline-block font-medium text-slate-500">アプリ名:</span> Mocap
                                            Plus</p>
                                        <p><span class="w-24 inline-block font-medium text-slate-500">バージョン:</span>
                                            3.1.0</p>
                                        <p><span class="w-24 inline-block font-medium text-slate-500">製作者:</span>
                                            中央大学理工学部 國井研究室 西藤 実</p>
                                        <p><span class="w-24 inline-block font-medium text-slate-500">リポジトリ:</span> <a
                                                href="https://github.com/minoru-saito-chuo/mocap" target="_blank"
                                                class="text-blue-600 hover:underline">GitHub</a></p>

                                    </div>
                                </div>
                                <br>
                                <div>
                                    <h2 class="text-xl font-semibold text-slate-700">更新履歴</h2>
                                    <ul class="mt-3 list-disc list-inside space-y-2 text-sm">
                                        <li><span class="font-semibold">2025-12-16:</span>
                                            新たに距離測定ツールを追加。点Aと点Bの平均座標を計算し、ユークリッド距離を測定する機能を提供。</li>
                                        <li><span class="font-semibold">2025-12-15:</span>
                                            基準速度算出ツールにおいて、クウォータニオン形式のエクスポートデータでもトラッキングできるよう改善。</li>
                                        <li><span class="font-semibold">2025-10-20:</span>
                                            広域解析ツールを追加し、軌跡・ヒートマップ・網羅率の可視化機能を追加。</li>
                                        <li><span class="font-semibold">2025-08-07:</span>
                                            データ解析ツールでファイルを後からでも追加できるよう修正。スクロールしてもメニューが固定されるよう改善。</li>
                                        <li><span class="font-semibold">2025-08-05:</span>
                                            ローパスフィルタにガウシアンフィルタを追加。動作区間検出アルゴリズムを修正。その他の潜在的なバグを修正。</li>
                                        <li><span class="font-semibold">2025-07-05:</span>
                                            アルゴリズム仕様ページを追加し、数式表示の改善やレイアウト修正などの更新を実施。</li>
                                        <li><span class="font-semibold">2025-07-04:</span>
                                            データ解析ツールに分散表示機能と、ユーザが任意に設定できるローパスフィルタ機能を追加。UI/UXの改善。</li>
                                        <li><span class="font-semibold">2025-07-03:</span> データ解析ツールにグラフ拡大機能を追加。</li>
                                        <li><span class="font-semibold">2025-06-28:</span> 基準速度の算出ツールを作成、データ解析ツールに統合。
                                        </li>
                                        <li><span class="font-semibold">2025-06-21:</span> データ解析ツールの初期リリース。</li>
                                    </ul>
                                </div>
                                <br>
                                <div>
                                    <h2 class="text-xl font-semibold text-slate-700">注意事項・免責事項</h2>
                                    <ul class="mt-3 list-disc space-y-2 pl-5 text-sm text-slate-600">
                                        <li>本ツールは、OptiTrackの解析ソフト「Motive」からエクスポートされたCSVファイルに最適化されています。</li>
                                        <li>データ処理は全てブラウザ内で完結し、添付したデータが外部に送信されることはありません。</li>
                                        <li>本ツールの利用によって生じた直接的または間接的な損害について、製作者は一切責任を負いません。</li>
                                        <li>本ツールの作成にあたっては、複数のLLMを利用しています。</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        <p class="text-center text-slate-500 text-sm">© 2025 SAITO Minoru.</p>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <div id="mobile-menu-overlay" class="lg:hidden fixed inset-0 z-40 hidden opacity-0">
        <div class="absolute inset-0 bg-black/40 backdrop-blur-sm"></div>
        <div id="mobile-menu-content"
            class="relative bg-slate-100 w-64 h-full shadow-lg p-4 transform -translate-x-full">
            <button id="mobile-menu-close-btn" class="absolute top-4 right-4 p-2">
                <svg class="h-6 w-6 text-slate-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
                    stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            <div class="flex items-center mb-6">
                <img src="icons/icon-192.png" style="width: 25px; height: auto;">
                <h1 class="text-lg font-bold text-slate-800 ml-2">Mocap Plus</h1>
            </div>
            <nav class="space-y-2" id="mobile-nav-links">
                <a class="nav-link block px-4 py-2 text-slate-700 hover:bg-slate-200 rounded-md" href="#home">ホーム</a>
                <a class="nav-link block px-4 py-2 text-slate-700 hover:bg-slate-200 rounded-md"
                    href="#data-analysis">データ解析ツール</a>
                <a class="nav-link block px-4 py-2 text-slate-700 hover:bg-slate-200 rounded-md"
                    href="#wide-area-analysis">広域解析ツール</a>
                <a class="nav-link block px-4 py-2 text-slate-700 hover:bg-slate-200 rounded-md"
                    href="#standard-velocity">基準速度算出ツール</a>
                <a class="nav-link block px-4 py-2 text-slate-700 hover:bg-slate-200 rounded-md"
                    href="#distance-measurement">距離測定ツール</a>
                <a class="nav-link block px-4 py-2 text-slate-700 hover:bg-slate-200 rounded-md"
                    href="#how-to-use">使い方ガイド</a>
                <a class="nav-link block px-4 py-2 text-slate-700 hover:bg-slate-200 rounded-md"
                    href="#algorithms">アルゴリズム仕様</a>
                <a class="nav-link block px-4 py-2 text-slate-700 hover:bg-slate-200 rounded-md"
                    href="#about">このツールについて</a>
            </nav>
        </div>
    </div>

    <div id="chart-zoom-modal"
        class="hidden fixed top-0 left-0 w-full h-full bg-black/60 backdrop-blur-sm flex justify-center items-center z-50 p-4 transition-opacity duration-300">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-5xl h-full max-h-[90vh] flex flex-col">
            <div class="flex justify-end p-2">
                <button id="modal-close-btn"
                    class="p-2 text-slate-500 hover:text-slate-800 rounded-full hover:bg-slate-100 transition-colors">
                    <svg class="h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
                        stroke-width="1.5" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <div class="flex-1 min-h-0 p-4 pt-0">
                <canvas id="modal-chart-canvas"></canvas>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Global Variables ---
            let modalChartInstance = null;

            // --- SPA Navigation ---
            const pages = document.querySelectorAll('.page');
            const mobileMenuBtn = document.getElementById('mobile-menu-btn');
            const mobileMenuOverlay = document.getElementById('mobile-menu-overlay');
            const mobileMenuContent = document.getElementById('mobile-menu-content');
            const mobileMenuCloseBtn = document.getElementById('mobile-menu-close-btn');
            const mobileNavLinks = document.getElementById('mobile-nav-links');
            const mobileTitle = document.getElementById('mobile-title');
            const mainContentArea = document.getElementById('main-content-area');

            function openMobileMenu() {
                if (!mobileMenuOverlay) return;
                document.body.classList.add('mobile-menu-open');
                mobileMenuOverlay.classList.remove('hidden');
                setTimeout(() => {
                    mobileMenuOverlay.classList.remove('opacity-0');
                    if (mobileMenuContent) mobileMenuContent.classList.remove('-translate-x-full');
                }, 10);
            }

            function closeMobileMenu() {
                if (!mobileMenuOverlay) return;
                document.body.classList.remove('mobile-menu-open');
                mobileMenuOverlay.classList.add('opacity-0');
                if (mobileMenuContent) mobileMenuContent.classList.add('-translate-x-full');
                setTimeout(() => {
                    mobileMenuOverlay.classList.add('hidden');
                }, 300);
            }

            function renderMath() {
                if (window.renderMathInElement) {
                    renderMathInElement(document.getElementById('algorithms'), {
                        delimiters: [
                            { left: '$$', right: '$$', display: true },
                            { left: '$', right: '$', display: false },
                            { left: '\\(', right: '\\)', display: false },
                            { left: '\\[', right: '\\]', display: true }
                        ],
                        throwOnError: false
                    });
                }
            }

            function showPage(pageId) {
                pages.forEach(page => {
                    page.classList.remove('active');
                });
                const targetPage = document.getElementById(pageId);
                if (targetPage) {
                    targetPage.classList.add('active');
                }

                document.querySelectorAll('.nav-link').forEach(link => {
                    const linkPageId = link.getAttribute('href').substring(1);
                    const isActive = linkPageId === pageId;
                    link.classList.toggle('active', isActive);

                    if (isActive) {
                        const titleText = link.querySelector('span')?.textContent || link.textContent.trim();
                        if (mobileTitle) mobileTitle.textContent = titleText;
                    }
                });
                window.scrollTo(0, 0);

                if (pageId === 'algorithms') {
                    renderMath();
                }
            }

            if (mobileMenuBtn) mobileMenuBtn.addEventListener('click', openMobileMenu);
            if (mobileMenuCloseBtn) mobileMenuCloseBtn.addEventListener('click', closeMobileMenu);
            if (mobileMenuOverlay) {
                mobileMenuOverlay.addEventListener('click', (e) => {
                    if (e.target === mobileMenuOverlay) closeMobileMenu();
                });
            }

            const allNavLinks = document.querySelectorAll('.nav-link, .nav-card');
            allNavLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const pageId = link.getAttribute('href').substring(1);
                    history.pushState(null, '', '#' + pageId);
                    showPage(pageId);
                    closeMobileMenu();
                });
            });

            window.addEventListener('popstate', () => {
                const pageId = window.location.hash ? window.location.hash.substring(1) : 'home';
                showPage(pageId);
            });

            const initialPage = window.location.hash ? window.location.hash.substring(1) : 'home';
            if (document.getElementById(initialPage)) {
                showPage(initialPage);
            } else {
                showPage('home');
            }

            // --- DATA ANALYSIS TOOL SCRIPT ---
            const fileDataStore = {};
            const chartInstances = {};
            let allInstantaneousVelocities = [];
            let lastProcessedData = [];

            const csvFileInput = document.getElementById('csv-files');
            const fileListDiv = document.getElementById('file-list');
            const clearFilesBtn = document.getElementById('clear-files-btn');
            const travelAxisSelect = document.getElementById('travel-axis');
            const verticalAxisSelect = document.getElementById('vertical-axis');
            const rigidbodySelectionSection = document.getElementById('rigidbody-selection-section');
            const rigidbodyListDiv = document.getElementById('rigidbody-list');
            const startAnalysisBtn = document.getElementById('start-analysis-btn');
            const resultsSection = document.getElementById('results-section');
            const loadingDiv = document.getElementById('loading');
            const downloadOverlay = document.getElementById('download-overlay');
            const filterVelocityCheckbox = document.getElementById('filter-velocity-checkbox');
            const filterRangeInputs = document.getElementById('filter-range-inputs');
            const recalculateAvgBtn = document.getElementById('recalculate-avg-btn');
            const redrawChartsBtn = document.getElementById('redraw-charts-btn');
            const loadingText = document.getElementById('loading-text');

            const lowpassFilterTypeSelect = document.getElementById('lowpass-filter-type');
            const lowpassStrengthInput = document.getElementById('lowpass-strength');
            const lowpassStrengthLabel = document.getElementById('lowpass-strength-label');
            const filterDescription = document.getElementById('filter-description');


            // --- Modal Elements ---
            const chartZoomModal = document.getElementById('chart-zoom-modal');
            const modalCloseBtn = document.getElementById('modal-close-btn');
            const modalChartCanvas = document.getElementById('modal-chart-canvas');

            // --- Low Pass Filter Helpers ---
            function applyMovingAverageFilter(dataPoints, windowSize) {
                if (windowSize <= 1 || dataPoints.length < windowSize) return dataPoints;

                const smoothedPoints = [];
                const halfWindow = Math.floor(windowSize / 2);

                for (let i = 0; i < dataPoints.length; i++) {
                    const start = Math.max(0, i - halfWindow);
                    const end = Math.min(dataPoints.length - 1, i + halfWindow);
                    let sumY = 0;
                    for (let j = start; j <= end; j++) {
                        sumY += dataPoints[j].y;
                    }
                    const avgY = sumY / (end - start + 1);
                    smoothedPoints.push({ x: dataPoints[i].x, y: avgY });
                }
                return smoothedPoints;
            }

            function applyGaussianFilter(dataPoints, sigma) {
                if (sigma <= 0 || dataPoints.length < 3) return dataPoints;

                const radius = Math.ceil(sigma * 3);
                const kernel = [];
                let kernelSum = 0;
                for (let i = -radius; i <= radius; i++) {
                    const val = Math.exp(-0.5 * (i / sigma) * (i / sigma));
                    kernel.push(val);
                    kernelSum += val;
                }
                for (let i = 0; i < kernel.length; i++) {
                    kernel[i] /= kernelSum;
                }

                const smoothedPoints = [];
                const halfKernel = Math.floor(kernel.length / 2);

                for (let i = 0; i < dataPoints.length; i++) {
                    let weightedSumY = 0;
                    for (let j = 0; j < kernel.length; j++) {
                        const dataIndex = i + j - halfKernel;
                        const clampedIndex = Math.max(0, Math.min(dataPoints.length - 1, dataIndex));
                        weightedSumY += dataPoints[clampedIndex].y * kernel[j];
                    }
                    smoothedPoints.push({ x: dataPoints[i].x, y: weightedSumY });
                }
                return smoothedPoints;
            }

            function rerenderCharts() {
                if (lastProcessedData && lastProcessedData.length > 0) {
                    renderAllCharts(lastProcessedData, travelAxisSelect.value, verticalAxisSelect.value);
                } else {
                    alert('先に解析を実行してください。');
                }
            }

            if (csvFileInput) {
                csvFileInput.addEventListener('change', (e) => handleFileSelect(e, 'data-analysis'));
                startAnalysisBtn.addEventListener('click', startAnalysis);
                if (clearFilesBtn) {
                    clearFilesBtn.addEventListener('click', () => clearAllFiles('data-analysis'));
                }

                lowpassFilterTypeSelect.addEventListener('change', (e) => {
                    const filterType = e.target.value;
                    if (filterType === 'none') {
                        lowpassStrengthInput.disabled = true;
                        lowpassStrengthLabel.innerHTML = '強度:';
                        filterDescription.textContent = 'フィルタを選択すると、強度を指定できます。';
                    } else if (filterType === 'moving-average') {
                        lowpassStrengthInput.disabled = false;
                        lowpassStrengthInput.value = 10;
                        lowpassStrengthInput.step = 1;
                        lowpassStrengthLabel.innerHTML = 'サンプル数:';
                        filterDescription.textContent = '移動平均のサンプル数（整数）を指定します。値が大きいほど滑らかになります。';
                    } else if (filterType === 'gaussian') {
                        lowpassStrengthInput.disabled = false;
                        lowpassStrengthInput.value = 2.0;
                        lowpassStrengthInput.step = 0.1;
                        lowpassStrengthLabel.innerHTML = 'σ値:';
                        filterDescription.innerHTML = '<b>σ値の目安:</b> 1.0-2.5(弱), 2.5-3.5(標準), 3.5-5.0(強)';
                    }
                });

                rigidbodyListDiv.addEventListener('change', (event) => {
                    if (event.target.classList.contains('rigidbody-checkbox')) {
                        const checkbox = event.target;
                        const itemContainer = checkbox.closest('.rigidbody-item-container');
                        const legendInputContainer = itemContainer.querySelector('.legend-input-container');
                        if (legendInputContainer) {
                            legendInputContainer.classList.toggle('hidden', !checkbox.checked);
                        }
                    }
                });

                fileListDiv.addEventListener('click', async (event) => {
                    const pasteBtn = event.target.closest('.paste-btn');
                    if (!pasteBtn) return;

                    try {
                        const text = await navigator.clipboard.readText();
                        const targetId = pasteBtn.dataset.targetId;
                        const targetInput = document.getElementById(targetId);
                        if (targetInput && !isNaN(parseFloat(text))) {
                            targetInput.value = parseFloat(text);
                        } else {
                            console.warn("Pasted content is not a valid number.");
                        }
                    } catch (err) {
                        alert('Failed to read clipboard contents: ', err);
                        alert("クリップボードの読み取りに失敗しました。ブラウザの権限設定を確認してください。");
                    }
                });

                filterVelocityCheckbox.addEventListener('change', () => {
                    filterRangeInputs.classList.toggle('hidden', !filterVelocityCheckbox.checked);
                });
                recalculateAvgBtn.addEventListener('click', recalculateAverages);

                if (redrawChartsBtn) redrawChartsBtn.addEventListener('click', rerenderCharts);


                document.querySelectorAll('.style-btn').forEach(btn => btn.addEventListener('click', handleStyleChange));
                document.getElementById('download-velocity-csv').addEventListener('click', downloadVelocityCSV);
                document.querySelectorAll('.chart-label-input').forEach(input => {
                    input.addEventListener('input', updateAllChartLabels);
                });

                resultsSection.addEventListener('click', (event) => {
                    const button = event.target.closest('button');
                    if (!button) return;

                    if (button.classList.contains('zoom-btn')) {
                        handleZoom(button.dataset.chartId);
                    } else if (button.classList.contains('download-btn')) {
                        handleDownload(button.dataset.chartId, button.dataset.format);
                    }
                });
            }

            if (modalCloseBtn) modalCloseBtn.addEventListener('click', closeZoomModal);
            if (chartZoomModal) chartZoomModal.addEventListener('click', (e) => { if (e.target === chartZoomModal) closeZoomModal(); });

            function handleZoom(chartId) {
                const originalChart = chartInstances[chartId];
                if (!originalChart) return;
                if (modalChartInstance) modalChartInstance.destroy();
                const modalChartOptions = JSON.parse(JSON.stringify(originalChart.options));
                modalChartOptions.maintainAspectRatio = false;
                modalChartOptions.plugins.title.font.size = 20;
                modalChartOptions.plugins.legend.labels.font.size = 14;
                modalChartOptions.scales.x.title.font.size = 16;
                modalChartOptions.scales.y.title.font.size = 16;
                modalChartOptions.scales.x.ticks.font.size = 14;
                modalChartOptions.scales.y.ticks.font.size = 14;
                modalChartInstance = new Chart(modalChartCanvas, { type: originalChart.config.type, data: originalChart.config.data, options: modalChartOptions });
                chartZoomModal.classList.remove('hidden');
            }

            function closeZoomModal() {
                if (modalChartInstance) { modalChartInstance.destroy(); modalChartInstance = null; }
                chartZoomModal.classList.add('hidden');
            }


            function clearAllFiles(tool) {
                if (tool === 'data-analysis') {
                    for (const key in fileDataStore) { delete fileDataStore[key]; }
                    fileListDiv.innerHTML = '';
                    rigidbodyListDiv.innerHTML = '';
                    rigidbodySelectionSection.classList.add('hidden');
                    resultsSection.classList.add('hidden');
                    csvFileInput.value = '';
                }
            }

            function handleFileSelect(event, tool) {
                const files = Array.from(event.target.files);
                if (files.length === 0) return;

                if (tool === 'data-analysis') {
                    rigidbodySelectionSection.classList.remove('hidden');

                    files.forEach(file => {
                        if (fileDataStore[file.name]) {
                            console.log(`File "${file.name}" is already loaded. Skipping.`);
                            return;
                        }

                        const fileId = `file-${file.name.replace(/[^a-zA-Z0-9]/g, '')}`;
                        const fileElement = document.createElement('div');
                        fileElement.className = 'bg-slate-50 p-2.5 rounded-md flex items-center justify-between border text-sm';
                        fileElement.innerHTML = `
                            <span class="text-slate-700 truncate pr-4">${file.name}</span>
                            <div class="flex items-center flex-shrink-0">
                                <label for="speed-${fileId}" class="text-xs text-slate-500 mr-2 whitespace-nowrap">基準速度(m/s):</label>
                                <div class="flex">
                                    <input type="number" id="speed-${fileId}" data-filename="${file.name}" class="reference-speed-input bg-white border border-slate-300 rounded-l-md w-20 p-1 text-right text-sm" step="0.1" value="1.0">
                                    <button type="button" class="paste-btn p-1.5 bg-slate-100 hover:bg-slate-200 border border-l-0 border-slate-300 rounded-r-md" data-target-id="speed-${fileId}" title="ペースト">
                                        <svg class="h-4 w-4 text-slate-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h3.75M9 15h3.75M9 18h3.75m3 .75H18a2.25 2.25 0 002.25-2.25V6.108c0-1.135-.845-2.098-1.976-2.192a48.424 48.424 0 00-1.123-.08m-5.801 0c-.065.21-.1.433-.1.664 0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75 2.25 2.25 0 00-.1-.664m-5.8 0A2.251 2.251 0 0113.5 2.25H15c1.012 0 1.867.668 2.15 1.586m-5.8 0c-.376.023-.75.05-1.124.08C9.095 4.01 8.25 4.973 8.25 6.108V8.25m0 0H4.875c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V9.375c0-.621-.504-1.125-1.125-1.125H8.25z" /></svg>
                                    </button>
                                </div>
                            </div>
                        `;
                        fileListDiv.appendChild(fileElement);
                        Papa.parse(file, {
                            complete: (results) => {
                                try {
                                    const rigidBodies = extractRigidBodies(results.data);
                                    fileDataStore[file.name] = { rawData: results.data, rigidBodies };
                                    displayRigidBodySelector(file.name, rigidBodies);
                                } catch (error) {
                                    alert(`ファイル "${file.name}" の解析中にエラーが発生しました: ${error.message}`);
                                }
                            },
                            error: (error) => alert(`ファイル "${file.name}" の読み込みに失敗しました: ${error.message}`)
                        });
                    });
                }
                event.target.value = '';
            }

            function extractRigidBodies(data) {
                let typeRowIndex = -1, nameRowIndex = -1, propertyRowIndex = -1, dataStartIndex = -1;
                for (let i = 0; i < 15 && i < data.length; i++) {
                    if (data[i][1] === 'Type') typeRowIndex = i;
                    if (data[i][1] === 'Name') nameRowIndex = i;
                    if (data[i][2] === 'Rotation' || data[i][2] === 'Position') propertyRowIndex = i;
                    if (data[i][0] === 'Frame' && data[i][1] === 'Time (Seconds)') dataStartIndex = i + 1;
                }
                if (typeRowIndex === -1 || nameRowIndex === -1 || propertyRowIndex === -1 || dataStartIndex === -1) throw new Error("CSVのヘッダー形式が不正です。");

                const [typeRow, nameRow, propertyRow] = [data[typeRowIndex], data[nameRowIndex], data[propertyRowIndex]];
                const rigidBodies = {};

                for (let i = 2; i < typeRow.length; i++) {
                    if (typeRow[i] === 'Rigid Body' && propertyRow[i] === 'Position') {
                        const name = nameRow[i];
                        if (!rigidBodies[name]) rigidBodies[name] = { name: name, posIndices: {} };
                        rigidBodies[name].posIndices = { X: i, Y: i + 1, Z: i + 2 };
                        i += 2;
                    }
                }

                const dataUnit = document.querySelector('input[name="data-unit"]:checked').value;
                const conversionFactor = dataUnit === 'mm' ? 1000 : 1;
                const actualData = data.slice(dataStartIndex).filter(row => row.length > 1 && row[1] !== '');
                Object.values(rigidBodies).forEach(body => {
                    body.data = actualData.map(row => ({
                        time: parseFloat(row[1]),
                        pos: {
                            X: parseFloat(row[body.posIndices.X]) / conversionFactor,
                            Y: parseFloat(row[body.posIndices.Y]) / conversionFactor,
                            Z: parseFloat(row[body.posIndices.Z]) / conversionFactor
                        }
                    })).filter(d => !isNaN(d.time) && !isNaN(d.pos.X));
                });
                return Object.values(rigidBodies);
            }

            function displayRigidBodySelector(filename, rigidBodies) {
                const fileGroupContainer = document.createElement('div');
                fileGroupContainer.className = 'mb-4';
                let listHTML = `<h3 class="text-md font-semibold text-slate-700 mb-2 border-b pb-2">[${filename}] の剛体</h3><div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-y-2 gap-x-4">`;
                if (rigidBodies.length === 0) {
                    listHTML += `<p class="text-slate-500 col-span-full text-sm">剛体データが見つかりませんでした。</p>`;
                } else {
                    rigidBodies.forEach(body => {
                        const defaultLabel = `${filename} - ${body.name}`;
                        listHTML += `
                        <div class="rigidbody-item-container">
                            <label class="flex items-center space-x-2 p-2 rounded-md hover:bg-slate-100 cursor-pointer w-full">
                                <input type="checkbox" class="rigidbody-checkbox form-checkbox h-4 w-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500" data-filename="${filename}" data-bodyname="${body.name}">
                                <span class="text-slate-800 text-sm">${body.name}</span>
                            </label>
                            <div class="legend-input-container hidden pl-7 mt-1">
                                <label class="text-xs text-slate-500">凡例名:</label>
                                <input type="text" class="legend-label-input mt-1 block w-full rounded-md shadow-sm p-1.5 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500" data-filename="${filename}" data-bodyname="${body.name}" value="${defaultLabel}">
                            </div>
                        </div>`;
                    });
                }
                listHTML += `</div>`;
                fileGroupContainer.innerHTML = listHTML;
                rigidbodyListDiv.appendChild(fileGroupContainer);
            }

            function startAnalysis() {
                const travelAxis = travelAxisSelect.value;
                const verticalAxis = verticalAxisSelect.value;
                if (travelAxis === verticalAxis) {
                    alert('進行方向と鉛直方向は異なる軸を選択してください。');
                    return;
                }

                const motionDetectionSettings = {
                    multiplier: parseFloat(document.getElementById('motion-threshold-multiplier').value)
                };

                const selectedBodies = [];
                document.querySelectorAll('.rigidbody-checkbox:checked').forEach(cb => {
                    const filename = cb.dataset.filename;
                    const bodyName = cb.dataset.bodyname;
                    const labelInput = document.querySelector(`.legend-label-input[data-filename="${filename}"][data-bodyname="${bodyName}"]`);
                    const label = labelInput ? labelInput.value : `${filename} - ${bodyName}`;
                    selectedBodies.push({ filename, bodyName, label });
                });
                if (selectedBodies.length === 0) {
                    alert('解析する剛体を少なくとも1つ選択してください。');
                    return;
                }
                loadingText.textContent = '解析中...';
                loadingDiv.classList.remove('hidden');
                resultsSection.classList.add('hidden');
                setTimeout(() => {
                    try {
                        lastProcessedData = processAllBodies(selectedBodies, travelAxis, verticalAxis, motionDetectionSettings);
                        displayResults(lastProcessedData);
                        renderAllCharts(lastProcessedData, travelAxis, verticalAxis);
                        resultsSection.classList.remove('hidden');
                        setTimeout(() => resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
                    } catch (error) {
                        alert("解析エラー:", error);
                        alert(`解析中にエラーが発生しました: ${error.message}`);
                    } finally {
                        loadingDiv.classList.add('hidden');
                    }
                }, 50);
            }

            function recalculateAverages() {
                const useFilter = filterVelocityCheckbox.checked;
                const lowerBound = parseFloat(document.getElementById('filter-lower-bound').value);
                const upperBound = parseFloat(document.getElementById('filter-upper-bound').value);

                if (useFilter && (isNaN(lowerBound) || isNaN(upperBound))) {
                    alert('有効な除外範囲を入力してください。');
                    return;
                }

                const updatedData = lastProcessedData.map(bodyData => {
                    let newAvgVelocity;
                    if (useFilter) {
                        let filteredDistance = 0;
                        let filteredTime = 0;
                        for (let i = 1; i < bodyData.data.length; i++) {
                            const vel = bodyData.data[i].instVelocity;
                            if (vel < lowerBound || vel > upperBound) {
                                filteredDistance += (bodyData.data[i].distance - bodyData.data[i - 1].distance);
                                filteredTime += (bodyData.data[i].time - bodyData.data[i - 1].time);
                            }
                        }
                        newAvgVelocity = filteredTime > 0 ? filteredDistance / filteredTime : 0;
                    } else {
                        const totalTime = bodyData.data[bodyData.data.length - 1].time;
                        const totalDistance = bodyData.data[bodyData.data.length - 1].distance;
                        newAvgVelocity = totalTime > 0 ? totalDistance / totalTime : 0;
                    }

                    let newAvgSlipRate = 0;
                    const u = bodyData.referenceSpeed;
                    const v = newAvgVelocity;
                    if (u > 0 && v >= 0) {
                        newAvgSlipRate = (u > v) ? (1 - (v / u)) * 100 : (1 - (u / v)) * 100;
                    }

                    return { ...bodyData, avgVelocity: newAvgVelocity, avgSlipRate: newAvgSlipRate };
                });

                displayResults(updatedData);
            }

            function processAllBodies(selectedBodies, travelAxis, verticalAxis, motionDetectionSettings) {
                allInstantaneousVelocities = [];
                return selectedBodies.map(selection => {
                    const { filename, bodyName, label } = selection;
                    const body = fileDataStore[filename].rigidBodies.find(b => b.name === bodyName);
                    const referenceSpeedInput = document.querySelector(`input[data-filename="${filename}"]`);
                    if (!referenceSpeedInput) throw new Error(`基準速度の入力が見つかりません: ${filename}`);
                    const referenceSpeed = parseFloat(referenceSpeedInput.value);

                    if (!body || isNaN(referenceSpeed)) throw new Error(`データまたは基準速度が見つかりません: ${filename} - ${bodyName}`);

                    const motionRange = findMotionRange(body.data, travelAxis, motionDetectionSettings);
                    if (!motionRange) {
                        console.warn(`${label} の有効な動作が見つかりませんでした。スキップします。`);
                        return null;
                    }

                    let workingData = body.data.slice(motionRange.start, motionRange.end);
                    if (workingData.length < 2) return null;

                    const startTime = workingData[0].time;
                    const initialPos = workingData[0].pos;
                    const horizontalAxes = ['X', 'Y', 'Z'].filter(ax => ax !== verticalAxis);

                    workingData.forEach((d, i) => {
                        d.time = d.time - startTime;
                        const d_h1 = d.pos[horizontalAxes[0]] - initialPos[horizontalAxes[0]];
                        const d_h2 = d.pos[horizontalAxes[1]] - initialPos[horizontalAxes[1]];
                        d.distance = Math.sqrt(d_h1 ** 2 + d_h2 ** 2);
                        d.verticalDisp = d.pos[verticalAxis] - initialPos[verticalAxis];

                        const chartXAxisName = travelAxis;
                        const chartYAxisName = horizontalAxes.find(ax => ax !== travelAxis);
                        d.trajectory_x = d.pos[chartXAxisName] - initialPos[chartXAxisName];
                        d.trajectory_y = d.pos[chartYAxisName] - initialPos[chartYAxisName];

                        if (i === 0) { d.instVelocity = 0; } else {
                            const dt = d.time - workingData[i - 1].time;
                            const dd = d.distance - workingData[i - 1].distance;
                            d.instVelocity = dt > 0 ? dd / dt : 0;
                        }
                        const u = referenceSpeed, v = d.instVelocity;
                        if (u > 0 && v >= 0) d.slipRate = (u > v) ? (1 - (v / u)) * 100 : (1 - (u / v)) * 100;
                        else d.slipRate = 0;
                    });

                    const totalTime = workingData[workingData.length - 1].time;
                    const totalDistance = workingData[workingData.length - 1].distance;
                    const avgVelocity = totalTime > 0 ? totalDistance / totalTime : 0;

                    let avgSlipRate = 0;
                    if (referenceSpeed > 0 && avgVelocity >= 0) {
                        avgSlipRate = (referenceSpeed > avgVelocity) ? (1 - (avgVelocity / referenceSpeed)) * 100 : (1 - (referenceSpeed / avgVelocity)) * 100;
                    }

                    const n = workingData.length;
                    let velocitySampleVariance = 0, velocityUnbiasedVariance = 0;
                    if (n > 1) {
                        const velocityValues = workingData.map(d => d.instVelocity);
                        const meanVel = velocityValues.reduce((a, b) => a + b, 0) / n;
                        const sumOfSquares = velocityValues.map(v => (v - meanVel) ** 2).reduce((a, b) => a + b, 0);
                        velocitySampleVariance = sumOfSquares / n;
                        velocityUnbiasedVariance = sumOfSquares / (n - 1);
                    }

                    let slipRateSampleVariance = 0, slipRateUnbiasedVariance = 0;
                    const slipRateValues = workingData.map(d => d.slipRate).filter(sr => sr !== undefined && !isNaN(sr));
                    const m = slipRateValues.length;
                    if (m > 1) {
                        const meanSlip = slipRateValues.reduce((a, b) => a + b, 0) / m;
                        const sumOfSquares = slipRateValues.map(s => (s - meanSlip) ** 2).reduce((a, b) => a + b, 0);
                        slipRateSampleVariance = sumOfSquares / m;
                        slipRateUnbiasedVariance = sumOfSquares / (m - 1);
                    }

                    workingData.forEach(d => {
                        allInstantaneousVelocities.push({
                            "ファイル名": filename, "剛体名": bodyName, "凡例名": label, "時間 (s)": d.time.toFixed(3),
                            "距離 (m)": d.distance.toFixed(4), "微小速度 (m/s)": d.instVelocity.toFixed(4),
                            "スリップ率 (%)": d.slipRate.toFixed(2), "鉛直変位 (m)": d.verticalDisp.toFixed(4),
                        });
                    });
                    return { name: label, data: workingData, avgVelocity, avgSlipRate, velocitySampleVariance, velocityUnbiasedVariance, slipRateSampleVariance, slipRateUnbiasedVariance, referenceSpeed };
                }).filter(d => d !== null);
            }

            function findMotionRange(data, travelAxis, settings) {
                const pos = data.map(d => d.pos[travelAxis]);
                if (pos.length < 20) return { start: 0, end: pos.length };

                const overallMax = Math.max(...pos);
                const overallMin = Math.min(...pos);
                const overallRange = overallMax - overallMin;
                if (overallRange === 0) return null;

                const margin = overallRange * settings.multiplier;

                const initialValue = pos[0];
                const startLowerBound = initialValue - margin;
                const startUpperBound = initialValue + margin;
                let startIndex = 0;
                for (let i = 1; i < pos.length; i++) {
                    if (pos[i] < startLowerBound || pos[i] > startUpperBound) {
                        startIndex = i;
                        break;
                    }
                }
                if (startIndex === 0) { console.warn("動作開始が検出できませんでした。"); return null; }

                const finalValue = pos[pos.length - 1];
                const endLowerBound = finalValue - margin;
                const endUpperBound = finalValue + margin;

                let endIndex = pos.length;
                for (let i = pos.length - 1; i >= startIndex; i--) {
                    if (pos[i] < endLowerBound || pos[i] > endUpperBound) {
                        endIndex = i + 1;
                        break;
                    }
                }

                if (startIndex >= endIndex) { console.warn("有効な動作区間が見つかりませんでした (開始点が終了点以降)。"); return null; }
                return { start: startIndex, end: endIndex };
            }

            function displayResults(processedData) {
                const container = document.getElementById('average-velocities');
                container.innerHTML = '<h3 class="text-md font-semibold mb-3 text-slate-800">平均値・分散</h3>';
                const list = document.createElement('div');
                list.className = 'space-y-3';
                processedData.forEach(result => {
                    const item = document.createElement('div');
                    item.className = 'p-3 bg-slate-50/70 rounded-md border';
                    item.innerHTML = `
                        <div class="font-semibold text-sm text-blue-700">${result.name}</div>
                        <div class="mt-2 pl-2 text-sm text-slate-700 space-y-1">
                            <div>
                                平均速度: <span class="font-medium">${result.avgVelocity.toFixed(3)} m/s</span>
                                <span class="text-xs text-slate-500 ml-2">(標本分散 σ²: ${result.velocitySampleVariance.toFixed(5)} | 不偏分散 u²: ${result.velocityUnbiasedVariance.toFixed(5)})</span>
                            </div>
                            <div>
                                平均スリップ率: <span class="font-medium">${result.avgSlipRate.toFixed(2)} %</span>
                                 <span class="text-xs text-slate-500 ml-2">(標本分散 σ²: ${result.slipRateSampleVariance.toFixed(3)} | 不偏分散 u²: ${result.slipRateUnbiasedVariance.toFixed(3)})</span>
                            </div>
                        </div>
                         <div class="mt-2 pl-2 text-xs text-slate-500">(基準速度: ${result.referenceSpeed} m/s)</div>
                    `;
                    list.appendChild(item);
                });
                container.appendChild(list);
            }

            function renderAllCharts(processedData, travelAxis, verticalAxis) {
                Object.values(chartInstances).forEach(chart => { if (chart && chart.destroy) chart.destroy() });

                const filterType = lowpassFilterTypeSelect ? lowpassFilterTypeSelect.value : 'none';
                const filterStrength = lowpassStrengthInput ? parseFloat(lowpassStrengthInput.value) : 0;
                const isFiltered = filterType !== 'none';

                const horizontalAxes = ['X', 'Y', 'Z'].filter(ax => ax !== verticalAxis);
                const trajectoryYAxisName = horizontalAxes.find(ax => ax !== travelAxis);

                const initialLabels = {
                    'velocity': { id: 'velocity-chart', title: '速度 vs 距離', x: '距離 (m)', y: '速度 (m/s)' },
                    'slip': { id: 'slip-chart', title: 'スリップ率 vs 距離', x: '距離 (m)', y: 'スリップ率 (%)' },
                    'vertical': { id: 'vertical-chart', title: '鉛直変位 vs 距離', x: '距離 (m)', y: `鉛直変位 (${verticalAxis}軸) (m)` },
                    'trajectory': { id: 'trajectory-chart', title: '平面移動軌跡', x: `${travelAxis}軸 変位 (m)`, y: `${trajectoryYAxisName}軸 変位 (m)` }
                };

                const labelMapping = { 'v': 'velocity', 's': 'slip', 'z': 'vertical', 't': 'trajectory' };
                const prefixMapping = { 'velocity': 'v', 'slip': 's', 'vertical': 'z', 'trajectory': 't' };

                for (const [prefix, fullKey] of Object.entries(labelMapping)) {
                    const labels = initialLabels[fullKey];
                    const finalTitle = isFiltered ? `${labels.title} (ローパス適用)` : labels.title;
                    document.getElementById(`${prefix}-chart-title`).value = finalTitle;
                    document.getElementById(`${prefix}-chart-xlabel`).value = labels.x;
                    document.getElementById(`${prefix}-chart-ylabel`).value = labels.y;
                }

                const colors = ['#10b981', '#ef4444', '#3b82f6', '#f59e0b', '#8b5cf6', '#f97316'];
                const pointStyles = ['circle', 'rect', 'cross', 'star', 'triangle', 'rectRot'];

                const datasets = processedData.map((result, index) => {
                    const color = colors[index % colors.length];
                    const style = pointStyles[index % pointStyles.length];
                    const base = {
                        label: result.name, borderColor: color, backgroundColor: color,
                        pointRadius: 3, pointStyle: style, showLine: true, tension: 0.1, borderWidth: 1.5
                    };

                    let velocityData = result.data.map(d => ({ x: d.distance, y: d.instVelocity }));
                    let slipData = result.data.map(d => ({ x: d.distance, y: d.slipRate }));
                    let verticalData = result.data.map(d => ({ x: d.distance, y: d.verticalDisp }));
                    const trajectoryData = result.data.map(d => ({ x: d.trajectory_x, y: d.trajectory_y }));

                    if (filterType === 'moving-average') {
                        velocityData = applyMovingAverageFilter(velocityData, filterStrength);
                        slipData = applyMovingAverageFilter(slipData, filterStrength);
                        verticalData = applyMovingAverageFilter(verticalData, filterStrength);
                    } else if (filterType === 'gaussian') {
                        velocityData = applyGaussianFilter(velocityData, filterStrength);
                        slipData = applyGaussianFilter(slipData, filterStrength);
                        verticalData = applyGaussianFilter(verticalData, filterStrength);
                    }

                    return {
                        velocity: { ...base, data: velocityData },
                        slip: { ...base, data: slipData },
                        vertical: { ...base, data: verticalData },
                        trajectory: { ...base, data: trajectoryData }
                    };
                });

                ['velocity', 'vertical'].forEach(key => {
                    const chartId = `${key}-chart`;
                    const chartData = datasets.map(d => d[key]);
                    const prefix = prefixMapping[key];
                    const title = document.getElementById(`${prefix}-chart-title`).value;
                    const xlabel = document.getElementById(`${prefix}-chart-xlabel`).value;
                    const ylabel = document.getElementById(`${prefix}-chart-ylabel`).value;
                    chartInstances[chartId] = new Chart(document.getElementById(chartId), {
                        type: 'scatter',
                        data: { datasets: chartData },
                        options: getChartOptions(ylabel, xlabel, title)
                    });
                });

                const slipChartId = 'slip-chart';
                const slipChartData = datasets.map(d => d.slip);
                const slipPrefix = prefixMapping['slip'];
                const slipTitle = document.getElementById(`${slipPrefix}-chart-title`).value;
                const slipXLabel = document.getElementById(`${slipPrefix}-chart-xlabel`).value;
                const slipYLabel = document.getElementById(`${slipPrefix}-chart-ylabel`).value;
                const slipChartOptions = getChartOptions(slipYLabel, slipXLabel, slipTitle);
                slipChartOptions.scales.y.min = 0;
                slipChartOptions.scales.y.max = 100;
                chartInstances[slipChartId] = new Chart(document.getElementById(slipChartId), {
                    type: 'scatter',
                    data: { datasets: slipChartData },
                    options: slipChartOptions
                });

                const trajectoryDatasets = datasets.map(d => d.trajectory);

                let minVal = Infinity, maxVal = -Infinity;
                trajectoryDatasets.forEach(dataset => {
                    dataset.data.forEach(point => {
                        minVal = Math.min(minVal, point.x, point.y);
                        maxVal = Math.max(maxVal, point.x, point.y);
                    });
                });
                const range = maxVal - minVal;
                const padding = range === 0 ? 1 : range * 0.1;
                const finalMin = minVal - padding;
                const finalMax = maxVal + padding;

                const trajectoryPrefix = prefixMapping['trajectory'];
                const trajectoryTitle = document.getElementById(`${trajectoryPrefix}-chart-title`).value;
                const trajectoryXLabel = document.getElementById(`${trajectoryPrefix}-chart-xlabel`).value;
                const trajectoryYLabel = document.getElementById(`${trajectoryPrefix}-chart-ylabel`).value;
                const trajectoryOptions = getChartOptions(trajectoryYLabel, trajectoryXLabel, trajectoryTitle);
                trajectoryOptions.scales.x.min = finalMin;
                trajectoryOptions.scales.x.max = finalMax;
                trajectoryOptions.scales.y.min = finalMin;
                trajectoryOptions.scales.y.max = finalMax;
                trajectoryOptions.aspectRatio = 1;

                chartInstances['trajectory-chart'] = new Chart(document.getElementById('trajectory-chart'), {
                    type: 'scatter',
                    data: { datasets: trajectoryDatasets },
                    options: trajectoryOptions
                });

                const currentStyle = document.querySelector('.style-btn.bg-blue-600');
                handleStyleChange({ target: currentStyle || document.getElementById('style-casual') });
            }

            function updateAllChartLabels() {
                const filterType = lowpassFilterTypeSelect.value;
                const isFiltered = filterType !== 'none';
                const suffix = isFiltered ? ' (ローパス適用)' : '';

                document.querySelectorAll('.chart-label-input').forEach(input => {
                    const chartId = input.dataset.chartId;
                    const labelType = input.dataset.labelType;
                    const chart = chartInstances[chartId];
                    if (!chart || !chart.options) return;

                    if (labelType === 'title') {
                        let baseTitle = input.value.replace(' (ローパス適用)', '');
                        chart.options.plugins.title.text = baseTitle + suffix;
                    }
                    if (labelType === 'x') chart.options.scales.x.title.text = input.value;
                    if (labelType === 'y') chart.options.scales.y.title.text = input.value;
                });
                Object.values(chartInstances).forEach(chart => chart.update('none'));
            }

            function getChartOptions(yLabel, xLabel, title) {
                return {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { title: { display: true, text: yLabel, font: { size: 13 } }, ticks: { font: { size: 12 } } },
                        x: { type: 'linear', position: 'bottom', title: { display: true, text: xLabel, font: { size: 13 } }, ticks: { font: { size: 12 } } }
                    },
                    plugins: {
                        legend: { position: 'top', labels: { usePointStyle: true, pointStyleWidth: 20, font: { size: 13 } } },
                        title: { display: true, text: title, font: { size: 16, weight: '600' } }
                    },
                    animation: { duration: 0 }
                };
            }

            function handleStyleChange(event) {
                if (!event || !event.target) return;
                const mode = event.target.id.includes('formal') ? 'formal' : 'casual';
                const casualBtn = document.getElementById('style-casual');
                const formalBtn = document.getElementById('style-formal');
                casualBtn.classList.toggle('bg-blue-600', mode === 'casual');
                casualBtn.classList.toggle('text-white', mode === 'casual');
                casualBtn.classList.toggle('bg-slate-200', mode === 'formal');
                casualBtn.classList.toggle('text-slate-700', mode === 'formal');
                formalBtn.classList.toggle('bg-blue-600', mode === 'formal');
                formalBtn.classList.toggle('text-white', mode === 'formal');
                formalBtn.classList.toggle('bg-slate-200', mode === 'casual');
                formalBtn.classList.toggle('text-slate-700', mode === 'casual');
                const isFormal = mode === 'formal';
                const formalStyles = { color: '#000', font: { weight: 'bold' } };
                const casualStyles = { color: '#334155', font: { weight: 'normal' } };
                const newStyles = isFormal ? formalStyles : casualStyles;

                Object.values(chartInstances).forEach(chart => {
                    if (!chart || !chart.options || !chart.options.plugins || !chart.options.scales) return;

                    chart.options.plugins.title.color = newStyles.color;
                    chart.options.plugins.title.font.weight = newStyles.font.weight;
                    chart.options.plugins.legend.labels.color = newStyles.color;
                    chart.options.scales.x.title.color = newStyles.color;
                    chart.options.scales.x.title.font.weight = newStyles.font.weight;
                    chart.options.scales.x.ticks.color = newStyles.color;
                    chart.options.scales.y.title.color = newStyles.color;
                    chart.options.scales.y.title.font.weight = newStyles.font.weight;
                    chart.options.scales.y.ticks.color = newStyles.color;

                    if (isFormal) {
                        chart.options.scales.x.grid.display = false;
                        chart.options.scales.y.grid.display = false;
                        chart.options.scales.x.border = { color: '#000', width: 2 };
                        chart.options.scales.y.border = { color: '#000', width: 2 };
                        chart.data.datasets.forEach(dataset => {
                            Object.assign(dataset, { borderColor: '#000', backgroundColor: 'rgba(0,0,0,0.1)', borderWidth: 1, pointRadius: 2.5 });
                        });
                    } else {
                        chart.options.scales.x.grid.display = true;
                        chart.options.scales.y.grid.display = true;
                        chart.options.scales.x.grid.color = '#e2e8f0';
                        chart.options.scales.y.grid.color = '#e2e8f0';
                        chart.options.scales.x.border = { color: '#cbd5e1' };
                        chart.options.scales.y.border = { color: '#cbd5e1' };

                        const colors = ['#10b981', '#ef4444', '#3b82f6', '#f59e0b', '#8b5cf6', '#f97316'];
                        chart.data.datasets.forEach((dataset, i) => {
                            const color = colors[i % colors.length];
                            Object.assign(dataset, { borderColor: color, backgroundColor: color, borderWidth: 1.5, pointRadius: 3 });
                        });
                    }
                    chart.update('none');
                });
            }

            function downloadVelocityCSV() {
                if (allInstantaneousVelocities.length === 0) {
                    alert('ダウンロードするデータがありません。');
                    return;
                }
                const csv = Papa.unparse(allInstantaneousVelocities);
                const blob = new Blob([`\uFEFF${csv}`], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.setAttribute('download', 'instantaneous_velocities.csv');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            async function handleDownload(chartId, format) {
                const chart = chartInstances[chartId];
                if (!chart) return;

                downloadOverlay.classList.remove('hidden');

                const exportWidth = document.getElementById('export-width').value;
                const exportHeight = document.getElementById('export-height').value;

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = exportWidth;
                tempCanvas.height = exportHeight;

                tempCanvas.style.position = 'absolute';
                tempCanvas.style.left = '-9999px';
                tempCanvas.style.top = '0px';
                document.body.appendChild(tempCanvas);

                const tempChart = new Chart(tempCanvas, {
                    type: chart.config.type,
                    data: chart.config.data,
                    options: { ...chart.config.options, animation: false, responsive: false, maintainAspectRatio: false }
                });

                await new Promise(resolve => setTimeout(resolve, 500));

                try {
                    const canvas = await html2canvas(tempCanvas, { backgroundColor: '#FFFFFF', scale: 2 });

                    if (format === 'png') {
                        const image = canvas.toDataURL('image/png', 1.0);
                        const link = document.createElement('a');
                        link.href = image;
                        link.download = `${chartId}.png`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    } else if (format === 'pdf') {
                        if (!window.jspdf || !window.jspdf.jsPDF) {
                            alert('PDF generation library (jsPDF) is not loaded.'); return;
                        }
                        const { jsPDF } = window.jspdf;
                        const pdf = new jsPDF({
                            orientation: canvas.width > canvas.height ? 'landscape' : 'portrait',
                            unit: 'px',
                            format: [canvas.width, canvas.height]
                        });
                        pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
                        pdf.save(`${chartId}.pdf`);
                    }
                } catch (e) {
                    alert("Failed to generate download:", e);
                    alert("An error occurred during download. Please check the console.");
                } finally {
                    tempChart.destroy();
                    document.body.removeChild(tempCanvas);
                    downloadOverlay.classList.add('hidden');
                }
            }

            // --- STANDARD VELOCITY TOOL SCRIPT ---
            const fileInputStd = document.getElementById('csv-file-input-std');
            const fileNameDisplayStd = document.getElementById('file-name-display-std');
            const loadingIndicatorStd = document.getElementById('loading-indicator-std');
            const parametersSectionStd = document.getElementById('step-2-parameters-std');
            const resultsSectionStd = document.getElementById('step-3-results-std');
            const rigidbodyContainerStd = document.getElementById('rigidbody-radio-container-std');
            const radiusInputStd = document.getElementById('radius-input-std');
            const axisSelectStd = document.getElementById('axis-select-std');
            const calculateBtnStd = document.getElementById('calculate-btn-std');
            const resultDisplayStd = document.getElementById('result-display-std');
            const resultValueStd = document.getElementById('result-value-std');
            const copyBtnStd = document.getElementById('copy-btn-std');
            const errorDisplayStd = document.getElementById('error-display-std');

            let parsedCsvDataStd = null;

            if (fileInputStd) {
                fileInputStd.addEventListener('change', handleFileSelectStd);
                calculateBtnStd.addEventListener('click', handleCalculationStd);
                copyBtnStd.addEventListener('click', handleCopyStd);
            }

            function handleFileSelectStd(event) {
                const file = event.target.files[0];
                if (!file) return;

                fileNameDisplayStd.textContent = file.name;
                parametersSectionStd.classList.add('hidden');
                resultsSectionStd.classList.add('hidden');
                errorDisplayStd.classList.add('hidden');
                loadingIndicatorStd.classList.remove('hidden');

                Papa.parse(file, {
                    complete: (results) => {
                        try {
                            parseCsvAndSetupUIStd(results.data);
                        } catch (e) {
                            showErrorStd(`ファイル解析エラー: ${e.message}`);
                        } finally {
                            loadingIndicatorStd.classList.add('hidden');
                        }
                    },
                    error: (error) => {
                        showErrorStd(`CSVファイルの読み込みに失敗しました: ${error.message}`);
                        loadingIndicatorStd.classList.add('hidden');
                    }
                });
            }

            function parseCsvAndSetupUIStd(csvData) {
                let dataStartIndex = -1, propertyRowIndex = -1, nameRowIndex = -1, typeRowIndex = -1;

                for (let i = 0; i < Math.min(15, csvData.length); i++) {
                    if (csvData[i][0] === 'Frame' && csvData[i][1] === 'Time (Seconds)') dataStartIndex = i + 1;
                    if (csvData[i][2] === 'Rotation' || csvData[i][2] === 'Position') propertyRowIndex = i;
                    if (csvData[i][1] === 'Name') nameRowIndex = i;
                    if (csvData[i][1] === 'Type') typeRowIndex = i;
                }

                if (dataStartIndex === -1 || propertyRowIndex === -1 || nameRowIndex === -1 || typeRowIndex === -1) {
                    throw new Error("CSVのヘッダー形式がMotiveエクスポート形式と異なります。");
                }

                const headerInfo = { dataStartIndex, propertyRowIndex, nameRowIndex, typeRowIndex };
                const rigidBodies = extractRigidBodiesStd(csvData, headerInfo);
                if (Object.keys(rigidBodies).length === 0) {
                    throw new Error("ファイル内に有効な剛体(Rigid Body)データが見つかりませんでした。");
                }

                parsedCsvDataStd = {
                    headerInfo,
                    dataRows: csvData.slice(headerInfo.dataStartIndex),
                    rigidBodies
                };

                populateRigidBodyRadiosStd(Object.keys(rigidBodies));
                parametersSectionStd.classList.remove('hidden');
            }

            function extractRigidBodiesStd(csvData, headerInfo) {
                const rigidBodies = {};
                const typeRow = csvData[headerInfo.typeRowIndex];
                const nameRow = csvData[headerInfo.nameRowIndex];
                const propertyRow = csvData[headerInfo.propertyRowIndex];
                const dataHeaderRow = csvData[headerInfo.dataStartIndex - 1];

                for (let i = 2; i < typeRow.length; i++) {
                    if (typeRow[i] === 'Rigid Body' && propertyRow[i] === 'Rotation') {
                        const name = nameRow[i];
                        if (!rigidBodies[name]) {
                            rigidBodies[name] = { name: name, rotation: {} };
                        }
                        const axisName = dataHeaderRow[i];
                        rigidBodies[name].rotation[axisName] = i;
                    }
                }
                return rigidBodies;
            }

            function populateRigidBodyRadiosStd(bodyNames) {
                rigidbodyContainerStd.innerHTML = '';
                const keywords = ['wheel', 'tire'];
                let defaultIndex = 0;
                const firstMatchIndex = bodyNames.findIndex(name =>
                    keywords.some(keyword => name.toLowerCase().includes(keyword))
                );
                if (firstMatchIndex !== -1) { defaultIndex = firstMatchIndex; }
                bodyNames.forEach((name, index) => {
                    const id = `body-radio-std-${name.replace(/\s+/g, '-')}`;
                    const div = document.createElement('div');
                    div.className = 'flex items-center';
                    div.innerHTML = `
                        <input id="${id}" type="radio" value="${name}" name="rigidbody-select-std" class="rigidbody-radio-std h-4 w-4 text-blue-600 border-slate-300 focus:ring-blue-500" ${index === defaultIndex ? 'checked' : ''}>
                        <label for="${id}" class="ml-3 block text-sm text-slate-900">${name}</label>
                    `;
                    rigidbodyContainerStd.appendChild(div);
                });
            }

            function handleCalculationStd() {
                if (!parsedCsvDataStd) {
                    showErrorStd("先にファイルを解析してください。"); return;
                }
                resultsSectionStd.classList.add('hidden');
                resultDisplayStd.classList.add('hidden');
                errorDisplayStd.classList.add('hidden');

                const selectedRadio = document.querySelector('.rigidbody-radio-std:checked');
                if (!selectedRadio) {
                    showErrorStd("解析する剛体を選択してください。"); return;
                }
                const radiusCm = parseFloat(radiusInputStd.value);
                if (isNaN(radiusCm) || radiusCm <= 0) {
                    showErrorStd("半径には正の数値を入力してください。"); return;
                }
                const radiusM = radiusCm / 100.0;
                const selectedAxis = axisSelectStd.value;
                const selectedBodyName = selectedRadio.value;
                const rotationFormat = document.querySelector('input[name="rotation-format-std"]:checked').value;

                try {
                    const bodyInfo = parsedCsvDataStd.rigidBodies[selectedBodyName];
                    const timeData = [];
                    const angleData = [];

                    if (rotationFormat === 'quaternion') {
                        // Check if we have X, Y, Z, W
                        if (bodyInfo.rotation['X'] === undefined || bodyInfo.rotation['Y'] === undefined ||
                            bodyInfo.rotation['Z'] === undefined || bodyInfo.rotation['W'] === undefined) {
                            throw new Error("クウォータニオンデータ(X, Y, Z, W)が揃っていません。");
                        }

                        // We will use standard Euler order 'XYZ' for now, but really we just want the selected axis component.
                        // Assuming the user selected axis is the primary rotation axis.
                        // THREE.Euler order 'XYZ' -> rotates X, then Y, then Z.
                        // If selectedAxis is 'Y', we want the rotation around Y.
                        // However, decomposition depends on order.
                        // Let's assume standard 'XYZ' order is sufficient for simple wheel rotation.
                        // Or better, use an order where the selected axis is applied LAST to represent global rotation?
                        // Actually, for a single axis rotation, any valid order containing that axis should show the change.

                        const idxX = bodyInfo.rotation['X'];
                        const idxY = bodyInfo.rotation['Y'];
                        const idxZ = bodyInfo.rotation['Z'];
                        const idxW = bodyInfo.rotation['W'];

                        parsedCsvDataStd.dataRows.forEach(row => {
                            const t = parseFloat(row[1]);
                            const qx = parseFloat(row[idxX]);
                            const qy = parseFloat(row[idxY]);
                            const qz = parseFloat(row[idxZ]);
                            const qw = parseFloat(row[idxW]);

                            if (!isNaN(t) && !isNaN(qx) && !isNaN(qy) && !isNaN(qz) && !isNaN(qw)) {
                                timeData.push(t);
                                const q = new THREE.Quaternion(qx, qy, qz, qw);

                                // Select Euler order to avoid gimbal lock/clamping on the target axis.
                                // The middle axis in Tait-Bryan angles is often clamped to +/- 90 degrees.
                                // We ensure the selected axis is the first applied rotation (outermost in some conventions, or just consistent).
                                let eulerOrder = 'XYZ';
                                if (selectedAxis === 'Y') eulerOrder = 'YXZ';
                                else if (selectedAxis === 'Z') eulerOrder = 'ZXY';
                                else eulerOrder = 'XYZ'; // X is first

                                const euler = new THREE.Euler().setFromQuaternion(q, eulerOrder);

                                let angleVal = 0;
                                if (selectedAxis === 'X') angleVal = euler.x;
                                else if (selectedAxis === 'Y') angleVal = euler.y;
                                else if (selectedAxis === 'Z') angleVal = euler.z;

                                // Convert radians to degrees
                                angleData.push(angleVal * (180 / Math.PI));
                            }
                        });

                    } else {
                        // Euler (Degrees)
                        const rotationColumnIndex = bodyInfo.rotation[selectedAxis];
                        if (rotationColumnIndex === undefined) {
                            throw new Error(`選択された剛体に'${selectedAxis}'軸の回転データが存在しません。`);
                        }
                        parsedCsvDataStd.dataRows.forEach(row => {
                            const t = parseFloat(row[1]);
                            const a = parseFloat(row[rotationColumnIndex]);
                            if (!isNaN(t) && !isNaN(a)) {
                                timeData.push(t);
                                angleData.push(a);
                            }
                        });
                    }

                    if (timeData.length !== angleData.length || timeData.length < 2) {
                        throw new Error("有効な時間または角度データが不足しています。");
                    }

                    const unwrappedAngles = unwrapAnglesStd(angleData);
                    const period = findRotationPeriodStd(timeData, unwrappedAngles);

                    if (period === null) {
                        throw new Error("データ内で1回転以上の回転を検出できませんでした。回転軸の選択が間違っているか、データに乱れがある可能性があります。");
                    }
                    const omega = (2 * Math.PI) / period;
                    const velocity = radiusM * omega;
                    const velocityStr = velocity.toFixed(8);

                    resultValueStd.textContent = velocityStr;
                    copyBtnStd.dataset.copyValue = velocityStr;
                    resultDisplayStd.classList.remove('hidden');
                    resultsSectionStd.classList.remove('hidden');
                    setTimeout(() => resultsSectionStd.scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);

                } catch (e) {
                    showErrorStd(`[${selectedBodyName}] ${e.message}`);
                }
            }

            function unwrapAnglesStd(angles) {
                const unwrapped = [angles[0]];
                let offset = 0;
                for (let i = 1; i < angles.length; i++) {
                    const diff = angles[i] - angles[i - 1];
                    if (diff > 180) { offset -= 360; }
                    else if (diff < -180) { offset += 360; }
                    unwrapped.push(angles[i] + offset);
                }
                return unwrapped;
            }

            function findRotationPeriodStd(times, unwrappedAngles) {
                let currentIndex = 0;

                // Try to find a valid rotation period by searching through the data
                while (currentIndex < unwrappedAngles.length - 10) {
                    // 1. Find start of motion relative to currentIndex
                    let motionStartIndex = -1;
                    const baseAngle = unwrappedAngles[currentIndex];

                    for (let i = currentIndex + 1; i < unwrappedAngles.length; i++) {
                        if (Math.abs(unwrappedAngles[i] - baseAngle) > 5) {
                            motionStartIndex = i;
                            break;
                        }
                    }

                    if (motionStartIndex === -1) return null; // No more motion found

                    // 2. Check if this motion looks valid (not just noise)
                    const sampleEndIndex = Math.min(motionStartIndex + 20, unwrappedAngles.length - 1);
                    const angleChange = unwrappedAngles[sampleEndIndex] - unwrappedAngles[motionStartIndex];

                    // If movement is too slow or just noise, skip and try again
                    if (Math.abs(angleChange) < 5) {
                        currentIndex = motionStartIndex;
                        continue;
                    }

                    // 3. Try to find the end of a 360 degree rotation
                    const direction = Math.sign(angleChange);
                    const targetAngle = unwrappedAngles[motionStartIndex] + (360 * direction);
                    let endIndex = -1;

                    for (let i = motionStartIndex + 1; i < unwrappedAngles.length; i++) {
                        if ((direction > 0 && unwrappedAngles[i] >= targetAngle) ||
                            (direction < 0 && unwrappedAngles[i] <= targetAngle)) {
                            endIndex = i;
                            break;
                        }
                    }

                    if (endIndex !== -1) {
                        // Found a valid rotation! Calculate period.
                        const T_start = times[motionStartIndex];
                        const angle_before = unwrappedAngles[endIndex - 1];
                        const angle_after = unwrappedAngles[endIndex];
                        const time_before = times[endIndex - 1];
                        const time_after = times[endIndex];

                        if (angle_after === angle_before) return time_after - T_start;

                        const fraction = (targetAngle - angle_before) / (angle_after - angle_before);
                        const T_end = time_before + fraction * (time_after - time_before);
                        return T_end - T_start;
                    }

                    // If we didn't find a full rotation, advance search to try finding a new start point
                    // We advance slightly past the motion start to see if a valid rotation starts later
                    currentIndex = motionStartIndex + 1;
                }

                return null;
            }

            function handleCopyStd() {
                const textToCopy = copyBtnStd.dataset.copyValue;
                if (!textToCopy) return;

                const textArea = document.createElement('textarea');
                textArea.value = textToCopy;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    copyBtnStd.textContent = 'コピーしました！';
                    setTimeout(() => { copyBtnStd.textContent = '結果をコピー'; }, 2000);
                } catch (err) {
                    copyBtnStd.textContent = 'コピー失敗';
                }
                document.body.removeChild(textArea);
            }

            function showErrorStd(message) {
                errorDisplayStd.textContent = message;
                errorDisplayStd.classList.remove('hidden');
                resultsSectionStd.classList.remove('hidden');
                setTimeout(() => resultsSectionStd.scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
            }

            // --- WIDE AREA ANALYSIS TOOL SCRIPT (kiseki) ---
            const csvFileInputWide = document.getElementById('csv-files-wide');
            const fileListAreaWide = document.getElementById('file-list-area-wide');
            const clearFilesBtnWide = document.getElementById('clear-files-btn-wide');
            const samplingRateInputWide = document.getElementById('sampling-rate-wide');
            const gridSizeInputWide = document.getElementById('heatmap-grid-size-wide');
            const verticalAxisSelectWide = document.getElementById('vertical-axis-wide');
            const rigidbodySelectionAreaWide = document.getElementById('rigidbody-selection-area-wide');
            const rigidbodyListContainerWide = document.getElementById('rigidbody-list-container-wide');
            const analyzeBtnWide = document.getElementById('analyze-btn-wide');
            const resultsCardWide = document.getElementById('results-card-wide');

            const showTrajectoryBtnWide = document.getElementById('show-trajectory-btn-wide');
            const showHeatmapBtnWide = document.getElementById('show-heatmap-btn-wide');
            const show3DTrajectoryBtnWide = document.getElementById('show-3d-trajectory-btn-wide');
            const trajectoryViewWide = document.getElementById('trajectory-view-wide');
            const heatmapViewWide = document.getElementById('heatmap-view-wide');
            const trajectory3DViewWide = document.getElementById('trajectory-3d-view-wide');
            const heatmapMaxValueWide = document.getElementById('heatmap-max-value-wide');

            const calculateCoverageBtnWide = document.getElementById('calculate-coverage-btn-wide');
            const coverageResultElWide = document.getElementById('coverage-result-wide');
            const areaShapeRadiosWide = document.querySelectorAll('input[name="area-shape-wide"]');
            const centerTypeRadiosWide = document.querySelectorAll('input[name="center-type-wide"]');
            const customCenterInputsWide = document.getElementById('custom-center-inputs-wide');
            const areaSizeLabelWide = document.getElementById('area-size-label-wide');
            const areaSizeInputWide = document.getElementById('area-size-wide');
            const centerXInputWide = document.getElementById('center-x-wide');
            const centerYInputWide = document.getElementById('center-y-wide');
            const centerXLabelWide = document.getElementById('center-x-label-wide');
            const centerYLabelWide = document.getElementById('center-y-label-wide');
            const dataUnitRadiosWide = document.querySelectorAll('input[name="data-unit-wide"]');
            const unitLabels = document.querySelectorAll('.unit-label');
            const coordinateUnitNote = document.getElementById('coordinate-unit-note');

            let trajectoryChartWide = null;
            let fileDataStoreWide = {};
            let lastSampledDataWide = null;
            let lastHeatmapGridWide = null;
            let is3DTrajectoryRendered = false;
            const heatmapTooltip = document.getElementById('heatmap-tooltip');
            const heatmapCanvas = document.getElementById('heatmap-canvas-wide');
            const heightInfoCheckboxWide = document.getElementById('height-info-checkbox-wide');

            heightInfoCheckboxWide.addEventListener('change', () => {
                if (lastSampledDataWide) {
                    const verticalAxis = verticalAxisSelectWide.value;
                    const axes = ['X', 'Y', 'Z'];
                    const horizontalAxes = axes.filter(ax => ax !== verticalAxis);
                    drawTrajectoryWide(lastSampledDataWide, horizontalAxes[0], horizontalAxes[1]);
                }
            });

            heatmapCanvas.addEventListener('mousemove', (event) => {
                if (!lastHeatmapGridWide || !lastHeatmapGridWide.gridInfo) return;

                const rect = heatmapCanvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                const { grid, gridInfo } = lastHeatmapGridWide;
                const { rows, cols } = gridInfo;
                const cellWidth = heatmapCanvas.width / cols;
                const cellHeight = heatmapCanvas.height / rows;

                const col = Math.floor(x / cellWidth);
                const row = rows - 1 - Math.floor(y / cellHeight);

                if (col >= 0 && col < cols && row >= 0 && row < rows) {
                    const count = grid[row][col];
                    heatmapTooltip.textContent = `カウント: ${count}`;
                    heatmapTooltip.style.left = `${event.clientX - rect.left + 10}px`;
                    heatmapTooltip.style.top = `${event.clientY - rect.top + 10}px`;
                    heatmapTooltip.classList.remove('hidden');
                } else {
                    heatmapTooltip.classList.add('hidden');
                }
            });

            heatmapCanvas.addEventListener('mouseout', () => {
                heatmapTooltip.classList.add('hidden');
            });

            csvFileInputWide.addEventListener('change', handleFileSelectWide);
            clearFilesBtnWide.addEventListener('click', clearAllFilesWide);
            analyzeBtnWide.addEventListener('click', analyzeDataWide);
            showTrajectoryBtnWide.addEventListener('click', () => switchViewWide('trajectory'));
            showHeatmapBtnWide.addEventListener('click', () => switchViewWide('heatmap'));
            show3DTrajectoryBtnWide.addEventListener('click', () => switchViewWide('3d-trajectory'));
            document.querySelectorAll('.download-btn-wide').forEach(btn => btn.addEventListener('click', handleDownloadWide));

            calculateCoverageBtnWide.addEventListener('click', calculateAndDisplayCoverageWide);
            areaShapeRadiosWide.forEach(radio => radio.addEventListener('change', (e) => {
                areaSizeLabelWide.textContent = e.target.value === 'circle' ? '半径' : '一辺の長さ';
            }));
            centerTypeRadiosWide.forEach(radio => radio.addEventListener('change', (e) => {
                customCenterInputsWide.classList.toggle('hidden', e.target.value === 'data');
            }));

            dataUnitRadiosWide.forEach(radio => radio.addEventListener('change', (e) => {
                const selectedUnit = e.target.value;
                unitLabels.forEach(label => label.textContent = selectedUnit);

                const gridSizeInput = document.getElementById('heatmap-grid-size-wide');
                const areaSizeInput = document.getElementById('area-size-wide');

                if (selectedUnit === 'm') {
                    gridSizeInput.value = (parseFloat(gridSizeInput.value) / 1000).toFixed(2);
                    gridSizeInput.step = 0.1;
                    areaSizeInput.value = (parseFloat(areaSizeInput.value) / 1000).toFixed(2);
                    areaSizeInput.step = 0.1;
                    coordinateUnitNote.textContent = "※ 座標は正規化せず、元データの値をそのまま使用しています。";
                } else { // mm
                    gridSizeInput.value = Math.round(parseFloat(gridSizeInput.value) * 1000);
                    gridSizeInput.step = 100;
                    areaSizeInput.value = Math.round(parseFloat(areaSizeInput.value) * 1000);
                    areaSizeInput.step = 100;
                    coordinateUnitNote.textContent = "※ 座標は正規化せず、元データの値をメートル単位に変換して使用しています。";
                }
            }));

            function handleFileSelectWide(event) {
                const files = Array.from(event.target.files);
                if (files.length === 0) return;

                loadingDiv.classList.remove('hidden');
                loadingText.textContent = "ファイルを読み込み中...";

                const filePromises = files.map(file => {
                    if (fileDataStoreWide[file.name]) {
                        console.log(`File ${file.name} is already loaded.`);
                        return Promise.resolve();
                    }
                    return new Promise((resolve, reject) => {
                        Papa.parse(file, {
                            complete: (results) => {
                                try {
                                    const { rigidBodyInfo, rawData: processedData } = parseHeaderWide(results.data);
                                    fileDataStoreWide[file.name] = {
                                        rawData: processedData,
                                        rigidBodyInfo: rigidBodyInfo
                                    };
                                    resolve();
                                } catch (error) {
                                    reject(new Error(`"${file.name}"の解析に失敗: ${error.message}`));
                                }
                            },
                            error: (err) => reject(new Error(`"${file.name}"の読み込みに失敗: ${err.message}`))
                        });
                    });
                });

                Promise.all(filePromises)
                    .then(() => {
                        updateFileAndRigidBodyUIWide();
                        analyzeBtnWide.disabled = false;
                    })
                    .catch(error => {
                        alert(error.message);
                    })
                    .finally(() => {
                        loadingDiv.classList.add('hidden');
                        csvFileInputWide.value = '';
                    });
            }

            function parseHeaderWide(data) {
                let typeRowIndex = -1, nameRowIndex = -1, propertyRowIndex = -1, dataHeaderRowIndex = -1;
                for (let i = 0; i < Math.min(20, data.length); i++) {
                    const row = data[i];
                    if (!row || row.length < 2) continue;
                    if (row[1] === 'Type') typeRowIndex = i;
                    if (row[1] === 'Name') nameRowIndex = i;
                    if (row.includes('Position') && row.includes('Rotation')) propertyRowIndex = i;
                    if (row[0] === 'Frame' && row[1] === 'Time (Seconds)') {
                        dataHeaderRowIndex = i;
                        break;
                    }
                }
                if ([typeRowIndex, nameRowIndex, propertyRowIndex, dataHeaderRowIndex].includes(-1)) {
                    throw new Error("OptiTrack CSVのヘッダー形式を認識できませんでした。");
                }

                const typeRow = data[typeRowIndex];
                const nameRow = data[nameRowIndex];
                const propertyRow = data[propertyRowIndex];
                const dataHeaderRow = data[dataHeaderRowIndex];
                const dataStartIndex = dataHeaderRowIndex + 1;

                let rigidBodyInfo = {};
                for (let i = 2; i < typeRow.length; i++) {
                    if (typeRow[i] === 'Rigid Body' && propertyRow[i] === 'Position') {
                        const name = nameRow[i];
                        if (rigidBodyInfo[name]) continue;
                        rigidBodyInfo[name] = { name: name, xIndex: -1, yIndex: -1, zIndex: -1 };
                        for (let j = 0; j < 3; j++) {
                            const colIndex = i + j;
                            if (colIndex >= dataHeaderRow.length || nameRow[colIndex] !== name || propertyRow[colIndex] !== 'Position') break;
                            const axis = dataHeaderRow[colIndex].toUpperCase();
                            if (axis === 'X') rigidBodyInfo[name].xIndex = colIndex;
                            else if (axis === 'Y') rigidBodyInfo[name].yIndex = colIndex;
                            else if (axis === 'Z') rigidBodyInfo[name].zIndex = colIndex;
                        }
                    }
                }

                Object.keys(rigidBodyInfo).forEach(name => {
                    const info = rigidBodyInfo[name];
                    if (info.xIndex === -1 || info.yIndex === -1 || info.zIndex === -1) {
                        console.warn(`剛体 "${name}" の座標(X,Y,Z)の一部が見つかりませんでした。この剛体は無視されます。`);
                        delete rigidBodyInfo[name];
                    }
                });

                const rawData = data.slice(dataStartIndex).filter(row => row.length > 1 && row[1] !== '');
                return { rigidBodyInfo, rawData };
            }

            function updateFileAndRigidBodyUIWide() {
                fileListAreaWide.innerHTML = Object.keys(fileDataStoreWide).map(filename =>
                    `<div class="bg-slate-50 p-2.5 rounded-md border text-sm flex justify-between items-center">
                        <span class="text-slate-700 truncate pr-4">${filename}</span>
                    </div>`
                ).join('');

                rigidbodyListContainerWide.innerHTML = Object.keys(fileDataStoreWide).map(filename => {
                    const info = fileDataStoreWide[filename];
                    if (Object.keys(info.rigidBodyInfo).length === 0) return '';
                    return `
                        <div>
                            <h4 class="font-semibold text-sm text-slate-800 mb-2 border-b pb-1">${filename}</h4>
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-y-2 gap-x-4">
                                ${Object.keys(info.rigidBodyInfo).map(name => `
                                    <div class="rigidbody-item-container-wide">
                                        <label class="flex items-center space-x-2 p-2 rounded-md hover:bg-slate-100 cursor-pointer w-full">
                                            <input type="checkbox" class="rigidbody-checkbox-wide form-checkbox h-4 w-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500" data-filename="${filename}" value="${name}" checked>
                                            <span class="text-slate-800 text-sm">${name}</span>
                                        </label>
                                        <div class="legend-input-container-wide pl-7 mt-1 hidden">
                                            <label class="text-xs text-slate-500">凡例名:</label>
                                            <input type="text" class="legend-label-input-wide mt-1 block w-full rounded-md shadow-sm p-1.5 text-sm border-slate-300 focus:ring-1 focus:ring-blue-500" data-filename="${filename}" data-bodyname="${name}" value="${filename} - ${name}">
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }).join('');

                rigidbodyListContainerWide.addEventListener('change', (event) => {
                    if (event.target.classList.contains('rigidbody-checkbox-wide')) {
                        const checkbox = event.target;
                        const itemContainer = checkbox.closest('.rigidbody-item-container-wide');
                        const legendInputContainer = itemContainer.querySelector('.legend-input-container-wide');
                        if (legendInputContainer) {
                            legendInputContainer.classList.toggle('hidden', !checkbox.checked);
                        }
                    }
                });

                document.querySelectorAll('.rigidbody-checkbox-wide:checked').forEach(checkbox => {
                    const itemContainer = checkbox.closest('.rigidbody-item-container-wide');
                    const legendInputContainer = itemContainer.querySelector('.legend-input-container-wide');
                    if (legendInputContainer) {
                        legendInputContainer.classList.remove('hidden');
                    }
                });

                rigidbodySelectionAreaWide.classList.toggle('hidden', Object.keys(fileDataStoreWide).length === 0);
                clearFilesBtnWide.classList.toggle('hidden', Object.keys(fileDataStoreWide).length === 0);
            }

            function clearAllFilesWide() {
                fileDataStoreWide = {};
                csvFileInputWide.value = '';
                updateFileAndRigidBodyUIWide();
                resultsCardWide.classList.add('hidden');
                analyzeBtnWide.disabled = true;
            }

            function analyzeDataWide() {
                const verticalAxis = verticalAxisSelectWide.value;
                const dataUnit = document.querySelector('input[name="data-unit-wide"]:checked').value;
                const selectedBodies = Array.from(document.querySelectorAll('.rigidbody-checkbox-wide:checked')).map(cb => {
                    const filename = cb.dataset.filename;
                    const bodyName = cb.value;
                    const legendInput = document.querySelector(`.legend-label-input-wide[data-filename="${filename}"][data-bodyname="${bodyName}"]`);
                    return {
                        filename: filename,
                        bodyName: bodyName,
                        label: legendInput ? legendInput.value : `${filename} - ${bodyName}`
                    };
                });

                if (selectedBodies.length === 0) { alert('解析する剛体を少なくとも1つ選択してください。'); return; }
                const samplingRate = parseFloat(samplingRateInputWide.value);
                if (isNaN(samplingRate) || samplingRate <= 0) { alert('データ取得間隔には正の数値を入力してください。'); return; }
                let gridSize = parseFloat(gridSizeInputWide.value);
                if (isNaN(gridSize) || gridSize <= 0) { alert('マス目のサイズには正の数値を入力してください。'); return; }

                if (dataUnit === 'mm') {
                    gridSize /= 1000;
                }

                loadingDiv.classList.remove('hidden');
                loadingText.textContent = "解析中...";
                is3DTrajectoryRendered = false; // Reset render flag

                setTimeout(() => {
                    try {
                        const axes = ['X', 'Y', 'Z'];
                        const horizontalAxes = axes.filter(ax => ax !== verticalAxis);
                        const hAxis1 = horizontalAxes[0];
                        const hAxis2 = horizontalAxes[1];

                        lastSampledDataWide = sampleAllDataWide(selectedBodies, samplingRate, dataUnit);
                        drawTrajectoryWide(lastSampledDataWide, hAxis1, hAxis2);
                        // Defer 3D trajectory drawing until the tab is clicked
                        // draw3DTrajectory(lastSampledDataWide);
                        lastHeatmapGridWide = calculateHeatmapGridWide(lastSampledDataWide, gridSize, hAxis1, hAxis2);
                        heatmapMaxValueWide.textContent = lastHeatmapGridWide.maxCount;

                        const allPoints = [].concat(...Object.values(lastSampledDataWide));
                        const dataCenter = calculateDataCenterWide(allPoints);

                        if (dataUnit === 'mm') {
                            centerXInputWide.value = (dataCenter.x * 1000).toFixed(2);
                            centerYInputWide.value = (dataCenter.y * 1000).toFixed(2);
                        } else {
                            centerXInputWide.value = dataCenter.x.toFixed(2);
                            centerYInputWide.value = dataCenter.y.toFixed(2);
                        }

                        centerXLabelWide.textContent = `${hAxis1}:`;
                        centerYLabelWide.textContent = `${hAxis2}:`;

                        resultsCardWide.classList.remove('hidden');
                        switchViewWide('trajectory');
                        setTimeout(() => resultsCardWide.scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
                    } catch (error) {
                        alert(`解析エラー: ${error.message}`);
                    } finally {
                        loadingDiv.classList.add('hidden');
                    }
                }, 50);
            }

            function sampleAllDataWide(selectedBodies, samplingRate, dataUnit) {
                const result = {};
                selectedBodies.forEach(({ filename, bodyName, label }) => {
                    const uniqueKey = label;
                    result[uniqueKey] = [];
                    const { rawData, rigidBodyInfo } = fileDataStoreWide[filename];
                    const info = rigidBodyInfo[bodyName];
                    if (!info) return;

                    let nextSampleTime = 0;
                    for (const row of rawData) {
                        const time = parseFloat(row[1]);
                        if (isNaN(time)) continue;

                        if (time >= nextSampleTime) {
                            let x = parseFloat(row[info.xIndex]);
                            let y = parseFloat(row[info.yIndex]);
                            let z = parseFloat(row[info.zIndex]);

                            if (dataUnit === 'mm') {
                                x /= 1000;
                                y /= 1000;
                                z /= 1000;
                            }

                            if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                                result[uniqueKey].push({ t: time, x: x, y: y, z: z });
                            }
                            nextSampleTime += samplingRate;
                        }
                    }
                });
                return result;
            }

            function hexToRgb(hex) {
                let r = 0, g = 0, b = 0;
                if (hex.length == 4) {
                    r = "0x" + hex[1] + hex[1];
                    g = "0x" + hex[2] + hex[2];
                    b = "0x" + hex[3] + hex[3];
                } else if (hex.length == 7) {
                    r = "0x" + hex[1] + hex[2];
                    g = "0x" + hex[3] + hex[4];
                    b = "0x" + hex[5] + hex[6];
                }
                return { r: +r, g: +g, b: +b };
            }

            function rgbToHsl(r, g, b) {
                r /= 255, g /= 255, b /= 255;
                let max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;
                if (max == min) {
                    h = s = 0; // achromatic
                } else {
                    let d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return { h, s, l };
            }

            function hslToRgb(h, s, l) {
                let r, g, b;
                if (s == 0) {
                    r = g = b = l; // achromatic
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1 / 3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1 / 3);
                }
                return `rgb(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)})`;
            }

            function getColorForHeight(value, min, max, baseColorHex) {
                const { r, g, b } = hexToRgb(baseColorHex);
                const { h, s } = rgbToHsl(r, g, b);

                if (min === max) {
                    return hslToRgb(h, s, 0.2); // Return a dark shade if no height difference
                }

                const ratio = (value - min) / (max - min);
                const lightness = 0.2 + ratio * 0.65; // Interpolate lightness from 20% to 85%

                return hslToRgb(h, s, lightness);
            }

            function drawTrajectoryWide(data, hAxis1, hAxis2) {
                const ctx = document.getElementById('trajectory-chart-wide').getContext('2d');
                const colors = ['#3b82f6', '#ef4444', '#10b981', '#f97316', '#8b5cf6', '#f59e0b', '#14b8a6', '#ec4899', '#6929c4', '#1192e8', '#005d5d', '#9f1853', '#fa4d56', '#570408', '#198038', '#002d9c', '#ee538b', '#b28600', '#009d9a', '#012749'];
                if (trajectoryChartWide) trajectoryChartWide.destroy();

                const legendContainer = document.getElementById('height-legend-wide');
                const showHeightInfo = document.getElementById('height-info-checkbox-wide').checked;
                let minHeight = Infinity;
                let maxHeight = -Infinity;
                let uniqueColors = new Set();

                if (showHeightInfo) {
                    const verticalAxis = verticalAxisSelectWide.value.toLowerCase();
                    Object.values(data).forEach(points => {
                        points.forEach(p => {
                            const height = p[verticalAxis];
                            if (height < minHeight) minHeight = height;
                            if (height > maxHeight) maxHeight = height;
                        });
                    });
                }

                const datasets = Object.keys(data).map((uniqueKey, index) => {
                    const baseColor = colors[index % colors.length];
                    uniqueColors.add(baseColor);
                    const baseProps = {
                        label: uniqueKey,
                        data: data[uniqueKey].map(p => ({ x: p[hAxis1.toLowerCase()], y: -p[hAxis2.toLowerCase()] })),
                        showLine: !showHeightInfo,
                        tension: 0.1,
                        borderWidth: showHeightInfo ? 1 : 2,
                    };

                    if (showHeightInfo) {
                        const verticalAxis = verticalAxisSelectWide.value.toLowerCase();
                        const pointColors = data[uniqueKey].map(p => getColorForHeight(p[verticalAxis], minHeight, maxHeight, baseColor));
                        return {
                            ...baseProps,
                            backgroundColor: pointColors,
                            borderColor: pointColors,
                            pointRadius: 3,
                        };
                    } else {
                        return {
                            ...baseProps,
                            borderColor: baseColor,
                            backgroundColor: baseColor,
                            pointRadius: 2,
                        };
                    }
                });

                if (showHeightInfo) {
                    legendContainer.classList.remove('hidden');
                    document.getElementById('height-legend-min-wide').textContent = minHeight.toFixed(2);
                    document.getElementById('height-legend-max-wide').textContent = maxHeight.toFixed(2);
                    const gradientEl = document.getElementById('height-legend-gradient-wide');

                    // Use the color of the first series for the legend gradient
                    const firstColor = [...uniqueColors][0];
                    if (firstColor) {
                        const dark = getColorForHeight(minHeight, minHeight, maxHeight, firstColor);
                        const light = getColorForHeight(maxHeight, minHeight, maxHeight, firstColor);
                        gradientEl.style.background = `linear-gradient(to right, ${dark}, ${light})`;
                    } else {
                        // Fallback for safety
                        gradientEl.style.background = 'linear-gradient(to right, #666, #ccc)';
                    }
                } else {
                    legendContainer.classList.add('hidden');
                }

                const allPoints = [].concat(...datasets.map(d => d.data));
                let scales = {};
                if (allPoints.length > 0) {
                    const allX = allPoints.map(p => p.x), allY = allPoints.map(p => p.y);
                    const minX = Math.min(...allX), maxX = Math.max(...allX);
                    const minY = Math.min(...allY), maxY = Math.max(...allY);
                    const rangeX = maxX - minX, rangeY = maxY - minY;
                    const maxRange = Math.max(rangeX, rangeY, 0.1) * 1.1;
                    const midX = (minX + maxX) / 2, midY = (minY + maxY) / 2;
                    scales = {
                        x: { min: midX - maxRange / 2, max: midX + maxRange / 2, grid: { color: '#e2e8f0' }, title: { display: true, text: `${hAxis1}座標 (m)` } },
                        y: { min: midY - maxRange / 2, max: midY + maxRange / 2, grid: { color: '#e2e8f0' }, title: { display: true, text: `${hAxis2}座標 (m)` } }
                    };
                }
                trajectoryChartWide = new Chart(ctx, {
                    type: 'scatter', data: { datasets }, options: { responsive: true, maintainAspectRatio: true, plugins: { title: { display: true, text: '剛体の移動軌跡' }, legend: { display: !showHeightInfo, position: 'top' } }, scales: scales, aspectRatio: 1 }
                });
            }

            function draw3DTrajectory(data) {
                const container = document.getElementById('trajectory-3d-container-wide');
                if (!container) return;
                container.innerHTML = '';

                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf1f5f9);

                const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 10000);
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                container.appendChild(renderer.domElement);

                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;

                // Add lights to the scene
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 50);
                scene.add(directionalLight);

                const colors = ['#3b82f6', '#ef4444', '#10b981', '#f97316', '#8b5cf6', '#f59e0b', '#14b8a6', '#ec4899', '#6929c4', '#1192e8', '#005d5d', '#9f1853', '#fa4d56', '#570408', '#198038', '#002d9c', '#ee538b', '#b28600', '#009d9a', '#012749'];

                const allPoints = [].concat(...Object.values(data).map(arr => arr.map(p => new THREE.Vector3(p.x, p.y, p.z))));

                if (allPoints.length > 1) {
                    Object.values(data).forEach((pointsData, index) => {
                        const points = pointsData.map(p => new THREE.Vector3(p.x, p.y, p.z));
                        if (points.length < 2) return;

                        const curve = new THREE.CatmullRomCurve3(points);
                        const tubeGeometry = new THREE.TubeGeometry(curve, points.length * 2, 0.05, 8, false);
                        const tubeMaterial = new THREE.MeshStandardMaterial({
                            color: colors[index % colors.length],
                            metalness: 0.5,
                            roughness: 0.5
                        });
                        const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                        scene.add(tube);
                    });

                    const boundingBox = new THREE.Box3().setFromPoints(allPoints);
                    const center = new THREE.Vector3();
                    boundingBox.getCenter(center);
                    const size = new THREE.Vector3();
                    boundingBox.getSize(size);

                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180);
                    const cameraDistance = Math.abs(maxDim / (2 * Math.tan(fov / 2)));

                    const offset = cameraDistance * 1.2;
                    camera.position.set(center.x, center.y, center.z + Math.max(offset, 5));

                    camera.near = cameraDistance / 100;
                    camera.far = cameraDistance * 100;
                    camera.updateProjectionMatrix();

                    controls.target.copy(center);
                    controls.update();

                    const gridHelper = new THREE.GridHelper(Math.ceil(maxDim * 1.5) || 10, 20, 0xcccccc, 0xcccccc);
                    gridHelper.position.y = boundingBox.min.y;
                    scene.add(gridHelper);

                } else {
                    camera.position.set(0, 5, 10);
                    controls.target.set(0, 0, 0);
                    const gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xcccccc);
                    scene.add(gridHelper);
                }

                function animate() {
                    requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                }
                animate();

                const resizeObserver = new ResizeObserver(entries => {
                    if (entries.length === 0) return;
                    const { width, height } = entries[0].contentRect;
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                    renderer.setSize(width, height);
                });

                resizeObserver.observe(container);
            }

            function calculateHeatmapGridWide(data, gridSize, hAxis1, hAxis2) {
                const hAxis1Lower = hAxis1.toLowerCase();
                const hAxis2Lower = hAxis2.toLowerCase();
                const allPoints = [].concat(...Object.values(data));
                if (allPoints.length === 0) return { grid: [], maxCount: 0, gridInfo: null };

                const minX = Math.min(...allPoints.map(p => p[hAxis1Lower])), maxX = Math.max(...allPoints.map(p => p[hAxis1Lower]));
                const minY = Math.min(...allPoints.map(p => -p[hAxis2Lower])), maxY = Math.max(...allPoints.map(p => -p[hAxis2Lower]));
                const rangeX = maxX - minX, rangeY = maxY - minY;
                const maxRange = Math.max(rangeX, rangeY, 0.1);
                const midX = (minX + maxX) / 2, midY = (minY + maxY) / 2;
                const gridMinX = midX - maxRange / 2, gridMinY = midY - maxRange / 2;
                const divisions = Math.ceil(maxRange / gridSize);
                const cols = Math.max(1, divisions), rows = Math.max(1, divisions);

                const grid = Array(rows).fill(0).map(() => Array(cols).fill(0));
                const timeSteps = {};
                const samplingRate = parseFloat(samplingRateInputWide.value);
                allPoints.forEach(p => {
                    const t = Math.floor(p.t / samplingRate);
                    if (!timeSteps[t]) timeSteps[t] = [];
                    timeSteps[t].push(p);
                });
                Object.values(timeSteps).forEach(pointsInStep => {
                    const visitedCells = new Set();
                    pointsInStep.forEach(point => {
                        const col = Math.floor((point[hAxis1Lower] - gridMinX) / gridSize);
                        const row = Math.floor((-point[hAxis2Lower] - gridMinY) / gridSize);
                        if (col >= 0 && col < cols && row >= 0 && row < rows) {
                            visitedCells.add(`${row}-${col}`);
                        }
                    });
                    visitedCells.forEach(cell => {
                        const [r, c] = cell.split('-').map(Number);
                        if (grid[r] !== undefined && grid[r][c] !== undefined) grid[r][c]++;
                    });
                });
                const maxCount = Math.max(0, ...[].concat(...grid));
                const gridInfo = { gridMinX, gridMinY, rows, cols, gridSize };
                return { grid, maxCount, gridInfo };
            }

            function drawHeatmapCanvasWide(grid, maxCount, hAxis1, hAxis2) {
                const canvas = document.getElementById('heatmap-canvas-wide');
                const container = document.getElementById('heatmap-container-wide');
                if (!container) return;
                const ctx = canvas.getContext('2d');
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const rows = grid.length;
                if (rows === 0 || grid[0].length === 0) return;
                const cols = grid[0].length;
                const cellWidth = canvas.width / cols, cellHeight = canvas.height / rows;
                if (maxCount > 0) {
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            const count = grid[r][c];
                            if (count > 0) {
                                const value = count / maxCount;
                                ctx.fillStyle = getColorForValueWide(value);
                                ctx.fillRect(c * cellWidth, (rows - 1 - r) * cellHeight, cellWidth + 1, cellHeight + 1);
                            }
                        }
                    }
                }
            }

            function getColorForValueWide(value) {
                // Blue -> Cyan -> Green -> Yellow -> Red
                const colors = [
                    { r: 0, g: 0, b: 255 }, // Blue
                    { r: 0, g: 255, b: 255 }, // Cyan
                    { r: 0, g: 255, b: 0 },   // Green
                    { r: 255, g: 255, b: 0 },   // Yellow
                    { r: 255, g: 0, b: 0 }    // Red
                ];

                const segment = 1 / (colors.length - 1);
                const index = Math.min(Math.floor(value / segment), colors.length - 2);
                const t = (value - (index * segment)) / segment;

                const r = colors[index].r + t * (colors[index + 1].r - colors[index].r);
                const g = colors[index].g + t * (colors[index + 1].g - colors[index].g);
                const b = colors[index].b + t * (colors[index + 1].b - colors[index].b);

                return `rgb(${r}, ${g}, ${b})`;
            }

            function switchViewWide(viewName) {
                trajectoryViewWide.classList.add('hidden');
                heatmapViewWide.classList.add('hidden');
                trajectory3DViewWide.classList.add('hidden');
                showTrajectoryBtnWide.classList.remove('active');
                showHeatmapBtnWide.classList.remove('active');
                show3DTrajectoryBtnWide.classList.remove('active');

                if (viewName === 'trajectory') {
                    trajectoryViewWide.classList.remove('hidden');
                    showTrajectoryBtnWide.classList.add('active');
                } else if (viewName === 'heatmap') {
                    heatmapViewWide.classList.remove('hidden');
                    showHeatmapBtnWide.classList.add('active');
                    if (lastHeatmapGridWide) {
                        const verticalAxis = verticalAxisSelectWide.value;
                        const axes = ['X', 'Y', 'Z'];
                        const horizontalAxes = axes.filter(ax => ax !== verticalAxis);
                        const hAxis1 = horizontalAxes[0];
                        const hAxis2 = horizontalAxes[1];
                        setTimeout(() => {
                            drawHeatmapCanvasWide(lastHeatmapGridWide.grid, lastHeatmapGridWide.maxCount, hAxis1, hAxis2);
                        }, 50);
                    }
                } else if (viewName === '3d-trajectory') {
                    trajectory3DViewWide.classList.remove('hidden');
                    show3DTrajectoryBtnWide.classList.add('active');
                    if (lastSampledDataWide && !is3DTrajectoryRendered) {
                        setTimeout(() => { // Use setTimeout to ensure the container is fully visible
                            draw3DTrajectory(lastSampledDataWide);
                            is3DTrajectoryRendered = true;
                        }, 50);
                    }
                }
            }

            function calculateDataCenterWide(allPoints) {
                if (allPoints.length === 0) return { x: 0, y: 0 };
                const sumX = allPoints.reduce((sum, p) => sum + p.x, 0);
                const sumY = allPoints.reduce((sum, p) => sum + p.y, 0);
                return { x: sumX / allPoints.length, y: sumY / allPoints.length };
            }

            function calculateAndDisplayCoverageWide() {
                if (!lastHeatmapGridWide || !lastHeatmapGridWide.gridInfo) {
                    alert('先にデータを解析してください。');
                    return;
                }

                const shape = document.querySelector('input[name="area-shape-wide"]:checked').value;
                const dataUnit = document.querySelector('input[name="data-unit-wide"]:checked').value;
                let size = parseFloat(areaSizeInputWide.value);
                if (isNaN(size) || size <= 0) {
                    alert('基準範囲のサイズには正の数値を入力してください。');
                    return;
                }

                let centerX, centerY;
                if (document.querySelector('input[name="center-type-wide"]:checked').value === 'custom') {
                    centerX = parseFloat(centerXInputWide.value);
                    centerY = parseFloat(centerYInputWide.value);
                    if (isNaN(centerX) || isNaN(centerY)) {
                        alert('中心座標には有効な数値を入力してください。');
                        return;
                    }
                } else {
                    const allPoints = [].concat(...Object.values(lastSampledDataWide));
                    const dataCenter = calculateDataCenterWide(allPoints);
                    centerX = dataCenter.x;
                    centerY = dataCenter.y;
                }

                if (dataUnit === 'mm') {
                    size /= 1000;
                    if (document.querySelector('input[name="center-type-wide"]:checked').value === 'custom') {
                        centerX /= 1000;
                        centerY /= 1000;
                    }
                }

                const { grid, gridInfo } = lastHeatmapGridWide;
                const { gridMinX, gridMinY, rows, cols, gridSize } = gridInfo;

                let totalCellsInArea = 0;
                let reachedCellsInArea = 0;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const cellCenterX = gridMinX + (c + 0.5) * gridSize;
                        const cellCenterY = gridMinY + (r + 0.5) * gridSize;

                        const dx = cellCenterX - centerX;
                        const dy = cellCenterY - centerY;

                        let isInArea = false;
                        if (shape === 'circle') {
                            if ((dx * dx + dy * dy) <= (size * size)) {
                                isInArea = true;
                            }
                        } else { // square
                            if (Math.abs(dx) <= size / 2 && Math.abs(dy) <= size / 2) {
                                isInArea = true;
                            }
                        }

                        if (isInArea) {
                            totalCellsInArea++;
                            if (grid[r][c] > 0) {
                                reachedCellsInArea++;
                            }
                        }
                    }
                }

                const coverage = totalCellsInArea > 0 ? (reachedCellsInArea / totalCellsInArea) * 100 : 0;
                coverageResultElWide.textContent = coverage.toFixed(2);

                // Visualize the area on the heatmap
                switchViewWide('heatmap');
                setTimeout(() => {
                    drawHeatmapCanvasWide(grid, lastHeatmapGridWide.maxCount);
                    const canvas = document.getElementById('heatmap-canvas-wide');
                    const ctx = canvas.getContext('2d');

                    const canvasWidth = canvas.width;
                    const canvasHeight = canvas.height;
                    const totalGridWidth = cols * gridSize;
                    const totalGridHeight = rows * gridSize;

                    const canvasCenterX = ((centerX - gridMinX) / totalGridWidth) * canvasWidth;
                    const canvasCenterY = canvasHeight - (((centerY - gridMinY) / totalGridHeight) * canvasHeight);

                    ctx.strokeStyle = '#0d9488';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);

                    if (shape === 'circle') {
                        const canvasRadius = (size / totalGridWidth) * canvasWidth;
                        ctx.beginPath();
                        ctx.arc(canvasCenterX, canvasCenterY, canvasRadius, 0, 2 * Math.PI);
                        ctx.stroke();
                    } else {
                        const canvasSide = (size / totalGridWidth) * canvasWidth;
                        ctx.strokeRect(canvasCenterX - canvasSide / 2, canvasCenterY - canvasSide / 2, canvasSide, canvasSide);
                    }
                    ctx.setLineDash([]);
                }, 100);
            }

            async function handleDownloadWide(event) {
                const { target, format } = event.target.dataset;
                const element = document.getElementById(target);
                if (!element) return;

                loadingDiv.classList.remove('hidden');
                loadingText.textContent = "画像を生成中...";

                await new Promise(resolve => setTimeout(resolve, 100));

                try {
                    const canvas = await html2canvas(element, { backgroundColor: '#ffffff', scale: 2 });
                    const image = canvas.toDataURL('image/png', 1.0);

                    if (format === 'png') {
                        const link = document.createElement('a');
                        link.href = image;
                        link.download = `${target}.png`;
                        link.click();
                    } else if (format === 'pdf') {
                        const { jsPDF } = window.jspdf;
                        const orientation = canvas.width > canvas.height ? 'landscape' : 'portrait';
                        const pdf = new jsPDF({ orientation, unit: 'px', format: [canvas.width, canvas.height] });
                        pdf.addImage(image, 'PNG', 0, 0, canvas.width, canvas.height);
                        pdf.save(`${target}.pdf`);
                    }
                } catch (error) {
                    alert("Download failed:", error);
                    alert("画像の生成に失敗しました。");
                } finally {
                    loadingDiv.classList.add('hidden');
                }
            }

            // --- DISTANCE MEASUREMENT TOOL SCRIPT ---
            const csvFilesDistance = document.getElementById('csv-files-distance');
            const fileNameDistance = document.getElementById('file-name-distance');
            const analysisTypeDistanceRadios = document.querySelectorAll('input[name="analysis-type-distance"]');
            const samplingRateDistance = document.getElementById('sampling-rate-distance');
            const enableDownsamplingCheckbox = document.getElementById('enable-downsampling-distance');
            const samplingRateContainer = document.getElementById('sampling-rate-container-distance');
            const dataUnitDistanceRadios = document.querySelectorAll('input[name="data-unit-distance"]');
            const pairSelectionArea = document.getElementById('pair-selection-area');
            const pairListContainer = document.getElementById('pair-list-container');
            const addPairBtn = document.getElementById('add-pair-btn');
            const analyzeBtnDistance = document.getElementById('analyze-btn-distance');
            const resultsCardDistance = document.getElementById('results-card-distance');
            const resultsTableBodyDistance = document.getElementById('results-table-body-distance');

            let fileDataStoreDistance = null;
            let pairCount = 0;

            if (csvFilesDistance) {
                csvFilesDistance.addEventListener('change', handleFileSelectDistance);
                addPairBtn.addEventListener('click', addPairRow);
                analyzeBtnDistance.addEventListener('click', calculateDistance);
                analysisTypeDistanceRadios.forEach(radio => radio.addEventListener('change', updatePairSelectors));
                enableDownsamplingCheckbox.addEventListener('change', (e) => {
                    samplingRateContainer.classList.toggle('hidden', !e.target.checked);
                });
            }

            function handleFileSelectDistance(event) {
                const file = event.target.files[0];
                if (!file) return;

                fileNameDistance.textContent = file.name;
                loadingDiv.classList.remove('hidden');
                loadingText.textContent = "ファイルを読み込み中...";

                Papa.parse(file, {
                    complete: (results) => {
                        try {
                            fileDataStoreDistance = parseHeaderDistance(results.data);
                            pairSelectionArea.classList.remove('hidden');
                            // Initialize with one pair row if empty
                            if (pairCount === 0) addPairRow();
                            updatePairSelectors(); // Populate selectors
                        } catch (error) {
                            alert(`解析エラー: ${error.message}`);
                            fileDataStoreDistance = null;
                            pairSelectionArea.classList.add('hidden');
                        } finally {
                            loadingDiv.classList.add('hidden');
                        }
                    },
                    error: (error) => {
                        alert(`ファイルの読み込みに失敗しました: ${error.message}`);
                        loadingDiv.classList.add('hidden');
                    }
                });
            }

            function parseHeaderDistance(data) {
                // Robust parsing for both Rigid Bodies and Markers
                let typeRowIndex = -1, nameRowIndex = -1, propertyRowIndex = -1, dataHeaderRowIndex = -1;
                for (let i = 0; i < Math.min(20, data.length); i++) {
                    const row = data[i];
                    if (!row || row.length < 2) continue;
                    if (row[1] === 'Type') typeRowIndex = i;
                    if (row[1] === 'Name') nameRowIndex = i;
                    if (row.includes('Position')) propertyRowIndex = i;
                    // Allow looser Time column match (starts with Time)
                    if (row[0] === 'Frame' && row[1] && row[1].startsWith('Time')) {
                        dataHeaderRowIndex = i;
                        break;
                    }
                }

                if ([typeRowIndex, nameRowIndex, propertyRowIndex, dataHeaderRowIndex].includes(-1)) {
                    throw new Error("CSVのヘッダー形式を認識できませんでした。");
                }

                const typeRow = data[typeRowIndex];
                const nameRow = data[nameRowIndex];
                const propertyRow = data[propertyRowIndex];
                const dataHeaderRow = data[dataHeaderRowIndex];
                const dataStartIndex = dataHeaderRowIndex + 1;

                const objects = {
                    rigidBodies: [],
                    markers: []
                };

                for (let i = 2; i < typeRow.length; i++) {
                    // Check for Position property
                    if (propertyRow[i] !== 'Position') continue;

                    const type = typeRow[i];
                    const name = nameRow[i];

                    // Identify object end index (assuming X, Y, Z are contiguous)
                    // Check if we have X, Y, Z
                    let xIndex = -1, yIndex = -1, zIndex = -1;

                    for (let j = 0; j < 3; j++) {
                        if (i + j < dataHeaderRow.length) {
                            const axis = dataHeaderRow[i + j].toUpperCase();
                            if (axis === 'X') xIndex = i + j;
                            if (axis === 'Y') yIndex = i + j;
                            if (axis === 'Z') zIndex = i + j;
                        }
                    }

                    if (xIndex !== -1 && yIndex !== -1 && zIndex !== -1) {
                        const objData = { name: name, xIndex, yIndex, zIndex };
                        if (type === 'Rigid Body') {
                            if (!objects.rigidBodies.find(o => o.name === name)) {
                                objects.rigidBodies.push(objData);
                            }
                        } else if (type === 'Marker') {
                            // Try to find if this marker belongs to a rigid body.
                            // Motive sometimes puts "RigidBodyName:MarkerName" in the Name row, or puts RigidBody name in a separate row if exported differently.
                            // Based on standard motive export (CSV), Name row usually contains the full unique name.
                            // However, sometimes it's grouped.
                            // Let's assume the name in 'Name' row is unique enough or formatted as "RB:Marker".
                            // The user requested: "マーカー一覧では，マーカー名の前に剛体名を入れることにしてください"
                            // If the CSV structure has a specific row for ID or Rigid Body Parent, we might use it.
                            // But standard "Take" export usually flattens it or puts it in Name.
                            // Let's use the Name column as is, assuming it contains necessary info,
                            // OR check if there's a convention.

                            // If the name is just "Marker1" and it belongs to "Robot", often it's "Robot:Marker1".
                            // We will just store it. If we can deduce a prefix from previous columns or similar, we might.
                            // But parsing strictly from columns:

                            if (!objects.markers.find(o => o.name === name)) {
                                objects.markers.push(objData);
                            }
                        }
                        // Advance index to skip Y and Z
                        // Note: The loop increments by 1, so we don't need to skip manually if we just process when propertyRow[i] is 'Position' (usually aligned with X).
                        // Actually, propertyRow usually has 'Position' for X, Y, Z columns or just one merged cell?
                        // In CSV, usually: Type, Type, Type... | Name, Name, Name... | Position, Position, Position... | X, Y, Z, X, Y, Z...
                        // So propertyRow[i] is 'Position' for X, Y, and Z.
                        // We should process only if we are at X (start of triplet).
                        // We can detect if dataHeaderRow[i] is 'X'.

                    }
                }

                // Refined loop to ensure we only pick up the start of a triplet
                const uniqueObjects = { rigidBodies: [], markers: [] };
                for (let i = 2; i < typeRow.length; i++) {
                    if (propertyRow[i] === 'Position' && dataHeaderRow[i].toUpperCase() === 'X') {
                        const type = typeRow[i];
                        const name = nameRow[i];
                        const xIndex = i;
                        const yIndex = i + 1;
                        const zIndex = i + 2;

                        // Verify Y and Z exist
                        if (yIndex < dataHeaderRow.length && dataHeaderRow[yIndex].toUpperCase() === 'Y' &&
                            zIndex < dataHeaderRow.length && dataHeaderRow[zIndex].toUpperCase() === 'Z') {

                            const obj = { name, xIndex, yIndex, zIndex };
                            if (type === 'Rigid Body') {
                                if (!uniqueObjects.rigidBodies.find(o => o.name === name)) uniqueObjects.rigidBodies.push(obj);
                            } else if (type === 'Marker') {
                                if (!uniqueObjects.markers.find(o => o.name === name)) uniqueObjects.markers.push(obj);
                            }
                        }
                    }
                }

                // Filter out empty lines from raw data
                const rawData = data.slice(dataStartIndex).filter(row => row.length > 1 && row[1] !== '');

                return { objects: uniqueObjects, rawData };
            }

            function addPairRow() {
                if (pairCount >= 5) {
                    alert("最大5件まで選択できます。");
                    return;
                }
                pairCount++;

                const rowId = `pair-row-${Date.now()}`;
                const div = document.createElement('div');
                div.className = 'pair-row flex items-center space-x-4 p-3 bg-slate-50 border rounded-md';
                div.id = rowId;
                div.innerHTML = `
                    <span class="font-medium text-slate-500 text-sm w-6">#${pairCount}</span>
                    <div class="flex-1 grid grid-cols-2 gap-4">
                        <div>
                            <label class="block text-xs text-slate-500 mb-1">点A</label>
                            <select class="pair-select-a block w-full bg-white border-slate-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 text-sm max-w-xs"></select>
                        </div>
                        <div>
                            <label class="block text-xs text-slate-500 mb-1">点B</label>
                            <select class="pair-select-b block w-full bg-white border-slate-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 text-sm max-w-xs"></select>
                        </div>
                    </div>
                    <button type="button" class="text-red-500 hover:text-red-700" onclick="removePairRow('${rowId}')">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                    </button>
                `;
                pairListContainer.appendChild(div);

                // Populate the new selects if data is loaded
                if (fileDataStoreDistance) {
                    updateSelectOptions(div.querySelector('.pair-select-a'));
                    updateSelectOptions(div.querySelector('.pair-select-b'));
                }

                updateAnalyzeButtonState();
            }

            // Expose remove function to global scope
            window.removePairRow = function (rowId) {
                const row = document.getElementById(rowId);
                if (row) {
                    row.remove();
                    pairCount--;
                    // Renumber rows? Optional but looks nicer
                    document.querySelectorAll('#pair-list-container .pair-row').forEach((row, index) => {
                        row.querySelector('span').textContent = `#${index + 1}`;
                    });
                    updateAnalyzeButtonState();
                }
            };

            function updateAnalyzeButtonState() {
                analyzeBtnDistance.disabled = pairCount === 0 || !fileDataStoreDistance;
            }

            function updatePairSelectors() {
                if (!fileDataStoreDistance) return;
                document.querySelectorAll('.pair-select-a, .pair-select-b').forEach(select => {
                    updateSelectOptions(select);
                });
            }

            function updateSelectOptions(selectElement) {
                const type = document.querySelector('input[name="analysis-type-distance"]:checked').value;
                const objects = fileDataStoreDistance.objects;
                const list = type === 'marker' ? objects.markers : objects.rigidBodies;

                const currentValue = selectElement.value;
                selectElement.innerHTML = '<option value="">選択してください</option>';

                list.forEach(obj => {
                    const option = document.createElement('option');
                    option.value = obj.name;
                    option.textContent = obj.name;
                    selectElement.appendChild(option);
                });

                if (currentValue) selectElement.value = currentValue;
            }

            function calculateDistance() {
                if (!fileDataStoreDistance) return;

                const pairs = [];
                document.querySelectorAll('.pair-row').forEach(row => {
                    const selectA = row.querySelector('.pair-select-a');
                    const selectB = row.querySelector('.pair-select-b');
                    if (selectA.value && selectB.value) {
                        pairs.push({ a: selectA.value, b: selectB.value });
                    }
                });

                if (pairs.length === 0) {
                    alert("有効なペアが選択されていません。");
                    return;
                }

                const type = document.querySelector('input[name="analysis-type-distance"]:checked').value;
                const objectList = type === 'marker' ? fileDataStoreDistance.objects.markers : fileDataStoreDistance.objects.rigidBodies;
                const isDownsampling = enableDownsamplingCheckbox.checked;
                const samplingRate = isDownsampling ? parseFloat(samplingRateDistance.value) : 0;
                const dataUnit = document.querySelector('input[name="data-unit-distance"]:checked').value;

                loadingDiv.classList.remove('hidden');
                loadingText.textContent = "解析中...";

                setTimeout(() => {
                    try {
                        const results = pairs.map(pair => {
                            const objA = objectList.find(o => o.name === pair.a);
                            const objB = objectList.find(o => o.name === pair.b);

                            if (!objA || !objB) return null;

                            const avgA = calculateAveragePosition(objA, samplingRate, isDownsampling, dataUnit);
                            const avgB = calculateAveragePosition(objB, samplingRate, isDownsampling, dataUnit);

                            // Euclidean distance between averages
                            const distance = Math.sqrt(
                                Math.pow(avgA.x - avgB.x, 2) +
                                Math.pow(avgA.y - avgB.y, 2) +
                                Math.pow(avgA.z - avgB.z, 2)
                            );

                            return { pair, avgA, avgB, distance };
                        }).filter(r => r !== null);

                        displayDistanceResults(results);

                    } catch (e) {
                        alert(e);
                        alert("計算中にエラーが発生しました。");
                    } finally {
                        loadingDiv.classList.add('hidden');
                    }
                }, 50);
            }

            function calculateAveragePosition(objInfo, samplingRate, isDownsampling, dataUnit) {
                const rawData = fileDataStoreDistance.rawData;
                let sumX = 0, sumY = 0, sumZ = 0;
                let count = 0;
                let nextSampleTime = -1; // Process first frame always

                for (const row of rawData) {
                    const time = parseFloat(row[1]);
                    if (isNaN(time)) continue;

                    if (!isDownsampling || time >= nextSampleTime) {
                        let x = parseFloat(row[objInfo.xIndex]);
                        let y = parseFloat(row[objInfo.yIndex]);
                        let z = parseFloat(row[objInfo.zIndex]);

                        if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                            if (dataUnit === 'mm') {
                                x /= 1000;
                                y /= 1000;
                                z /= 1000;
                            }
                            sumX += x;
                            sumY += y;
                            sumZ += z;
                            count++;
                        }
                        if (isDownsampling) {
                            if (nextSampleTime === -1) nextSampleTime = time; // Initialize on first valid frame
                            nextSampleTime += samplingRate;
                        }
                    }
                }

                if (count === 0) return { x: 0, y: 0, z: 0 };
                return { x: sumX / count, y: sumY / count, z: sumZ / count };
            }

            function displayDistanceResults(results) {
                resultsTableBodyDistance.innerHTML = '';
                results.forEach(res => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `
                        <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-slate-900">
                            ${res.pair.a} <span class="text-slate-400 mx-1">↔</span> ${res.pair.b}
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-700 font-bold">
                            ${res.distance.toFixed(4)}
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-500">
                            (${res.avgA.x.toFixed(3)}, ${res.avgA.y.toFixed(3)}, ${res.avgA.z.toFixed(3)})
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-500">
                            (${res.avgB.x.toFixed(3)}, ${res.avgB.y.toFixed(3)}, ${res.avgB.z.toFixed(3)})
                        </td>
                    `;
                    resultsTableBodyDistance.appendChild(tr);
                });

                resultsCardDistance.classList.remove('hidden');
                resultsCardDistance.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }


            // --- DATA TRIMMING TOOL SCRIPT ---
            const csvFileTrimming = document.getElementById('csv-file-trimming');
            const fileNameTrimming = document.getElementById('file-name-trimming');
            const rigidbodySelectTrimming = document.getElementById('rigidbody-select-trimming');
            const trimmingEditorArea = document.getElementById('trimming-editor-area');
            const trimmingChartCanvas = document.getElementById('trimming-chart');
            const trimStartTimeInput = document.getElementById('trim-start-time');
            const trimEndTimeInput = document.getElementById('trim-end-time');
            const exportTrimmingBtn = document.getElementById('export-trimming-btn');
            const trimmingDownsampleCheckbox = document.getElementById('trimming-downsample');

            window.trimmingDataStore = null; let trimmingDataStore = null;
            window.trimmingChart = null; let trimmingChart = null;
            let trimmingDragTarget = null;

            if (csvFileTrimming) {
                csvFileTrimming.addEventListener('change', handleFileSelectTrimming);
                rigidbodySelectTrimming.addEventListener('change', updateTrimmingChart);
                trimStartTimeInput.addEventListener('change', updateChartAnnotations);
                trimEndTimeInput.addEventListener('change', updateChartAnnotations);
                exportTrimmingBtn.addEventListener('click', exportTrimmedCSV);
                trimmingDownsampleCheckbox.addEventListener('change', updateTrimmingChart);
            }

            function handleFileSelectTrimming(event) {
                const file = event.target.files[0];
                if (!file) return;

                fileNameTrimming.textContent = file.name;
                loadingDiv.classList.remove('hidden');
                loadingText.textContent = "ファイルを読み込み中...";

                Papa.parse(file, {
                    complete: (results) => {
                        try {
                            window.trimmingDataStore = trimmingDataStore = parseHeaderTrimming(results.data);
                            populateTrimmingRigidBodies();
                            trimmingEditorArea.classList.remove('hidden');

                            // Initialize times based on data range
                            const firstTime = trimmingDataStore.times[0];
                            const lastTime = trimmingDataStore.times[trimmingDataStore.times.length - 1];
                            trimStartTimeInput.value = firstTime.toFixed(3);
                            trimEndTimeInput.value = lastTime.toFixed(3);

                            // Select first rigid body and draw
                            if (rigidbodySelectTrimming.options.length > 1) {
                                rigidbodySelectTrimming.selectedIndex = 1;
                                updateTrimmingChart();
                            }
                        } catch (error) {
                            alert(`解析エラー: ${error.message}`);
                            trimmingDataStore = null;
                            trimmingEditorArea.classList.add('hidden');
                        } finally {
                            loadingDiv.classList.add('hidden');
                        }
                    },
                    error: (error) => {
                        alert(`ファイルの読み込みに失敗しました: ${error.message}`);
                        loadingDiv.classList.add('hidden');
                    }
                });
            }

            function parseHeaderTrimming(data) {
                // Similar parsing logic, but we keep raw rows for export
                // Adopt robust logic from parseHeaderWide
                let typeRowIndex = -1, nameRowIndex = -1, propertyRowIndex = -1, dataHeaderRowIndex = -1;
                for (let i = 0; i < Math.min(20, data.length); i++) {
                    const row = data[i];
                    if (!row || row.length < 2) continue;
                    if (row[1] === 'Type') typeRowIndex = i;
                    if (row[1] === 'Name') nameRowIndex = i;
                    if (row.includes('Position')) propertyRowIndex = i;
                    // Allow looser Time column match
                    if (row[0] === 'Frame' && row[1] && row[1].startsWith('Time')) {
                        dataHeaderRowIndex = i;
                        break;
                    }
                }

                if ([typeRowIndex, nameRowIndex, propertyRowIndex, dataHeaderRowIndex].includes(-1)) {
                    throw new Error("CSVのヘッダー形式を認識できませんでした。");
                }

                const typeRow = data[typeRowIndex];
                const nameRow = data[nameRowIndex];
                const propertyRow = data[propertyRowIndex];
                const dataHeaderRow = data[dataHeaderRowIndex];
                const dataStartIndex = dataHeaderRowIndex + 1;

                const rigidBodies = [];
                for (let i = 2; i < typeRow.length; i++) {
                    if (typeRow[i] === 'Rigid Body' && propertyRow[i] === 'Position') {
                        const name = nameRow[i];
                        if (rigidBodies.find(rb => rb.name === name)) continue;

                        // Assume contiguous columns for X, Y, Z if Position property found
                        // This mirrors the robust logic in Data Analysis tool
                        const xIndex = i;
                        const yIndex = i + 1;
                        const zIndex = i + 2;

                        // Basic validation that columns exist and belong to the same rigid body/property
                        if (zIndex < typeRow.length &&
                            nameRow[yIndex] === name && propertyRow[yIndex] === 'Position' &&
                            nameRow[zIndex] === name && propertyRow[zIndex] === 'Position') {

                            rigidBodies.push({
                                name: name,
                                xIndex: xIndex,
                                yIndex: yIndex,
                                zIndex: zIndex
                            });
                        }
                    }
                }

                // Extract times and raw data
                // We keep raw data rows to allow slicing for export
                const rawDataRows = data.slice(dataStartIndex).filter(row => row.length > 1 && row[1] !== '');
                const times = rawDataRows.map(row => parseFloat(row[1]));
                const frames = rawDataRows.map(row => parseInt(row[0]));

                return {
                    headerRows: data.slice(0, dataStartIndex),
                    rawDataRows: rawDataRows,
                    times: times,
                    frames: frames,
                    rigidBodies: rigidBodies
                };
            }

            function populateTrimmingRigidBodies() {
                rigidbodySelectTrimming.innerHTML = '<option value="">剛体を選択してください</option>';
                rigidbodySelectTrimming.disabled = false;
                trimmingDataStore.rigidBodies.forEach(rb => {
                    const option = document.createElement('option');
                    option.value = rb.name;
                    option.textContent = rb.name;
                    rigidbodySelectTrimming.appendChild(option);
                });

                // Add "All" option if needed, but plotting all might be messy. The user asked for it though.
                const allOption = document.createElement('option');
                allOption.value = 'ALL_BODIES';
                allOption.textContent = 'すべての剛体';
                rigidbodySelectTrimming.appendChild(allOption);
            }

            function updateTrimmingChart() {
                if (!trimmingDataStore) return;

                const selectedBodyName = rigidbodySelectTrimming.value;
                if (!selectedBodyName) return;

                const isDownsampling = trimmingDownsampleCheckbox.checked;

                const ctx = trimmingChartCanvas.getContext('2d');
                if (trimmingChart) trimmingChart.destroy();

                const datasets = [];
                const colors = ['#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6'];

                let targetBodies = [];
                if (selectedBodyName === 'ALL_BODIES') {
                    targetBodies = trimmingDataStore.rigidBodies;
                } else {
                    targetBodies = trimmingDataStore.rigidBodies.filter(rb => rb.name === selectedBodyName);
                }

                targetBodies.forEach((rb, index) => {
                    const colorGroup = colors[index % colors.length];

                    const dataX = [];
                    const dataY = [];
                    const dataZ = [];

                    const rawRows = trimmingDataStore.rawDataRows;
                    const step = isDownsampling ? Math.max(1, Math.floor(rawRows.length / 2000)) : 1; // Limit to ~2000 points

                    for(let i=0; i<rawRows.length; i+=step) {
                        const row = rawRows[i];
                        const t = parseFloat(row[1]);
                        const x = parseFloat(row[rb.xIndex]);
                        const y = parseFloat(row[rb.yIndex]);
                        const z = parseFloat(row[rb.zIndex]);

                        if (!isNaN(t) && !isNaN(x)) {
                            dataX.push({x: t, y: x});
                            dataY.push({x: t, y: y});
                            dataZ.push({x: t, y: z});
                        }
                    }

                    datasets.push({
                        label: `${rb.name} X`,
                        data: dataX,
                        borderColor: '#ef4444', // Red for X
                        borderWidth: 1,
                        pointRadius: 0,
                        hidden: selectedBodyName === 'ALL_BODIES' // Hide detailed axes if ALL selected to prevent clutter, logic below
                    });
                    datasets.push({
                        label: `${rb.name} Y`,
                        data: dataY,
                        borderColor: '#10b981', // Green for Y (Motive style usually Y up) or just distinct
                        borderWidth: 1,
                        pointRadius: 0,
                         hidden: selectedBodyName === 'ALL_BODIES'
                    });
                    datasets.push({
                        label: `${rb.name} Z`,
                        data: dataZ,
                        borderColor: '#3b82f6', // Blue for Z
                        borderWidth: 1,
                        pointRadius: 0,
                         hidden: selectedBodyName === 'ALL_BODIES'
                    });
                });

                // If ALL_BODIES, maybe just plot one axis or magnitude? Or just plotting X of all?
                // The user said "All rigid bodies".
                // To avoid chaos, if ALL is selected, let's plot only Y (Height) or maybe a magnitude?
                // Or just loop and add them all. The user can toggle legend.
                // Let's stick to adding them all but maybe just one representative axis if too many?
                // No, let's keep it simple: Standard X, Y, Z for selected.
                // For "ALL", the code above adds 3 datasets per body.

                if (selectedBodyName === 'ALL_BODIES') {
                    // Override colors to distinguish bodies instead of axes
                    datasets.forEach((ds, i) => {
                        const bodyIndex = Math.floor(i / 3);
                        ds.borderColor = colors[bodyIndex % colors.length];
                        ds.hidden = false;
                        ds.label = `${ds.label}`; // Already includes body name
                    });
                }

                const startTime = parseFloat(trimStartTimeInput.value);
                const endTime = parseFloat(trimEndTimeInput.value);

                window.trimmingChart = trimmingChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'nearest',
                            axis: 'x',
                            intersect: false
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                title: { display: true, text: 'Time (s)' }
                            },
                            y: {
                                title: { display: true, text: 'Position (m)' } // Assuming M? Or matches input unit.
                                // Actually raw data unit.
                            }
                        },
                        plugins: {
                            zoom: {
                                zoom: {
                                    wheel: { enabled: true },
                                    pinch: { enabled: true },
                                    mode: 'x',
                                },
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    onPan: function({chart}) {
                                        // Block panning if dragging lines
                                        return !trimmingDragTarget;
                                    }
                                }
                            },
                            annotation: {
                                annotations: {
                                    box1: {
                                        type: 'box',
                                        xMin: startTime,
                                        xMax: endTime,
                                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                        borderColor: 'rgba(59, 130, 246, 0.5)',
                                        borderWidth: 1,
                                        init: function(chart) {
                                             // This init runs once?
                                        }
                                    },
                                    lineStart: {
                                        type: 'line',
                                        scaleID: 'x',
                                        value: startTime,
                                        borderColor: '#2563eb',
                                        borderWidth: 2,
                                        label: {
                                            display: true,
                                            content: 'Start',
                                            position: 'start'
                                        },
                                        draggable: true,
                                        onDrag: function(event) {
                                            // event.subject.value is the new value
                                            // But for 'line' annotation in chartjs-plugin-annotation v3, checking docs
                                            // v1 used onDrag. v3 uses event listeners?
                                            // Let's check typical usage for v3.
                                            // It supports `draggable` inside `enter`, `leave`, etc? No.
                                            // Actually chartjs-plugin-annotation supports dragging but requires configuration.
                                        }
                                    },
                                    lineEnd: {
                                        type: 'line',
                                        scaleID: 'x',
                                        value: endTime,
                                        borderColor: '#2563eb',
                                        borderWidth: 2,
                                        label: {
                                            display: true,
                                            content: 'End',
                                            position: 'start'
                                        },
                                        draggable: true
                                    }
                                }
                            }
                        }
                    }
                });

                // Add drag handlers manually since simpler config might fail or differ by version
                // For Annotation v3, we need to enable events.
                // Re-configuring annotations correctly for dragging:

                const annotationOptions = {
                    common: {
                        drawTime: 'afterDatasetsDraw'
                    },
                    annotations: {
                        rangeBox: {
                            type: 'box',
                            xMin: startTime,
                            xMax: endTime,
                            backgroundColor: 'rgba(37, 99, 235, 0.1)',
                            borderWidth: 0
                        },
                        startLine: {
                            type: 'line',
                            scaleID: 'x',
                            value: startTime,
                            borderColor: '#2563eb',
                            borderWidth: 4,
                            label: { content: 'Start', display: true, position: 'top' },
                        },
                        endLine: {
                            type: 'line',
                            scaleID: 'x',
                            value: endTime,
                            borderColor: '#2563eb',
                            borderWidth: 4,
                            label: { content: 'End', display: true, position: 'top' },
                        }
                    }
                };

                trimmingChart.options.plugins.annotation = annotationOptions;

                // Add event listeners for dragging simulation or use built-in if configured correctly
                // Dragging in chartjs-plugin-annotation is tricky to get right without explicit 'draggable' config which changed between versions.
                // Assuming v3 (CDN loaded), we use a custom drag logic using chart events or use the 'enter'/'leave' hooks to change cursor.

                // Simplest approach: Use chart `onClick` to snap closest line to click position?
                // Or implement standard drag logic on the canvas.

                // Let's implement a simple "Click to move closest limit" logic for robustness,
                // OR standard dragging logic.
                // Given "Video editor style", dragging is best.

                // Let's try to use the `dragger` logic attached to the chart instance
                enableChartDrag(trimmingChart);

                trimmingChart.update();
            }

            function enableChartDrag(chart) {
                // trimmingDragTarget is global to share state with zoom plugin

                chart.canvas.addEventListener('pointerdown', (evt) => {
                    const points = Chart.helpers.getRelativePosition(evt, chart);
                    const dataX = chart.scales.x.getValueForPixel(points.x);

                    const startVal = parseFloat(trimStartTimeInput.value);
                    const endVal = parseFloat(trimEndTimeInput.value);

                    // Check proximity (in pixels)
                    const startX = chart.scales.x.getPixelForValue(startVal);
                    const endX = chart.scales.x.getPixelForValue(endVal);

                    const threshold = 10;
                    if (Math.abs(points.x - startX) < threshold) {
                        trimmingDragTarget = 'start';
                        chart.canvas.style.cursor = 'ew-resize';
                    } else if (Math.abs(points.x - endX) < threshold) {
                        trimmingDragTarget = 'end';
                        chart.canvas.style.cursor = 'ew-resize';
                    } else {
                        trimmingDragTarget = null;
                        chart.canvas.style.cursor = 'default';
                    }
                });

                chart.canvas.addEventListener('pointermove', (evt) => {
                    const points = Chart.helpers.getRelativePosition(evt, chart);

                    if (trimmingDragTarget) {
                        let newVal = chart.scales.x.getValueForPixel(points.x);
                        // Clamp to data range
                        const minTime = trimmingDataStore.times[0];
                        const maxTime = trimmingDataStore.times[trimmingDataStore.times.length-1];
                        newVal = Math.max(minTime, Math.min(maxTime, newVal));

                        if (trimmingDragTarget === 'start') {
                             trimStartTimeInput.value = newVal.toFixed(3);
                        } else {
                             trimEndTimeInput.value = newVal.toFixed(3);
                        }
                        updateChartAnnotations(); // Refresh chart visuals
                    } else {
                        // Just hover effect
                         const startVal = parseFloat(trimStartTimeInput.value);
                         const endVal = parseFloat(trimEndTimeInput.value);
                         const startX = chart.scales.x.getPixelForValue(startVal);
                         const endX = chart.scales.x.getPixelForValue(endVal);
                         const threshold = 10;
                         if (Math.abs(points.x - startX) < threshold || Math.abs(points.x - endX) < threshold) {
                             chart.canvas.style.cursor = 'ew-resize';
                         } else {
                             chart.canvas.style.cursor = 'grab'; // Indicate panning is possible
                         }
                    }
                });

                chart.canvas.addEventListener('pointerup', () => {
                    trimmingDragTarget = null;
                    chart.canvas.style.cursor = 'grab';
                });

                // Disable chart zoom pan while dragging
                // (Handled by checking if dragTarget is set? Zoom plugin might interfere)
                // We might need to disable zoom/pan dynamically if dragging.
            }

            function updateChartAnnotations() {
                if (!trimmingChart) return;

                let start = parseFloat(trimStartTimeInput.value);
                let end = parseFloat(trimEndTimeInput.value);

                if (start > end) {
                    // Don't swap inputs while dragging, just visualize correctly or clamp?
                    // Let's just allow it but box will be weird.
                }

                trimmingChart.options.plugins.annotation.annotations.startLine.value = start;
                trimmingChart.options.plugins.annotation.annotations.endLine.value = end;
                trimmingChart.options.plugins.annotation.annotations.rangeBox.xMin = Math.min(start, end);
                trimmingChart.options.plugins.annotation.annotations.rangeBox.xMax = Math.max(start, end);

                trimmingChart.update('none'); // Update without animation
            }

            function exportTrimmedCSV() {
                if (!trimmingDataStore) return;

                const start = parseFloat(trimStartTimeInput.value);
                const end = parseFloat(trimEndTimeInput.value);

                if (start >= end) {
                    alert('開始時間は終了時間より前である必要があります。');
                    return;
                }

                loadingDiv.classList.remove('hidden');
                loadingText.textContent = "CSVを生成中...";

                setTimeout(() => {
                    try {
                        // Filter rows
                        const dataStartIndex = 0; // Relative to rawDataRows
                        // Find index of start time
                        // Assuming times are sorted
                        const times = trimmingDataStore.times;

                        let startIndex = times.findIndex(t => t >= start);
                        if (startIndex === -1) startIndex = 0;

                        let endIndex = times.findIndex(t => t > end);
                        if (endIndex === -1) endIndex = times.length; // Until end

                        const slicedRows = trimmingDataStore.rawDataRows.slice(startIndex, endIndex);

                        if (slicedRows.length === 0) {
                            throw new Error("選択された範囲にデータがありません。");
                        }

                        // Re-index Frame and Time
                        const startTimeOffset = parseFloat(slicedRows[0][1]);
                        const processedRows = slicedRows.map((row, idx) => {
                            const newRow = [...row];
                            newRow[0] = (idx + 1).toString(); // Frame starts at 1
                            const oldTime = parseFloat(newRow[1]);
                            newRow[1] = (oldTime - startTimeOffset).toFixed(3); // Time starts at 0
                            return newRow;
                        });

                        // Construct CSV
                        // 1. Header Rows (unparsed, from PapaParse meta? No, we kept them manually)
                        // Papa.unparse takes array of objects or arrays.
                        // We have array of arrays.

                        const headerCsv = Papa.unparse(trimmingDataStore.headerRows, { delimiter: ",", newline: "\r\n" });
                        const dataCsv = Papa.unparse(processedRows, { delimiter: ",", newline: "\r\n" });

                        const fullCsv = headerCsv + "\r\n" + dataCsv;

                        const blob = new Blob([fullCsv], { type: 'text/csv;charset=utf-8;' });
                        const link = document.createElement('a');
                        const url = URL.createObjectURL(blob);
                        link.setAttribute('href', url);
                        link.setAttribute('download', `trimmed_${fileNameTrimming.textContent}`);
                        link.style.visibility = 'hidden';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);

                    } catch (e) {
                        alert(`エクスポートエラー: ${e.message}`);
                    } finally {
                        loadingDiv.classList.add('hidden');
                    }
                }, 100);
            }


            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./service-worker.js')
                        .then(registration => {
                            console.log('Service Worker registered: ', registration);
                        })
                        .catch(error => {
                            console.log('Service Worker registration failed: ', error);
                        });
                });
            }
        });
    </script>
</body>

</html>